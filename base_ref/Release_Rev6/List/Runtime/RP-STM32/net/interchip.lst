###############################################################################
#
# IAR ANSI C/C++ Compiler V9.10.2.313/W64 for ARM         28/Jul/2021  15:57:38
# Copyright 1999-2021 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\infra_pub\arch\infra_stm32\net\interchip.c
#    Command line                 =
#        -f
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\Release_Rev6\List\Runtime\RP-STM32\net\interchip.lst.rsp
#        (C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\infra_pub\arch\infra_stm32\net\interchip.c
#        -D USE_STDPERIPH_DRIVER -D STM32F10X_HD -D USART_ENABLE_USART3 -D
#        CONFIG_BREAKOUT_REV=6 -D USE_FRONT_IR_SENSORS -D FEATURE_SET_V -lCN
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\Release_Rev6\List\Runtime\RP-STM32\net
#        --diag_suppress Pa050 -o
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\Release_Rev6\Obj\Runtime\RP-STM32\net
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        9.0\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\src\
#        -I
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\..\..\common\inc\
#        -I
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\..\infra_pub\
#        -I
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\..\infra_pub\arch\st_fwlib\CMSIS\CM3\CoreSupport\
#        -I
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\..\infra_pub\arch\st_fwlib\CMSIS\CM3\DeviceSupport\ST\STM32F10x\
#        -I
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\..\infra_pub\arch\st_fwlib\STM32F10x_StdPeriph_Driver\inc\
#        -I
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\..\infra_pub\arch\infra_stm32\
#        -I
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\..\infra_pub\arch\infra_stm32\32f10x\
#        -Ohz --use_c++_inline) --dependencies=n
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\Release_Rev6\Obj\Runtime\RP-STM32\net\interchip.o.d
#    Locale                       =  C
#    List file                    =
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\Release_Rev6\List\Runtime\RP-STM32\net\interchip.lst
#    Object file                  =
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\Release_Rev6\Obj\Runtime\RP-STM32\net\interchip.o
#    Runtime model:                  
#      __SystemLibrary            =  DLib
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#
###############################################################################

C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\infra_pub\arch\infra_stm32\net\interchip.c
      1          /*
      2           * SlamTec Infra Runtime Public
      3           * Copyright 2009 - 2017 RoboPeak
      4           * Copyright 2013 - 2017 Shanghai SlamTec Co., Ltd.
      5           * http://www.slamtec.com
      6           * All rights reserved.
      7           */
      8          /*
      9           * Redistribution and use in source and binary forms, with or without modification,
     10           * are permitted provided that the following conditions are met:
     11           *
     12           * 1. Redistributions of source code must retain the above copyright notice,
     13           *    this list of conditions and the following disclaimer.
     14           *
     15           * 2. Redistributions in binary form must reproduce the above copyright notice,
     16           *    this list of conditions and the following disclaimer in the documentation
     17           *    and/or other materials provided with the distribution.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
     20           * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
     21           * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
     22           * SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
     23           * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
     24           * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
     25           * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
     26           * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     27           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     28           *
     29           */
     30          
     31          #include "common/common.h"
     32          #include "net/interchip.h"
     33          
     34          #define PKT_STATE_NULL  0x00
     35          #define PKT_STATE_READY 0x80
     36          #define PKT_STATE_CHECKSUM_FAIL PKT_ERRORCODE_CHECKSUM_FAIL
     37          #define PKT_STATE_SIZE_OVERFLOW PKT_ERRORCODE_SIZE_OVERFLOW
     38          #define PKT_STATE_NOT_SYNC_PKT  PKT_ERRORCODE_NOT_SYNC_PKT
     39          
     40          #define PKT_STATE_WAIT_LEN     (1)
     41          #define PKT_STATE_WAIT_LEN_EX  (2)
     42          #define PKT_STATE_WAIT_DATA_AND_CHK    (3)
     43          #define PKT_STATE_WAIT_DATA    (4)
     44          

   \                                 In section .text, align 4, keep-with-next
     45          static void _interchip_on_rx(infra_channel_desc_t * handle, void * data_arr, size_t size)
     46          {
   \                     _interchip_on_rx: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x4688             MOV      R8,R1
   \        0x8   0x4616             MOV      R6,R2
     47              infra_channel_desc_t * desc = (infra_channel_desc_t *)handle;
   \        0xA   0xE01A             B.N      ??_interchip_on_rx_1
     48          
     49              while (size -- ) {
     50                  _u8  data = *((_u8 *)data_arr);
     51                  data_arr = ((_u8 *)data_arr) + 1;
     52          
     53                  _u32 cached_state = desc->rx_state >>16;
     54          
     55                  if ( cached_state & PKT_STATE_READY)
     56                  {
     57                      desc->rx_state |= PKT_STATE_NOT_SYNC_PKT;
     58                      alert();
     59                      return ;
     60                  }
     61          
     62                  if ( desc->rx_pos == 0 )
     63                  {
     64                      if ( data == LIT_PKT_CMD_FLAG
     65              #ifdef INTERCHIP_RX_ENABLE_LONGFRAME
     66                          ||  data == LONG_PKT_CMD_FLAG
     67              #endif
     68                          )
     69                      {
     70                          desc->rx_checksum = 0;
     71                          cached_state = PKT_STATE_WAIT_LEN;
     72                      } else {
     73                          desc->rx_state |= PKT_STATE_NOT_SYNC_PKT;
     74                          alert();
     75                          return;
     76                      }
     77                  }
     78                  else
     79                  {
     80                      switch (cached_state) {
     81          
     82                      case PKT_STATE_WAIT_LEN:
     83              #ifdef INTERCHIP_RX_ENABLE_LONGFRAME
     84                      case PKT_STATE_WAIT_LEN_EX:
     85                          if ( desc->rxbuffer[0] == LONG_PKT_CMD_FLAG && cached_state==PKT_STATE_WAIT_LEN) {
     86                              ++cached_state;
     87                              break;
     88                          }
     89              #endif
     90                          cached_state = PKT_STATE_WAIT_DATA_AND_CHK;
     91                          break;
     92                      case PKT_STATE_WAIT_DATA_AND_CHK:
     93                          if ( net_get_request_size(desc) + desc->rx_pos > desc->rxbuffersize)
     94                          {
     95                             desc->rx_state |= PKT_STATE_SIZE_OVERFLOW;
     96                             desc->rx_pos = 0;
     97                             alert();
     98                             return;
     99                          }
    100                          ++ cached_state;
   \                     ??_interchip_on_rx_2: (+1)
   \        0xC   0x2504             MOVS     R5,#+4
    101                      case PKT_STATE_WAIT_DATA:
    102          
    103                          if (desc->rx_pos == net_get_request_size(desc) + ( (desc->rxbuffer[0] == LONG_PKT_CMD_FLAG)?3:2))
   \                     ??_interchip_on_rx_3: (+1)
   \        0xE   0x4620             MOV      R0,R4
   \       0x10   0x.... 0x....      BL       net_get_request_size
   \       0x14   0x6821             LDR      R1,[R4, #+0]
   \       0x16   0x780A             LDRB     R2,[R1, #+0]
   \       0x18   0x2A50             CMP      R2,#+80
   \       0x1A   0xBF14             ITE      NE
   \       0x1C   0x2102             MOVNE    R1,#+2
   \       0x1E   0x2103             MOVEQ    R1,#+3
   \       0x20   0x8BA2             LDRH     R2,[R4, #+28]
   \       0x22   0x1808             ADDS     R0,R1,R0
   \       0x24   0x4282             CMP      R2,R0
   \       0x26   0xD049             BEQ.N    ??_interchip_on_rx_4
   \       0x28   0x042D             LSLS     R5,R5,#+16
    104                          {
    105                              if (data != desc->rx_checksum)
    106                              {
    107                                  desc->rx_state |= PKT_STATE_CHECKSUM_FAIL;
    108                              }
    109                              desc->rx_state |= PKT_STATE_READY;
    110                              desc->rx_pos = 0;
    111                              alert();
    112                              return;
    113                          }
    114                          break;
    115                      default :
    116                          desc->rx_pos = 0;
    117                          return;
    118                      }
    119                  }
    120                  desc->rx_checksum ^=(uint8_t)(data & 0xFF);
   \                     ??_interchip_on_rx_5: (+1)
   \       0x2A   0x7FA0             LDRB     R0,[R4, #+30]
   \       0x2C   0x4078             EORS     R0,R7,R0
   \       0x2E   0x77A0             STRB     R0,[R4, #+30]
    121                  desc->rxbuffer[desc->rx_pos++] = data;
   \       0x30   0x8BA0             LDRH     R0,[R4, #+28]
   \       0x32   0x1C41             ADDS     R1,R0,#+1
   \       0x34   0x83A1             STRH     R1,[R4, #+28]
   \       0x36   0x6822             LDR      R2,[R4, #+0]
   \       0x38   0x5417             STRB     R7,[R2, R0]
    122                  desc->rx_state = (cached_state<<16) | (desc->rx_state & 0xFFFF);
   \       0x3A   0x69A0             LDR      R0,[R4, #+24]
   \       0x3C   0xB280             UXTH     R0,R0
   \       0x3E   0x4305             ORRS     R5,R0,R5
   \       0x40   0x61A5             STR      R5,[R4, #+24]
   \                     ??_interchip_on_rx_1: (+1)
   \       0x42   0x4630             MOV      R0,R6
   \       0x44   0x1E46             SUBS     R6,R0,#+1
   \       0x46   0xB1B0             CBZ.N    R0,??_interchip_on_rx_6
   \       0x48   0xF818 0x7B01      LDRB     R7,[R8], #+1
   \       0x4C   0x69A5             LDR      R5,[R4, #+24]
   \       0x4E   0x0C2D             LSRS     R5,R5,#+16
   \       0x50   0x0629             LSLS     R1,R5,#+24
   \       0x52   0xD408             BMI.N    ??_interchip_on_rx_7
   \       0x54   0x8BA0             LDRH     R0,[R4, #+28]
   \       0x56   0xB980             CBNZ.N   R0,??_interchip_on_rx_8
   \       0x58   0x2F10             CMP      R7,#+16
   \       0x5A   0xBF12             ITEE     NE
   \       0x5C   0x2F50             CMPNE    R7,#+80
   \       0x5E   0x77A0             STRBEQ   R0,[R4, #+30]
   \       0x60   0xF44F 0x3580      MOVEQ    R5,#+65536
   \       0x64   0xD0E1             BEQ.N    ??_interchip_on_rx_5
   \                     ??_interchip_on_rx_7: (+1)
   \       0x66   0x69A0             LDR      R0,[R4, #+24]
   \       0x68   0xF040 0x0010      ORR      R0,R0,#0x10
   \       0x6C   0x61A0             STR      R0,[R4, #+24]
   \                     ??_interchip_on_rx_9: (+1)
   \       0x6E   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \       0x72   0x.... 0x....      B.W      alert
   \                     ??_interchip_on_rx_6: (+1)
   \       0x76   0xE8BD 0x81F0      POP      {R4-R8,PC}
   \                     ??_interchip_on_rx_8: (+1)
   \       0x7A   0x1E68             SUBS     R0,R5,#+1
   \       0x7C   0x2803             CMP      R0,#+3
   \       0x7E   0xD82A             BHI.N    ??_interchip_on_rx_10
   \       0x80   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??_interchip_on_rx_0:
   \       0x84   0x03 0x03          DC8      0x3,0x3,0xD,0x2

   \              0x0D 0x02
   \                     ??_interchip_on_rx_11: (+1)
   \       0x88   0xE7C1             B.N      ??_interchip_on_rx_3
   \                     ??_interchip_on_rx_12: (+1)
   \       0x8A   0x6820             LDR      R0,[R4, #+0]
   \       0x8C   0x7801             LDRB     R1,[R0, #+0]
   \       0x8E   0x2950             CMP      R1,#+80
   \       0x90   0xBF0A             ITET     EQ
   \       0x92   0x2D01             CMPEQ    R5,#+1
   \       0x94   0xF44F 0x3540      MOVNE    R5,#+196608
   \       0x98   0xF44F 0x3500      MOVEQ    R5,#+131072
   \       0x9C   0xE7C5             B.N      ??_interchip_on_rx_5
   \                     ??_interchip_on_rx_13: (+1)
   \       0x9E   0x4620             MOV      R0,R4
   \       0xA0   0x.... 0x....      BL       net_get_request_size
   \       0xA4   0x8BA2             LDRH     R2,[R4, #+28]
   \       0xA6   0x8AA1             LDRH     R1,[R4, #+20]
   \       0xA8   0x1810             ADDS     R0,R2,R0
   \       0xAA   0x4281             CMP      R1,R0
   \       0xAC   0xDAAE             BGE.N    ??_interchip_on_rx_2
   \       0xAE   0x69A0             LDR      R0,[R4, #+24]
   \       0xB0   0xF040 0x0020      ORR      R0,R0,#0x20
   \       0xB4   0x61A0             STR      R0,[R4, #+24]
   \       0xB6   0x2100             MOVS     R1,#+0
   \                     ??_interchip_on_rx_14: (+1)
   \       0xB8   0x83A1             STRH     R1,[R4, #+28]
   \       0xBA   0xE7D8             B.N      ??_interchip_on_rx_9
   \                     ??_interchip_on_rx_4: (+1)
   \       0xBC   0x7FA0             LDRB     R0,[R4, #+30]
   \       0xBE   0x4287             CMP      R7,R0
   \       0xC0   0xD003             BEQ.N    ??_interchip_on_rx_15
   \       0xC2   0x69A1             LDR      R1,[R4, #+24]
   \       0xC4   0xF041 0x0140      ORR      R1,R1,#0x40
   \       0xC8   0x61A1             STR      R1,[R4, #+24]
   \                     ??_interchip_on_rx_15: (+1)
   \       0xCA   0x2100             MOVS     R1,#+0
   \       0xCC   0x69A0             LDR      R0,[R4, #+24]
   \       0xCE   0xF040 0x0080      ORR      R0,R0,#0x80
   \       0xD2   0x61A0             STR      R0,[R4, #+24]
   \       0xD4   0xE7F0             B.N      ??_interchip_on_rx_14
   \                     ??_interchip_on_rx_10: (+1)
   \       0xD6   0x2000             MOVS     R0,#+0
   \       0xD8   0x83A0             STRH     R0,[R4, #+28]
   \       0xDA   0xE7CC             B.N      ??_interchip_on_rx_6
    123              }
    124          }
    125          

   \                                 In section .text, align 2, keep-with-next
    126          int net_bind(infra_channel_desc_t * channel)
    127          {
   \                     net_bind: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    128              if (!channel->rxbuffer || !channel->rxbuffersize
    129                  || !channel->register_rx_callback
    130                  || !channel->tx_buffer_set
    131                  || !channel->tx_flush) return 0;
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xBF1C             ITT      NE
   \        0x8   0x8A81             LDRHNE   R1,[R0, #+20]
   \        0xA   0x2900             CMPNE    R1,#+0
   \        0xC   0xD007             BEQ.N    ??net_bind_0
   \        0xE   0x6882             LDR      R2,[R0, #+8]
   \       0x10   0x2A00             CMP      R2,#+0
   \       0x12   0xBF1C             ITT      NE
   \       0x14   0x68C1             LDRNE    R1,[R0, #+12]
   \       0x16   0x2900             CMPNE    R1,#+0
   \       0x18   0xD001             BEQ.N    ??net_bind_0
   \       0x1A   0x6901             LDR      R1,[R0, #+16]
   \       0x1C   0xB909             CBNZ.N   R1,??net_bind_1
   \                     ??net_bind_0: (+1)
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0xBD02             POP      {R1,PC}
    132          
    133              channel->rx_state = 0;
   \                     ??net_bind_1: (+1)
   \       0x22   0x2100             MOVS     R1,#+0
   \       0x24   0x6181             STR      R1,[R0, #+24]
    134              channel->rx_pos = 0;
   \       0x26   0x8381             STRH     R1,[R0, #+28]
    135              channel->rx_checksum = 0;
   \       0x28   0x7781             STRB     R1,[R0, #+30]
    136          
    137              channel->register_rx_callback(channel, &_interchip_on_rx);
   \       0x2A   0x....             LDR.N    R1,??DataTable1
   \       0x2C   0x4790             BLX      R2
    138              return 1;
   \       0x2E   0x2001             MOVS     R0,#+1
   \       0x30   0xBD02             POP      {R1,PC}
    139          }
    140          

   \                                 In section .text, align 2, keep-with-next
    141          void net_prepare_pkt(infra_channel_desc_t * channel ,_u8 cmd, net_pkt_desc_t * pkt_desc)
    142          {
   \                     net_prepare_pkt: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    143              _u8 txheader[4];
    144          
    145          #ifdef INTERCHIP_TX_ENABLE_LONGFRAME
    146              txheader[0] = LONG_PKT_CMD_FLAG;
   \        0x2   0x2350             MOVS     R3,#+80
   \        0x4   0xF88D 0x3000      STRB     R3,[SP, #+0]
    147              pkt_desc->size = 1 + 2 + 1; // flag + 16bit len + command
   \        0x8   0x2404             MOVS     R4,#+4
   \        0xA   0x8014             STRH     R4,[R2, #+0]
    148          #else
    149              txheader[0] = LIT_PKT_CMD_FLAG;
    150              pkt_desc->size = 1 + 1 + 1; // flag + 8bit len + command
    151          #endif
    152              pkt_desc->checksum = txheader[0] ^ cmd;
   \        0xC   0xF081 0x0550      EOR      R5,R1,#0x50
   \       0x10   0x7095             STRB     R5,[R2, #+2]
    153              txheader[pkt_desc->size-1] = cmd;
    154              channel->tx_buffer_set(channel, &txheader, pkt_desc->size, 0);
   \       0x12   0x2300             MOVS     R3,#+0
   \       0x14   0x8814             LDRH     R4,[R2, #+0]
   \       0x16   0x446C             ADD      R4,SP,R4
   \       0x18   0xF804 0x1C01      STRB     R1,[R4, #+4294967295]
   \       0x1C   0x8812             LDRH     R2,[R2, #+0]
   \       0x1E   0x68C4             LDR      R4,[R0, #+12]
   \       0x20   0x4669             MOV      R1,SP
   \       0x22   0x47A0             BLX      R4
    155          }
   \       0x24   0xBD31             POP      {R0,R4,R5,PC}
    156          

   \                                 In section .text, align 2, keep-with-next
    157          int  net_pkt_pushdata(infra_channel_desc_t * channel, net_pkt_desc_t * pkt_desc, const void * data, _u16 size)
    158          {
   \                     net_pkt_pushdata: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x460C             MOV      R4,R1
   \        0x4   0x4615             MOV      R5,R2
   \        0x6   0x461E             MOV      R6,R3
    159              if (pkt_desc->size+size > channel->txbuffersize -1) {
   \        0x8   0x8AC2             LDRH     R2,[R0, #+22]
   \        0xA   0x8823             LDRH     R3,[R4, #+0]
   \        0xC   0x1E57             SUBS     R7,R2,#+1
   \        0xE   0x18F1             ADDS     R1,R6,R3
   \       0x10   0x428F             CMP      R7,R1
   \       0x12   0xBFBC             ITT      LT
   \       0x14   0x1E56             SUBLT    R6,R2,#+1
   \       0x16   0x1AF6             SUBLT    R6,R6,R3
    160                  size = channel->txbuffersize -1 - pkt_desc->size;
    161              }
    162          
    163              channel->tx_buffer_set(channel, data, size, pkt_desc->size);
   \       0x18   0x68C7             LDR      R7,[R0, #+12]
   \       0x1A   0xB2B2             UXTH     R2,R6
   \       0x1C   0x4629             MOV      R1,R5
   \       0x1E   0x47B8             BLX      R7
    164              pkt_desc->size += size;
   \       0x20   0x8820             LDRH     R0,[R4, #+0]
   \       0x22   0x1830             ADDS     R0,R6,R0
   \       0x24   0x8020             STRH     R0,[R4, #+0]
    165          
    166              for (_u16 pos = 0; pos < size; ++pos) {
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0xE005             B.N      ??net_pkt_pushdata_0
    167                  pkt_desc->checksum ^= ((_u8 *)data)[pos];
   \                     ??net_pkt_pushdata_1: (+1)
   \       0x2A   0xB282             UXTH     R2,R0
   \       0x2C   0x78A1             LDRB     R1,[R4, #+2]
   \       0x2E   0x5CAB             LDRB     R3,[R5, R2]
   \       0x30   0x4059             EORS     R1,R3,R1
   \       0x32   0x70A1             STRB     R1,[R4, #+2]
    168              }
   \       0x34   0x1C40             ADDS     R0,R0,#+1
   \                     ??net_pkt_pushdata_0: (+1)
   \       0x36   0xB281             UXTH     R1,R0
   \       0x38   0xB2B2             UXTH     R2,R6
   \       0x3A   0x4291             CMP      R1,R2
   \       0x3C   0xD3F5             BCC.N    ??net_pkt_pushdata_1
    169              return size;
   \       0x3E   0xB2B0             UXTH     R0,R6
   \       0x40   0xBDF2             POP      {R1,R4-R7,PC}
    170          }
    171          

   \                                 In section .text, align 2, keep-with-next
    172          int  net_flush_pkt(infra_channel_desc_t * channel, net_pkt_desc_t * pkt_desc)
    173          {
   \                     net_flush_pkt: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x460D             MOV      R5,R1
   \        0x4   0x4604             MOV      R4,R0
    174              _u16 length_field;
    175          #ifdef INTERCHIP_TX_ENABLE_LONGFRAME
    176              length_field = pkt_desc->size - 3;
   \        0x6   0x8828             LDRH     R0,[R5, #+0]
   \        0x8   0x1EC1             SUBS     R1,R0,#+3
   \        0xA   0xF8AD 0x1000      STRH     R1,[SP, #+0]
    177              channel->tx_buffer_set(channel, &length_field, 2, 1);
   \        0xE   0x2301             MOVS     R3,#+1
   \       0x10   0x68E6             LDR      R6,[R4, #+12]
   \       0x12   0x2202             MOVS     R2,#+2
   \       0x14   0x4669             MOV      R1,SP
   \       0x16   0x4620             MOV      R0,R4
   \       0x18   0x47B0             BLX      R6
    178          
    179              pkt_desc->checksum ^= ((_u8)(length_field & 0xFF)) ^ ((_u8)(length_field >> 8));
   \       0x1A   0x78A9             LDRB     R1,[R5, #+2]
   \       0x1C   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \       0x20   0x4041             EORS     R1,R0,R1
   \       0x22   0xEA81 0x2110      EOR      R1,R1,R0, LSR #+8
   \       0x26   0x70A9             STRB     R1,[R5, #+2]
    180          #else
    181              length_field = pkt_desc->size - 2;
    182              channel->tx_buffer_set(channel, &length_field, 1, 1);
    183              pkt_desc->checksum ^= (_u8)(length_field);
    184          #endif
    185          
    186              channel->tx_buffer_set(channel, &pkt_desc->checksum, 1, pkt_desc->size);
   \       0x28   0x882B             LDRH     R3,[R5, #+0]
   \       0x2A   0x68E6             LDR      R6,[R4, #+12]
   \       0x2C   0x2201             MOVS     R2,#+1
   \       0x2E   0x1CA9             ADDS     R1,R5,#+2
   \       0x30   0x4620             MOV      R0,R4
   \       0x32   0x47B0             BLX      R6
    187              channel->tx_flush(channel, pkt_desc->size+1);
   \       0x34   0x8829             LDRH     R1,[R5, #+0]
   \       0x36   0x6922             LDR      R2,[R4, #+16]
   \       0x38   0x1C49             ADDS     R1,R1,#+1
   \       0x3A   0x4620             MOV      R0,R4
   \       0x3C   0x4790             BLX      R2
    188          
    189              return pkt_desc->size+1;
   \       0x3E   0x8828             LDRH     R0,[R5, #+0]
   \       0x40   0x1C40             ADDS     R0,R0,#+1
   \       0x42   0xBD76             POP      {R1,R2,R4-R6,PC}
    190          }
    191          

   \                                 In section .text, align 2, keep-with-next
    192          int net_send_pkt(infra_channel_desc_t * channel, _u8 cmd, const void * data, _u16 size)
    193          {
   \                     net_send_pkt: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x4615             MOV      R5,R2
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x461E             MOV      R6,R3
    194              net_pkt_desc_t pkt;
    195              net_prepare_pkt(channel, cmd, &pkt);
   \        0x8   0x466A             MOV      R2,SP
   \        0xA   0x.... 0x....      BL       net_prepare_pkt
    196              net_pkt_pushdata(channel, &pkt, data, size);
   \        0xE   0x4633             MOV      R3,R6
   \       0x10   0x462A             MOV      R2,R5
   \       0x12   0x4669             MOV      R1,SP
   \       0x14   0x4620             MOV      R0,R4
   \       0x16   0x.... 0x....      BL       net_pkt_pushdata
    197              return net_flush_pkt(channel, &pkt);
   \       0x1A   0x4669             MOV      R1,SP
   \       0x1C   0x4620             MOV      R0,R4
   \       0x1E   0x.... 0x....      BL       net_flush_pkt
   \       0x22   0xBD76             POP      {R1,R2,R4-R6,PC}
    198          }
    199          

   \                                 In section .text, align 2, keep-with-next
    200          int net_send_errorcode(infra_channel_desc_t * channel, _u16 code)
    201          {
   \                     net_send_errorcode: (+1)
   \        0x0   0xB502             PUSH     {R1,LR}
    202              channel->rx_state = PKT_STATE_NULL;
   \        0x2   0x2100             MOVS     R1,#+0
   \        0x4   0x6181             STR      R1,[R0, #+24]
    203              return net_send_pkt(channel, STATUS_CODE_ANS_RXERR, (unsigned char *)&code, sizeof(code));
   \        0x6   0x2302             MOVS     R3,#+2
   \        0x8   0x466A             MOV      R2,SP
   \        0xA   0x2103             MOVS     R1,#+3
   \        0xC   0x.... 0x....      BL       net_send_pkt
   \       0x10   0xBD02             POP      {R1,PC}
    204          }
    205          

   \                                 In section .text, align 2, keep-with-next
    206          int net_send_ans(infra_channel_desc_t * channel, const void * data, _u16 size)
    207          {
   \                     net_send_ans: (+1)
   \        0x0   0x4613             MOV      R3,R2
    208              channel->rx_state = PKT_STATE_NULL;
   \        0x2   0x2200             MOVS     R2,#+0
   \        0x4   0x6182             STR      R2,[R0, #+24]
    209              return net_send_pkt(channel, STATUS_CODE_ANS, (unsigned char *)data, size);
   \        0x6   0x460A             MOV      R2,R1
   \        0x8   0x2102             MOVS     R1,#+2
   \        0xA   0x....             B.N      net_send_pkt
    210          }
    211          

   \                                 In section .text, align 2, keep-with-next
    212          void net_prepare_ans(infra_channel_desc_t * channel, net_pkt_desc_t * pkt_desc)
    213          {
   \                     net_prepare_ans: (+1)
   \        0x0   0x460A             MOV      R2,R1
    214              channel->rx_state = PKT_STATE_NULL;
   \        0x2   0x2100             MOVS     R1,#+0
   \        0x4   0x6181             STR      R1,[R0, #+24]
    215              net_prepare_pkt(channel, STATUS_CODE_ANS, pkt_desc);
   \        0x6   0x2102             MOVS     R1,#+2
   \        0x8   0x....             B.N      net_prepare_pkt
    216          }
    217          

   \                                 In section .text, align 2, keep-with-next
    218          bool net_poll_request(infra_channel_desc_t* channel)
    219          {
   \                     net_poll_request: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
    220              clear_alert();
   \        0x4   0x.... 0x....      BL       clear_alert
    221              if (channel->rx_state & (PKT_STATE_NOT_SYNC_PKT | PKT_STATE_CHECKSUM_FAIL | PKT_STATE_SIZE_OVERFLOW) )
   \        0x8   0x69A0             LDR      R0,[R4, #+24]
   \        0xA   0xF010 0x0F70      TST      R0,#0x70
   \        0xE   0xD006             BEQ.N    ??net_poll_request_0
    222              {
    223                  net_send_errorcode(channel , channel->rx_state & 0xFFFF);
   \       0x10   0x69A1             LDR      R1,[R4, #+24]
   \       0x12   0xB289             UXTH     R1,R1
   \       0x14   0x4620             MOV      R0,R4
   \       0x16   0x.... 0x....      BL       net_send_errorcode
    224              }
    225              else
    226              {
    227                  if (channel->rx_state & PKT_STATE_READY)
    228                  {
    229                      _u8 cmd = net_get_request_cmd(channel);
    230                      if (cmd == STATUS_CODE_SYNC
    231                          || cmd == STATUS_CODE_ECHO)
    232                      {
    233                          _u8 old_checksum = channel->rx_checksum;
    234          
    235                          channel->rx_state = PKT_STATE_NULL;
    236          
    237                          _u32 pkt_size = net_get_request_size(channel) + ((channel->rxbuffer[0] == LONG_PKT_CMD_FLAG )?3:2);
    238          
    239                          channel->tx_buffer_set(channel, (_u8 *)channel->rxbuffer, pkt_size, 0);
    240                          channel->tx_buffer_set(channel, &old_checksum, 1, pkt_size);
    241                          channel->tx_flush(channel, pkt_size+1 );
    242          
    243                      }else
    244                      {
    245                          return true;
    246                      }
    247                  }
    248              }
    249              return false;
   \                     ??net_poll_request_1: (+1)
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0xBD76             POP      {R1,R2,R4-R6,PC}
   \                     ??net_poll_request_0: (+1)
   \       0x1E   0x69A0             LDR      R0,[R4, #+24]
   \       0x20   0x0601             LSLS     R1,R0,#+24
   \       0x22   0xD5FA             BPL.N    ??net_poll_request_1
   \       0x24   0x4620             MOV      R0,R4
   \       0x26   0x.... 0x....      BL       net_get_request_cmd
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xBF18             IT       NE
   \       0x2E   0x2801             CMPNE    R0,#+1
   \       0x30   0xD11F             BNE.N    ??net_poll_request_2
   \       0x32   0x7FA0             LDRB     R0,[R4, #+30]
   \       0x34   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \       0x38   0x2100             MOVS     R1,#+0
   \       0x3A   0x61A1             STR      R1,[R4, #+24]
   \       0x3C   0x4620             MOV      R0,R4
   \       0x3E   0x.... 0x....      BL       net_get_request_size
   \       0x42   0x6821             LDR      R1,[R4, #+0]
   \       0x44   0x68E6             LDR      R6,[R4, #+12]
   \       0x46   0x4605             MOV      R5,R0
   \       0x48   0x7808             LDRB     R0,[R1, #+0]
   \       0x4A   0x2850             CMP      R0,#+80
   \       0x4C   0xBF0C             ITE      EQ
   \       0x4E   0x2003             MOVEQ    R0,#+3
   \       0x50   0x2002             MOVNE    R0,#+2
   \       0x52   0x1945             ADDS     R5,R0,R5
   \       0x54   0x2300             MOVS     R3,#+0
   \       0x56   0x462A             MOV      R2,R5
   \       0x58   0x4620             MOV      R0,R4
   \       0x5A   0x47B0             BLX      R6
   \       0x5C   0x68E6             LDR      R6,[R4, #+12]
   \       0x5E   0x462B             MOV      R3,R5
   \       0x60   0x2201             MOVS     R2,#+1
   \       0x62   0x4669             MOV      R1,SP
   \       0x64   0x4620             MOV      R0,R4
   \       0x66   0x47B0             BLX      R6
   \       0x68   0x6922             LDR      R2,[R4, #+16]
   \       0x6A   0x1C69             ADDS     R1,R5,#+1
   \       0x6C   0x4620             MOV      R0,R4
   \       0x6E   0x4790             BLX      R2
   \       0x70   0xE7D3             B.N      ??net_poll_request_1
   \                     ??net_poll_request_2: (+1)
   \       0x72   0x2001             MOVS     R0,#+1
   \       0x74   0xBD76             POP      {R1,R2,R4-R6,PC}
    250          }
    251          
    252          
    253          #ifdef INTERCHIP_RX_ENABLE_LONGFRAME
    254          

   \                                 In section .text, align 2, keep-with-next
    255          _u8   net_get_request_cmd(infra_channel_desc_t * channel)
    256          {
    257              if (channel->rxbuffer[0] == LONG_PKT_CMD_FLAG ) {
   \                     net_get_request_cmd: (+1)
   \        0x0   0x6800             LDR      R0,[R0, #+0]
   \        0x2   0x7801             LDRB     R1,[R0, #+0]
   \        0x4   0x2950             CMP      R1,#+80
   \        0x6   0xD101             BNE.N    ??net_get_request_cmd_0
    258                  return  ((long_pkt_header_t *)channel->rxbuffer)->_cmd;
   \        0x8   0x78C0             LDRB     R0,[R0, #+3]
   \        0xA   0x4770             BX       LR
    259              } else {
    260                  return  ((lit_pkt_header_t *)channel->rxbuffer)->_cmd;
   \                     ??net_get_request_cmd_0: (+1)
   \        0xC   0x7880             LDRB     R0,[R0, #+2]
   \        0xE   0x4770             BX       LR
    261              }
    262          }
    263          

   \                                 In section .text, align 2, keep-with-next
    264          _u16  net_get_request_size(infra_channel_desc_t * channel)
    265          {
    266              if (channel->rxbuffer[0] == LONG_PKT_CMD_FLAG ) {
   \                     net_get_request_size: (+1)
   \        0x0   0x6800             LDR      R0,[R0, #+0]
   \        0x2   0x7801             LDRB     R1,[R0, #+0]
   \        0x4   0x2950             CMP      R1,#+80
   \        0x6   0xD102             BNE.N    ??net_get_request_size_0
    267                  return  ((long_pkt_header_t *)channel->rxbuffer)->_len16;
   \        0x8   0xF8B0 0x0001      LDRH     R0,[R0, #+1]
   \        0xC   0x4770             BX       LR
    268              } else {
    269                  return  ((lit_pkt_header_t *)channel->rxbuffer)->_len;
   \                     ??net_get_request_size_0: (+1)
   \        0xE   0x7840             LDRB     R0,[R0, #+1]
   \       0x10   0x4770             BX       LR
    270              }
    271          }
    272          

   \                                 In section .text, align 2, keep-with-next
    273          _u8 * net_get_request_data(infra_channel_desc_t * channel)
    274          {
    275              if (channel->rxbuffer[0] == LONG_PKT_CMD_FLAG ) {
   \                     net_get_request_data: (+1)
   \        0x0   0x6800             LDR      R0,[R0, #+0]
   \        0x2   0x7801             LDRB     R1,[R0, #+0]
   \        0x4   0x2950             CMP      R1,#+80
   \        0x6   0xD101             BNE.N    ??net_get_request_data_0
    276                  return  (_u8 *)channel->rxbuffer + sizeof(long_pkt_header_t);
   \        0x8   0x1D00             ADDS     R0,R0,#+4
   \        0xA   0x4770             BX       LR
    277              } else {
    278                  return  (_u8 *)channel->rxbuffer + sizeof(lit_pkt_header_t);
   \                     ??net_get_request_data_0: (+1)
   \        0xC   0x1CC0             ADDS     R0,R0,#+3
   \        0xE   0x4770             BX       LR
    279              }
    280          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \        0x0   0x....'....        DC32     _interchip_on_rx
    281          
    282          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   _interchip_on_rx
         0   -> alert
        24   -> net_get_request_size
       8   net_bind
         8   -- Indirect call
      24   net_flush_pkt
        24   -- Indirect call
       0   net_get_request_cmd
       0   net_get_request_data
       0   net_get_request_size
      24   net_pkt_pushdata
        24   -- Indirect call
      24   net_poll_request
        24   -- Indirect call
        24   -> clear_alert
        24   -> net_get_request_cmd
        24   -> net_get_request_size
        24   -> net_send_errorcode
       0   net_prepare_ans
         0   -> net_prepare_pkt
      16   net_prepare_pkt
        16   -- Indirect call
       0   net_send_ans
         0   -> net_send_pkt
       8   net_send_errorcode
         8   -> net_send_pkt
      24   net_send_pkt
        24   -> net_flush_pkt
        24   -> net_pkt_pushdata
        24   -> net_prepare_pkt


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
     220  _interchip_on_rx
      50  net_bind
      68  net_flush_pkt
      16  net_get_request_cmd
      16  net_get_request_data
      18  net_get_request_size
      66  net_pkt_pushdata
     118  net_poll_request
      10  net_prepare_ans
      38  net_prepare_pkt
      12  net_send_ans
      18  net_send_errorcode
      36  net_send_pkt

 
 690 bytes in section .text
 
 690 bytes of CODE memory

Errors: none
Warnings: none
