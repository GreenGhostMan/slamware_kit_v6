###############################################################################
#
# IAR ANSI C/C++ Compiler V9.10.2.313/W64 for ARM         28/Jul/2021  15:57:31
# Copyright 1999-2021 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\infra_pub\arch\st_fwlib\CMSIS\CM3\DeviceSupport\ST\STM32F10x\system_stm32f10x.c
#    Command line      =
#        -f
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\Release_Rev6\List\Runtime\CMSIS\stm32f10x\system_stm32f10x.lst.rsp
#        (C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\infra_pub\arch\st_fwlib\CMSIS\CM3\DeviceSupport\ST\STM32F10x\system_stm32f10x.c
#        -D USE_STDPERIPH_DRIVER -D STM32F10X_HD -D USART_ENABLE_USART3 -D
#        CONFIG_BREAKOUT_REV=6 -D USE_FRONT_IR_SENSORS -D FEATURE_SET_V -lCN
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\Release_Rev6\List\Runtime\CMSIS\stm32f10x
#        --diag_suppress Pa050 -o
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\Release_Rev6\Obj\Runtime\CMSIS\stm32f10x
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        9.0\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\src\
#        -I
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\..\..\common\inc\
#        -I
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\..\infra_pub\
#        -I
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\..\infra_pub\arch\st_fwlib\CMSIS\CM3\CoreSupport\
#        -I
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\..\infra_pub\arch\st_fwlib\CMSIS\CM3\DeviceSupport\ST\STM32F10x\
#        -I
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\..\infra_pub\arch\st_fwlib\STM32F10x_StdPeriph_Driver\inc\
#        -I
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\..\infra_pub\arch\infra_stm32\
#        -I
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\..\infra_pub\arch\infra_stm32\32f10x\
#        -Ohz --use_c++_inline) --dependencies=n
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\Release_Rev6\Obj\Runtime\CMSIS\stm32f10x\system_stm32f10x.o.d
#    Locale            =  C
#    List file         =
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\Release_Rev6\List\Runtime\CMSIS\stm32f10x\system_stm32f10x.lst
#    Object file       =
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\Release_Rev6\Obj\Runtime\CMSIS\stm32f10x\system_stm32f10x.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\infra_pub\arch\st_fwlib\CMSIS\CM3\DeviceSupport\ST\STM32F10x\system_stm32f10x.c
      1          /**
      2            ******************************************************************************
      3            * @file    system_stm32f10x.c
      4            * @author  MCD Application Team
      5            * @version V3.5.0
      6            * @date    11-March-2011
      7            * @brief   CMSIS Cortex-M3 Device Peripheral Access Layer System Source File.
      8            * 
      9            * 1.  This file provides two functions and one global variable to be called from 
     10            *     user application:
     11            *      - SystemInit(): Setups the system clock (System clock source, PLL Multiplier
     12            *                      factors, AHB/APBx prescalers and Flash settings). 
     13            *                      This function is called at startup just after reset and 
     14            *                      before branch to main program. This call is made inside
     15            *                      the "startup_stm32f10x_xx.s" file.
     16            *
     17            *      - SystemCoreClock variable: Contains the core clock (HCLK), it can be used
     18            *                                  by the user application to setup the SysTick 
     19            *                                  timer or configure other parameters.
     20            *                                     
     21            *      - SystemCoreClockUpdate(): Updates the variable SystemCoreClock and must
     22            *                                 be called whenever the core clock is changed
     23            *                                 during program execution.
     24            *
     25            * 2. After each device reset the HSI (8 MHz) is used as system clock source.
     26            *    Then SystemInit() function is called, in "startup_stm32f10x_xx.s" file, to
     27            *    configure the system clock before to branch to main program.
     28            *
     29            * 3. If the system clock source selected by user fails to startup, the SystemInit()
     30            *    function will do nothing and HSI still used as system clock source. User can 
     31            *    add some code to deal with this issue inside the SetSysClock() function.
     32            *
     33            * 4. The default value of HSE crystal is set to 8 MHz (or 25 MHz, depedning on
     34            *    the product used), refer to "HSE_VALUE" define in "stm32f10x.h" file. 
     35            *    When HSE is used as system clock source, directly or through PLL, and you
     36            *    are using different crystal you have to adapt the HSE value to your own
     37            *    configuration.
     38            *        
     39            ******************************************************************************
     40            * @attention
     41            *
     42            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     43            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     44            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     45            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     46            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     47            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     48            *
     49            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     50            ******************************************************************************
     51            */
     52          
     53          /** @addtogroup CMSIS
     54            * @{
     55            */
     56          
     57          /** @addtogroup stm32f10x_system
     58            * @{
     59            */  
     60            
     61          /** @addtogroup STM32F10x_System_Private_Includes
     62            * @{
     63            */
     64          
     65          #include "stm32f10x.h"
     66          
     67          /**
     68            * @}
     69            */
     70          
     71          /** @addtogroup STM32F10x_System_Private_TypesDefinitions
     72            * @{
     73            */
     74          
     75          /**
     76            * @}
     77            */
     78          
     79          /** @addtogroup STM32F10x_System_Private_Defines
     80            * @{
     81            */
     82          
     83          /*!< Uncomment the line corresponding to the desired System clock (SYSCLK)
     84             frequency (after reset the HSI is used as SYSCLK source)
     85             
     86             IMPORTANT NOTE:
     87             ============== 
     88             1. After each device reset the HSI is used as System clock source.
     89          
     90             2. Please make sure that the selected System clock doesn't exceed your device's
     91                maximum frequency.
     92                
     93             3. If none of the define below is enabled, the HSI is used as System clock
     94              source.
     95          
     96             4. The System clock configuration functions provided within this file assume that:
     97                  - For Low, Medium and High density Value line devices an external 8MHz 
     98                    crystal is used to drive the System clock.
     99                  - For Low, Medium and High density devices an external 8MHz crystal is
    100                    used to drive the System clock.
    101                  - For Connectivity line devices an external 25MHz crystal is used to drive
    102                    the System clock.
    103               If you are using different crystal you have to adapt those functions accordingly.
    104              */
    105              
    106          #if defined (STM32F10X_LD_VL) || (defined STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)
    107          /* #define SYSCLK_FREQ_HSE    HSE_VALUE */
    108           #define SYSCLK_FREQ_24MHz  24000000
    109          #else
    110          /* #define SYSCLK_FREQ_HSE    HSE_VALUE */
    111          /* #define SYSCLK_FREQ_24MHz  24000000 */ 
    112          /* #define SYSCLK_FREQ_36MHz  36000000 */
    113          /* #define SYSCLK_FREQ_48MHz  48000000 */
    114          /* #define SYSCLK_FREQ_56MHz  56000000 */
    115          #define SYSCLK_FREQ_72MHz  72000000
    116          #endif
    117          
    118          /*!< Uncomment the following line if you need to use external SRAM mounted
    119               on STM3210E-EVAL board (STM32 High density and XL-density devices) or on 
    120               STM32100E-EVAL board (STM32 High-density value line devices) as data memory */ 
    121          #if defined (STM32F10X_HD) || (defined STM32F10X_XL) || (defined STM32F10X_HD_VL)
    122          /* #define DATA_IN_ExtSRAM */
    123          #endif
    124          
    125          /*!< Uncomment the following line if you need to relocate your vector Table in
    126               Internal SRAM. */ 
    127          /* #define VECT_TAB_SRAM */
    128          
    129          
    130          #ifndef VECT_TAB_OFFSET
    131          #define VECT_TAB_OFFSET  0x0 /*!< Vector Table base offset field. 
    132                                            This value must be a multiple of 0x200. */
    133          #endif
    134          
    135          /**
    136            * @}
    137            */
    138          
    139          /** @addtogroup STM32F10x_System_Private_Macros
    140            * @{
    141            */
    142          
    143          /**
    144            * @}
    145            */
    146          
    147          /** @addtogroup STM32F10x_System_Private_Variables
    148            * @{
    149            */
    150          
    151          /*******************************************************************************
    152          *  Clock Definitions
    153          *******************************************************************************/
    154          #ifdef SYSCLK_FREQ_HSE
    155            uint32_t SystemCoreClock         = SYSCLK_FREQ_HSE;        /*!< System Clock Frequency (Core Clock) */
    156          #elif defined SYSCLK_FREQ_24MHz
    157            uint32_t SystemCoreClock         = SYSCLK_FREQ_24MHz;        /*!< System Clock Frequency (Core Clock) */
    158          #elif defined SYSCLK_FREQ_36MHz
    159            uint32_t SystemCoreClock         = SYSCLK_FREQ_36MHz;        /*!< System Clock Frequency (Core Clock) */
    160          #elif defined SYSCLK_FREQ_48MHz
    161            uint32_t SystemCoreClock         = SYSCLK_FREQ_48MHz;        /*!< System Clock Frequency (Core Clock) */
    162          #elif defined SYSCLK_FREQ_56MHz
    163            uint32_t SystemCoreClock         = SYSCLK_FREQ_56MHz;        /*!< System Clock Frequency (Core Clock) */
    164          #elif defined SYSCLK_FREQ_72MHz

   \                                 In section .data, align 4
    165            uint32_t SystemCoreClock         = SYSCLK_FREQ_72MHz;        /*!< System Clock Frequency (Core Clock) */
    166          #else /*!< HSI Selected as System Clock source */
    167            uint32_t SystemCoreClock         = HSI_VALUE;        /*!< System Clock Frequency (Core Clock) */
    168          #endif
    169          
    170          __I uint8_t AHBPrescTable[16] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 6, 7, 8, 9};
   \                     AHBPrescTable:
   \        0x0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 6, 7, 8, 9

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x01 0x02    

   \              0x03 0x04    

   \              0x06 0x07    

   \              0x08 0x09
   \                     SystemCoreClock:
   \       0x10   0x044A'A200        DC32 72'000'000
    171          /**
    172            * @}
    173            */
    174          
    175          /** @addtogroup STM32F10x_System_Private_FunctionPrototypes
    176            * @{
    177            */
    178          
    179          static void SetSysClock(void);
    180          
    181          #ifdef SYSCLK_FREQ_HSE
    182            static void SetSysClockToHSE(void);
    183          #elif defined SYSCLK_FREQ_24MHz
    184            static void SetSysClockTo24(void);
    185          #elif defined SYSCLK_FREQ_36MHz
    186            static void SetSysClockTo36(void);
    187          #elif defined SYSCLK_FREQ_48MHz
    188            static void SetSysClockTo48(void);
    189          #elif defined SYSCLK_FREQ_56MHz
    190            static void SetSysClockTo56(void);  
    191          #elif defined SYSCLK_FREQ_72MHz
    192            static void SetSysClockTo72(void);
    193          #endif
    194          
    195          #ifdef DATA_IN_ExtSRAM
    196            static void SystemInit_ExtMemCtl(void); 
    197          #endif /* DATA_IN_ExtSRAM */
    198          
    199          /**
    200            * @}
    201            */
    202          
    203          /** @addtogroup STM32F10x_System_Private_Functions
    204            * @{
    205            */
    206          
    207          /**
    208            * @brief  Setup the microcontroller system
    209            *         Initialize the Embedded Flash Interface, the PLL and update the 
    210            *         SystemCoreClock variable.
    211            * @note   This function should be used only after reset.
    212            * @param  None
    213            * @retval None
    214            */

   \                                 In section .text, align 2, keep-with-next
    215          void SystemInit (void)
    216          {
   \                     SystemInit: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
    217            /* Reset the RCC clock configuration to the default reset state(for debug purpose) */
    218            /* Set HSION bit */
    219            RCC->CR |= (uint32_t)0x00000001;
   \        0x2   0x....             LDR.N    R2,??DataTable1
    220          
    221            /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
    222          #ifndef STM32F10X_CL
    223            RCC->CFGR &= (uint32_t)0xF8FF0000;
   \        0x4   0x....             LDR.N    R1,??DataTable1_1
   \        0x6   0x6810             LDR      R0,[R2, #+0]
   \        0x8   0xF040 0x0001      ORR      R0,R0,#0x1
   \        0xC   0x6010             STR      R0,[R2, #+0]
   \        0xE   0x6853             LDR      R3,[R2, #+4]
    224          #else
    225            RCC->CFGR &= (uint32_t)0xF0FF0000;
    226          #endif /* STM32F10X_CL */   
    227            
    228            /* Reset HSEON, CSSON and PLLON bits */
    229            RCC->CR &= (uint32_t)0xFEF6FFFF;
   \       0x10   0x....             LDR.N    R0,??DataTable1_2
   \       0x12   0x400B             ANDS     R3,R1,R3
   \       0x14   0x6053             STR      R3,[R2, #+4]
    230          
    231            /* Reset HSEBYP bit */
    232            RCC->CR &= (uint32_t)0xFFFBFFFF;
    233          
    234            /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
    235            RCC->CFGR &= (uint32_t)0xFF80FFFF;
    236          
    237          #ifdef STM32F10X_CL
    238            /* Reset PLL2ON and PLL3ON bits */
    239            RCC->CR &= (uint32_t)0xEBFFFFFF;
    240          
    241            /* Disable all interrupts and clear pending bits  */
    242            RCC->CIR = 0x00FF0000;
    243          
    244            /* Reset CFGR2 register */
    245            RCC->CFGR2 = 0x00000000;
    246          #elif defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)
    247            /* Disable all interrupts and clear pending bits  */
    248            RCC->CIR = 0x009F0000;
    249          
    250            /* Reset CFGR2 register */
    251            RCC->CFGR2 = 0x00000000;      
    252          #else
    253            /* Disable all interrupts and clear pending bits  */
    254            RCC->CIR = 0x009F0000;
    255          #endif /* STM32F10X_CL */
    256              
    257          #if defined (STM32F10X_HD) || (defined STM32F10X_XL) || (defined STM32F10X_HD_VL)
    258            #ifdef DATA_IN_ExtSRAM
    259              SystemInit_ExtMemCtl(); 
    260            #endif /* DATA_IN_ExtSRAM */
    261          #endif 
    262          
    263            /* Configure the System clock frequency, HCLK, PCLK2 and PCLK1 prescalers */
    264            /* Configure the Flash Latency cycles and enable prefetch buffer */
    265            SetSysClock();
   \       0x16   0x2300             MOVS     R3,#+0
   \       0x18   0x6814             LDR      R4,[R2, #+0]
   \       0x1A   0x4004             ANDS     R4,R0,R4
   \       0x1C   0x6014             STR      R4,[R2, #+0]
   \       0x1E   0x6811             LDR      R1,[R2, #+0]
   \       0x20   0xF421 0x2180      BIC      R1,R1,#0x40000
   \       0x24   0x6011             STR      R1,[R2, #+0]
   \       0x26   0xF44F 0x011F      MOV      R1,#+10420224
   \       0x2A   0x6850             LDR      R0,[R2, #+4]
   \       0x2C   0xF420 0x00FE      BIC      R0,R0,#0x7F0000
   \       0x30   0x6050             STR      R0,[R2, #+4]
   \       0x32   0x6091             STR      R1,[R2, #+8]
   \       0x34   0x9300             STR      R3,[SP, #+0]
   \       0x36   0x9301             STR      R3,[SP, #+4]
   \       0x38   0x6813             LDR      R3,[R2, #+0]
   \       0x3A   0xF443 0x3380      ORR      R3,R3,#0x10000
   \       0x3E   0x6013             STR      R3,[R2, #+0]
   \                     ??SystemInit_0: (+1)
   \       0x40   0x6810             LDR      R0,[R2, #+0]
   \       0x42   0xF400 0x3000      AND      R0,R0,#0x20000
   \       0x46   0x9001             STR      R0,[SP, #+4]
   \       0x48   0x9800             LDR      R0,[SP, #+0]
   \       0x4A   0x1C40             ADDS     R0,R0,#+1
   \       0x4C   0x9000             STR      R0,[SP, #+0]
   \       0x4E   0x9801             LDR      R0,[SP, #+4]
   \       0x50   0xB918             CBNZ.N   R0,??SystemInit_1
   \       0x52   0x9800             LDR      R0,[SP, #+0]
   \       0x54   0xF5B0 0x6FA0      CMP      R0,#+1280
   \       0x58   0xD1F2             BNE.N    ??SystemInit_0
   \                     ??SystemInit_1: (+1)
   \       0x5A   0x6810             LDR      R0,[R2, #+0]
   \       0x5C   0x0C40             LSRS     R0,R0,#+17
   \       0x5E   0xF000 0x0001      AND      R0,R0,#0x1
   \       0x62   0x9001             STR      R0,[SP, #+4]
   \       0x64   0x9801             LDR      R0,[SP, #+4]
   \       0x66   0x2801             CMP      R0,#+1
   \       0x68   0xD130             BNE.N    ??SystemInit_2
   \       0x6A   0x....             LDR.N    R0,??DataTable1_3
   \       0x6C   0x6801             LDR      R1,[R0, #+0]
   \       0x6E   0xF041 0x0110      ORR      R1,R1,#0x10
   \       0x72   0x6001             STR      R1,[R0, #+0]
   \       0x74   0x6803             LDR      R3,[R0, #+0]
   \       0x76   0x089B             LSRS     R3,R3,#+2
   \       0x78   0x009B             LSLS     R3,R3,#+2
   \       0x7A   0x6003             STR      R3,[R0, #+0]
   \       0x7C   0x6801             LDR      R1,[R0, #+0]
   \       0x7E   0xF041 0x0102      ORR      R1,R1,#0x2
   \       0x82   0x6001             STR      R1,[R0, #+0]
   \       0x84   0x6850             LDR      R0,[R2, #+4]
   \       0x86   0x6050             STR      R0,[R2, #+4]
   \       0x88   0x6851             LDR      R1,[R2, #+4]
   \       0x8A   0x6051             STR      R1,[R2, #+4]
   \       0x8C   0x6850             LDR      R0,[R2, #+4]
   \       0x8E   0xF440 0x6080      ORR      R0,R0,#0x400
   \       0x92   0x6050             STR      R0,[R2, #+4]
   \       0x94   0x6850             LDR      R0,[R2, #+4]
   \       0x96   0xF420 0x107C      BIC      R0,R0,#0x3F0000
   \       0x9A   0x6050             STR      R0,[R2, #+4]
   \       0x9C   0x6850             LDR      R0,[R2, #+4]
   \       0x9E   0xF440 0x10E8      ORR      R0,R0,#0x1D0000
   \       0xA2   0x6050             STR      R0,[R2, #+4]
   \       0xA4   0x6811             LDR      R1,[R2, #+0]
   \       0xA6   0xF041 0x7180      ORR      R1,R1,#0x1000000
   \       0xAA   0x6011             STR      R1,[R2, #+0]
   \                     ??SystemInit_3: (+1)
   \       0xAC   0x6810             LDR      R0,[R2, #+0]
   \       0xAE   0x0181             LSLS     R1,R0,#+6
   \       0xB0   0xD5FC             BPL.N    ??SystemInit_3
   \       0xB2   0x6850             LDR      R0,[R2, #+4]
   \       0xB4   0x0880             LSRS     R0,R0,#+2
   \       0xB6   0x0080             LSLS     R0,R0,#+2
   \       0xB8   0x6050             STR      R0,[R2, #+4]
   \       0xBA   0x6850             LDR      R0,[R2, #+4]
   \       0xBC   0xF040 0x0002      ORR      R0,R0,#0x2
   \       0xC0   0x6050             STR      R0,[R2, #+4]
   \                     ??SystemInit_4: (+1)
   \       0xC2   0x6850             LDR      R0,[R2, #+4]
   \       0xC4   0xF000 0x000C      AND      R0,R0,#0xC
   \       0xC8   0x2808             CMP      R0,#+8
   \       0xCA   0xD1FA             BNE.N    ??SystemInit_4
    266          
    267          #ifdef VECT_TAB_SRAM
    268            SCB->VTOR = SRAM_BASE + VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */
    269          #else
    270            SCB->VTOR = FLASH_BASE + VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH. */
   \                     ??SystemInit_2: (+1)
   \       0xCC   0xF04F 0x6000      MOV      R0,#+134217728
   \       0xD0   0x....             LDR.N    R1,??DataTable1_4
   \       0xD2   0x6008             STR      R0,[R1, #+0]
    271          #endif 
    272          }
   \       0xD4   0xBD13             POP      {R0,R1,R4,PC}
    273          
    274          /**
    275            * @brief  Update SystemCoreClock variable according to Clock Register Values.
    276            *         The SystemCoreClock variable contains the core clock (HCLK), it can
    277            *         be used by the user application to setup the SysTick timer or configure
    278            *         other parameters.
    279            *           
    280            * @note   Each time the core clock (HCLK) changes, this function must be called
    281            *         to update SystemCoreClock variable value. Otherwise, any configuration
    282            *         based on this variable will be incorrect.         
    283            *     
    284            * @note   - The system frequency computed by this function is not the real 
    285            *           frequency in the chip. It is calculated based on the predefined 
    286            *           constant and the selected clock source:
    287            *             
    288            *           - If SYSCLK source is HSI, SystemCoreClock will contain the HSI_VALUE(*)
    289            *                                              
    290            *           - If SYSCLK source is HSE, SystemCoreClock will contain the HSE_VALUE(**)
    291            *                          
    292            *           - If SYSCLK source is PLL, SystemCoreClock will contain the HSE_VALUE(**) 
    293            *             or HSI_VALUE(*) multiplied by the PLL factors.
    294            *         
    295            *         (*) HSI_VALUE is a constant defined in stm32f1xx.h file (default value
    296            *             8 MHz) but the real value may vary depending on the variations
    297            *             in voltage and temperature.   
    298            *    
    299            *         (**) HSE_VALUE is a constant defined in stm32f1xx.h file (default value
    300            *              8 MHz or 25 MHz, depedning on the product used), user has to ensure
    301            *              that HSE_VALUE is same as the real frequency of the crystal used.
    302            *              Otherwise, this function may have wrong result.
    303            *                
    304            *         - The result of this function could be not correct when using fractional
    305            *           value for HSE crystal.
    306            * @param  None
    307            * @retval None
    308            */

   \                                 In section .text, align 2, keep-with-next
    309          void SystemCoreClockUpdate (void)
    310          {
   \                     SystemCoreClockUpdate: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
    311            uint32_t tmp = 0, pllmull = 0, pllsource = 0;
    312          
    313          #ifdef  STM32F10X_CL
    314            uint32_t prediv1source = 0, prediv1factor = 0, prediv2factor = 0, pll2mull = 0;
    315          #endif /* STM32F10X_CL */
    316          
    317          #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)
    318            uint32_t prediv1factor = 0;
    319          #endif /* STM32F10X_LD_VL or STM32F10X_MD_VL or STM32F10X_HD_VL */
    320              
    321            /* Get SYSCLK source -------------------------------------------------------*/
    322            tmp = RCC->CFGR & RCC_CFGR_SWS;
   \        0x2   0x....             LDR.N    R0,??DataTable1_5
    323            
    324            switch (tmp)
   \        0x4   0x....             LDR.N    R1,??DataTable1_6
   \        0x6   0x6802             LDR      R2,[R0, #+0]
   \        0x8   0xF002 0x020C      AND      R2,R2,#0xC
   \        0xC   0x2A08             CMP      R2,#+8
   \        0xE   0xD109             BNE.N    ??SystemCoreClockUpdate_0
    325            {
    326              case 0x00:  /* HSI used as system clock */
    327                SystemCoreClock = HSI_VALUE;
    328                break;
    329              case 0x04:  /* HSE used as system clock */
    330                SystemCoreClock = HSE_VALUE;
    331                break;
    332              case 0x08:  /* PLL used as system clock */
    333          
    334                /* Get PLL clock source and multiplication factor ----------------------*/
    335                pllmull = RCC->CFGR & RCC_CFGR_PLLMULL;
   \       0x10   0x6802             LDR      R2,[R0, #+0]
    336                pllsource = RCC->CFGR & RCC_CFGR_PLLSRC;
   \       0x12   0x6804             LDR      R4,[R0, #+0]
    337                
    338          #ifndef STM32F10X_CL      
    339                pllmull = ( pllmull >> 18) + 2;
    340                
    341                if (pllsource == 0x00)
   \       0x14   0x....             LDR.N    R3,??DataTable1_7
   \       0x16   0xF3C2 0x4283      UBFX     R2,R2,#+18,#+4
   \       0x1A   0x1C92             ADDS     R2,R2,#+2
   \       0x1C   0x4353             MULS     R3,R3,R2
   \       0x1E   0x03E4             LSLS     R4,R4,#+15
   \       0x20   0xD409             BMI.N    ??SystemCoreClockUpdate_1
    342                {
    343                  /* HSI oscillator clock divided by 2 selected as PLL clock entry */
    344                  SystemCoreClock = (HSI_VALUE >> 1) * pllmull;
   \                     ??SystemCoreClockUpdate_2: (+1)
   \       0x22   0x4619             MOV      R1,R3
    345                }
    346                else
    347                {
    348           #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)
    349                 prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;
    350                 /* HSE oscillator clock selected as PREDIV1 clock entry */
    351                 SystemCoreClock = (HSE_VALUE / prediv1factor) * pllmull; 
    352           #else
    353                  /* HSE selected as PLL clock entry */
    354                  if ((RCC->CFGR & RCC_CFGR_PLLXTPRE) != (uint32_t)RESET)
    355                  {/* HSE oscillator clock divided by 2 */
    356                    SystemCoreClock = (HSE_VALUE >> 1) * pllmull;
    357                  }
    358                  else
    359                  {
    360                    SystemCoreClock = HSE_VALUE * pllmull;
    361                  }
    362           #endif
    363                }
    364          #else
    365                pllmull = pllmull >> 18;
    366                
    367                if (pllmull != 0x0D)
    368                {
    369                   pllmull += 2;
    370                }
    371                else
    372                { /* PLL multiplication factor = PLL input clock * 6.5 */
    373                  pllmull = 13 / 2; 
    374                }
    375                      
    376                if (pllsource == 0x00)
    377                {
    378                  /* HSI oscillator clock divided by 2 selected as PLL clock entry */
    379                  SystemCoreClock = (HSI_VALUE >> 1) * pllmull;
    380                }
    381                else
    382                {/* PREDIV1 selected as PLL clock entry */
    383                  
    384                  /* Get PREDIV1 clock source and division factor */
    385                  prediv1source = RCC->CFGR2 & RCC_CFGR2_PREDIV1SRC;
    386                  prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;
    387                  
    388                  if (prediv1source == 0)
    389                  { 
    390                    /* HSE oscillator clock selected as PREDIV1 clock entry */
    391                    SystemCoreClock = (HSE_VALUE / prediv1factor) * pllmull;          
    392                  }
    393                  else
    394                  {/* PLL2 clock selected as PREDIV1 clock entry */
    395                    
    396                    /* Get PREDIV2 division factor and PLL2 multiplication factor */
    397                    prediv2factor = ((RCC->CFGR2 & RCC_CFGR2_PREDIV2) >> 4) + 1;
    398                    pll2mull = ((RCC->CFGR2 & RCC_CFGR2_PLL2MUL) >> 8 ) + 2; 
    399                    SystemCoreClock = (((HSE_VALUE / prediv2factor) * pll2mull) / prediv1factor) * pllmull;                         
    400                  }
    401                }
    402          #endif /* STM32F10X_CL */ 
    403                break;
    404          
    405              default:
    406                SystemCoreClock = HSI_VALUE;
    407                break;
    408            }
    409            
    410            /* Compute HCLK clock frequency ----------------*/
    411            /* Get HCLK prescaler */
    412            tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
    413            /* HCLK clock frequency */
    414            SystemCoreClock >>= tmp;  
   \                     ??SystemCoreClockUpdate_0: (+1)
   \       0x24   0x....             LDR.N    R2,??DataTable1_8
   \       0x26   0x6111             STR      R1,[R2, #+16]
   \       0x28   0x6800             LDR      R0,[R0, #+0]
   \       0x2A   0xF3C0 0x1003      UBFX     R0,R0,#+4,#+4
   \       0x2E   0x5C10             LDRB     R0,[R2, R0]
   \       0x30   0x40C1             LSRS     R1,R1,R0
   \       0x32   0x6111             STR      R1,[R2, #+16]
    415          }
   \       0x34   0xBD30             POP      {R4,R5,PC}
   \                     ??SystemCoreClockUpdate_1: (+1)
   \       0x36   0x6804             LDR      R4,[R0, #+0]
   \       0x38   0x03A5             LSLS     R5,R4,#+14
   \       0x3A   0xD4F2             BMI.N    ??SystemCoreClockUpdate_2
   \       0x3C   0x4351             MULS     R1,R1,R2
   \       0x3E   0xE7F1             B.N      ??SystemCoreClockUpdate_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \        0x0   0x4002'1000        DC32     0x40021000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \        0x0   0xF8FF'0000        DC32     0xf8ff0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \        0x0   0xFEF6'FFFF        DC32     0xfef6ffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_3:
   \        0x0   0x4002'2000        DC32     0x40022000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_4:
   \        0x0   0xE000'ED08        DC32     0xe000ed08

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_5:
   \        0x0   0x4002'1004        DC32     0x40021004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_6:
   \        0x0   0x007A'1200        DC32     0x7a1200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_7:
   \        0x0   0x003D'0900        DC32     0x3d0900

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_8:
   \        0x0   0x....'....        DC32     AHBPrescTable
    416          
    417          /**
    418            * @brief  Configures the System clock frequency, HCLK, PCLK2 and PCLK1 prescalers.
    419            * @param  None
    420            * @retval None
    421            */
    422          static void SetSysClock(void)
    423          {
    424          #ifdef SYSCLK_FREQ_HSE
    425            SetSysClockToHSE();
    426          #elif defined SYSCLK_FREQ_24MHz
    427            SetSysClockTo24();
    428          #elif defined SYSCLK_FREQ_36MHz
    429            SetSysClockTo36();
    430          #elif defined SYSCLK_FREQ_48MHz
    431            SetSysClockTo48();
    432          #elif defined SYSCLK_FREQ_56MHz
    433            SetSysClockTo56();  
    434          #elif defined SYSCLK_FREQ_72MHz
    435            SetSysClockTo72();
    436          #endif
    437           
    438           /* If none of the define above is enabled, the HSI is used as System clock
    439              source (default after reset) */ 
    440          }
    441          
    442          /**
    443            * @brief  Setup the external memory controller. Called in startup_stm32f10x.s 
    444            *          before jump to __main
    445            * @param  None
    446            * @retval None
    447            */ 
    448          #ifdef DATA_IN_ExtSRAM
    449          /**
    450            * @brief  Setup the external memory controller. 
    451            *         Called in startup_stm32f10x_xx.s/.c before jump to main.
    452            * 	      This function configures the external SRAM mounted on STM3210E-EVAL
    453            *         board (STM32 High density devices). This SRAM will be used as program
    454            *         data memory (including heap and stack).
    455            * @param  None
    456            * @retval None
    457            */ 
    458          void SystemInit_ExtMemCtl(void) 
    459          {
    460          /*!< FSMC Bank1 NOR/SRAM3 is used for the STM3210E-EVAL, if another Bank is 
    461            required, then adjust the Register Addresses */
    462          
    463            /* Enable FSMC clock */
    464            RCC->AHBENR = 0x00000114;
    465            
    466            /* Enable GPIOD, GPIOE, GPIOF and GPIOG clocks */  
    467            RCC->APB2ENR = 0x000001E0;
    468            
    469          /* ---------------  SRAM Data lines, NOE and NWE configuration ---------------*/
    470          /*----------------  SRAM Address lines configuration -------------------------*/
    471          /*----------------  NOE and NWE configuration --------------------------------*/  
    472          /*----------------  NE3 configuration ----------------------------------------*/
    473          /*----------------  NBL0, NBL1 configuration ---------------------------------*/
    474            
    475            GPIOD->CRL = 0x44BB44BB;  
    476            GPIOD->CRH = 0xBBBBBBBB;
    477          
    478            GPIOE->CRL = 0xB44444BB;  
    479            GPIOE->CRH = 0xBBBBBBBB;
    480          
    481            GPIOF->CRL = 0x44BBBBBB;  
    482            GPIOF->CRH = 0xBBBB4444;
    483          
    484            GPIOG->CRL = 0x44BBBBBB;  
    485            GPIOG->CRH = 0x44444B44;
    486             
    487          /*----------------  FSMC Configuration ---------------------------------------*/  
    488          /*----------------  Enable FSMC Bank1_SRAM Bank ------------------------------*/
    489            
    490            FSMC_Bank1->BTCR[4] = 0x00001011;
    491            FSMC_Bank1->BTCR[5] = 0x00000200;
    492          }
    493          #endif /* DATA_IN_ExtSRAM */
    494          
    495          #ifdef SYSCLK_FREQ_HSE
    496          /**
    497            * @brief  Selects HSE as System clock source and configure HCLK, PCLK2
    498            *         and PCLK1 prescalers.
    499            * @note   This function should be used only after reset.
    500            * @param  None
    501            * @retval None
    502            */
    503          static void SetSysClockToHSE(void)
    504          {
    505            __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
    506            
    507            /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/    
    508            /* Enable HSE */    
    509            RCC->CR |= ((uint32_t)RCC_CR_HSEON);
    510           
    511            /* Wait till HSE is ready and if Time out is reached exit */
    512            do
    513            {
    514              HSEStatus = RCC->CR & RCC_CR_HSERDY;
    515              StartUpCounter++;  
    516            } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
    517          
    518            if ((RCC->CR & RCC_CR_HSERDY) != RESET)
    519            {
    520              HSEStatus = (uint32_t)0x01;
    521            }
    522            else
    523            {
    524              HSEStatus = (uint32_t)0x00;
    525            }  
    526          
    527            if (HSEStatus == (uint32_t)0x01)
    528            {
    529          
    530          #if !defined STM32F10X_LD_VL && !defined STM32F10X_MD_VL && !defined STM32F10X_HD_VL
    531              /* Enable Prefetch Buffer */
    532              FLASH->ACR |= FLASH_ACR_PRFTBE;
    533          
    534              /* Flash 0 wait state */
    535              FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
    536          
    537          #ifndef STM32F10X_CL
    538              FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_0;
    539          #else
    540              if (HSE_VALUE <= 24000000)
    541          	{
    542                FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_0;
    543          	}
    544          	else
    545          	{
    546                FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_1;
    547          	}
    548          #endif /* STM32F10X_CL */
    549          #endif
    550           
    551              /* HCLK = SYSCLK */
    552              RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
    553                
    554              /* PCLK2 = HCLK */
    555              RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;
    556              
    557              /* PCLK1 = HCLK */
    558              RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV1;
    559              
    560              /* Select HSE as system clock source */
    561              RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
    562              RCC->CFGR |= (uint32_t)RCC_CFGR_SW_HSE;    
    563          
    564              /* Wait till HSE is used as system clock source */
    565              while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x04)
    566              {
    567              }
    568            }
    569            else
    570            { /* If HSE fails to start-up, the application will have wrong clock 
    571                   configuration. User can add here some code to deal with this error */
    572            }  
    573          }
    574          #elif defined SYSCLK_FREQ_24MHz
    575          /**
    576            * @brief  Sets System clock frequency to 24MHz and configure HCLK, PCLK2 
    577            *         and PCLK1 prescalers.
    578            * @note   This function should be used only after reset.
    579            * @param  None
    580            * @retval None
    581            */
    582          static void SetSysClockTo24(void)
    583          {
    584            __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
    585            
    586            /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/    
    587            /* Enable HSE */    
    588            RCC->CR |= ((uint32_t)RCC_CR_HSEON);
    589           
    590            /* Wait till HSE is ready and if Time out is reached exit */
    591            do
    592            {
    593              HSEStatus = RCC->CR & RCC_CR_HSERDY;
    594              StartUpCounter++;  
    595            } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
    596          
    597            if ((RCC->CR & RCC_CR_HSERDY) != RESET)
    598            {
    599              HSEStatus = (uint32_t)0x01;
    600            }
    601            else
    602            {
    603              HSEStatus = (uint32_t)0x00;
    604            }  
    605          
    606            if (HSEStatus == (uint32_t)0x01)
    607            {
    608          #if !defined STM32F10X_LD_VL && !defined STM32F10X_MD_VL && !defined STM32F10X_HD_VL 
    609              /* Enable Prefetch Buffer */
    610              FLASH->ACR |= FLASH_ACR_PRFTBE;
    611          
    612              /* Flash 0 wait state */
    613              FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
    614              FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_0;    
    615          #endif
    616           
    617              /* HCLK = SYSCLK */
    618              RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
    619                
    620              /* PCLK2 = HCLK */
    621              RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;
    622              
    623              /* PCLK1 = HCLK */
    624              RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV1;
    625              
    626          #ifdef STM32F10X_CL
    627              /* Configure PLLs ------------------------------------------------------*/
    628              /* PLL configuration: PLLCLK = PREDIV1 * 6 = 24 MHz */ 
    629              RCC->CFGR &= (uint32_t)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);
    630              RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 | 
    631                                      RCC_CFGR_PLLMULL6); 
    632          
    633              /* PLL2 configuration: PLL2CLK = (HSE / 5) * 8 = 40 MHz */
    634              /* PREDIV1 configuration: PREDIV1CLK = PLL2 / 10 = 4 MHz */       
    635              RCC->CFGR2 &= (uint32_t)~(RCC_CFGR2_PREDIV2 | RCC_CFGR2_PLL2MUL |
    636                                        RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC);
    637              RCC->CFGR2 |= (uint32_t)(RCC_CFGR2_PREDIV2_DIV5 | RCC_CFGR2_PLL2MUL8 |
    638                                       RCC_CFGR2_PREDIV1SRC_PLL2 | RCC_CFGR2_PREDIV1_DIV10);
    639            
    640              /* Enable PLL2 */
    641              RCC->CR |= RCC_CR_PLL2ON;
    642              /* Wait till PLL2 is ready */
    643              while((RCC->CR & RCC_CR_PLL2RDY) == 0)
    644              {
    645              }   
    646          #elif defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
    647              /*  PLL configuration:  = (HSE / 2) * 6 = 24 MHz */
    648              RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLMULL));
    649              RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_PREDIV1 | RCC_CFGR_PLLXTPRE_PREDIV1_Div2 | RCC_CFGR_PLLMULL6);
    650          #else    
    651              /*  PLL configuration:  = (HSE / 2) * 6 = 24 MHz */
    652              RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLMULL));
    653              RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLXTPRE_HSE_Div2 | RCC_CFGR_PLLMULL6);
    654          #endif /* STM32F10X_CL */
    655          
    656              /* Enable PLL */
    657              RCC->CR |= RCC_CR_PLLON;
    658          
    659              /* Wait till PLL is ready */
    660              while((RCC->CR & RCC_CR_PLLRDY) == 0)
    661              {
    662              }
    663          
    664              /* Select PLL as system clock source */
    665              RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
    666              RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;    
    667          
    668              /* Wait till PLL is used as system clock source */
    669              while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)
    670              {
    671              }
    672            }
    673            else
    674            { /* If HSE fails to start-up, the application will have wrong clock 
    675                   configuration. User can add here some code to deal with this error */
    676            } 
    677          }
    678          #elif defined SYSCLK_FREQ_36MHz
    679          /**
    680            * @brief  Sets System clock frequency to 36MHz and configure HCLK, PCLK2 
    681            *         and PCLK1 prescalers. 
    682            * @note   This function should be used only after reset.
    683            * @param  None
    684            * @retval None
    685            */
    686          static void SetSysClockTo36(void)
    687          {
    688            __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
    689            
    690            /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/    
    691            /* Enable HSE */    
    692            RCC->CR |= ((uint32_t)RCC_CR_HSEON);
    693           
    694            /* Wait till HSE is ready and if Time out is reached exit */
    695            do
    696            {
    697              HSEStatus = RCC->CR & RCC_CR_HSERDY;
    698              StartUpCounter++;  
    699            } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
    700          
    701            if ((RCC->CR & RCC_CR_HSERDY) != RESET)
    702            {
    703              HSEStatus = (uint32_t)0x01;
    704            }
    705            else
    706            {
    707              HSEStatus = (uint32_t)0x00;
    708            }  
    709          
    710            if (HSEStatus == (uint32_t)0x01)
    711            {
    712              /* Enable Prefetch Buffer */
    713              FLASH->ACR |= FLASH_ACR_PRFTBE;
    714          
    715              /* Flash 1 wait state */
    716              FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
    717              FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_1;    
    718           
    719              /* HCLK = SYSCLK */
    720              RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
    721                
    722              /* PCLK2 = HCLK */
    723              RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;
    724              
    725              /* PCLK1 = HCLK */
    726              RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV1;
    727              
    728          #ifdef STM32F10X_CL
    729              /* Configure PLLs ------------------------------------------------------*/
    730              
    731              /* PLL configuration: PLLCLK = PREDIV1 * 9 = 36 MHz */ 
    732              RCC->CFGR &= (uint32_t)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);
    733              RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 | 
    734                                      RCC_CFGR_PLLMULL9); 
    735          
    736          	/*!< PLL2 configuration: PLL2CLK = (HSE / 5) * 8 = 40 MHz */
    737              /* PREDIV1 configuration: PREDIV1CLK = PLL2 / 10 = 4 MHz */
    738                  
    739              RCC->CFGR2 &= (uint32_t)~(RCC_CFGR2_PREDIV2 | RCC_CFGR2_PLL2MUL |
    740                                        RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC);
    741              RCC->CFGR2 |= (uint32_t)(RCC_CFGR2_PREDIV2_DIV5 | RCC_CFGR2_PLL2MUL8 |
    742                                       RCC_CFGR2_PREDIV1SRC_PLL2 | RCC_CFGR2_PREDIV1_DIV10);
    743            
    744              /* Enable PLL2 */
    745              RCC->CR |= RCC_CR_PLL2ON;
    746              /* Wait till PLL2 is ready */
    747              while((RCC->CR & RCC_CR_PLL2RDY) == 0)
    748              {
    749              }
    750              
    751          #else    
    752              /*  PLL configuration: PLLCLK = (HSE / 2) * 9 = 36 MHz */
    753              RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLMULL));
    754              RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLXTPRE_HSE_Div2 | RCC_CFGR_PLLMULL9);
    755          #endif /* STM32F10X_CL */
    756          
    757              /* Enable PLL */
    758              RCC->CR |= RCC_CR_PLLON;
    759          
    760              /* Wait till PLL is ready */
    761              while((RCC->CR & RCC_CR_PLLRDY) == 0)
    762              {
    763              }
    764          
    765              /* Select PLL as system clock source */
    766              RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
    767              RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;    
    768          
    769              /* Wait till PLL is used as system clock source */
    770              while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)
    771              {
    772              }
    773            }
    774            else
    775            { /* If HSE fails to start-up, the application will have wrong clock 
    776                   configuration. User can add here some code to deal with this error */
    777            } 
    778          }
    779          #elif defined SYSCLK_FREQ_48MHz
    780          /**
    781            * @brief  Sets System clock frequency to 48MHz and configure HCLK, PCLK2 
    782            *         and PCLK1 prescalers. 
    783            * @note   This function should be used only after reset.
    784            * @param  None
    785            * @retval None
    786            */
    787          static void SetSysClockTo48(void)
    788          {
    789            __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
    790            
    791            /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/    
    792            /* Enable HSE */    
    793            RCC->CR |= ((uint32_t)RCC_CR_HSEON);
    794           
    795            /* Wait till HSE is ready and if Time out is reached exit */
    796            do
    797            {
    798              HSEStatus = RCC->CR & RCC_CR_HSERDY;
    799              StartUpCounter++;  
    800            } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
    801          
    802            if ((RCC->CR & RCC_CR_HSERDY) != RESET)
    803            {
    804              HSEStatus = (uint32_t)0x01;
    805            }
    806            else
    807            {
    808              HSEStatus = (uint32_t)0x00;
    809            }  
    810          
    811            if (HSEStatus == (uint32_t)0x01)
    812            {
    813              /* Enable Prefetch Buffer */
    814              FLASH->ACR |= FLASH_ACR_PRFTBE;
    815          
    816              /* Flash 1 wait state */
    817              FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
    818              FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_1;    
    819           
    820              /* HCLK = SYSCLK */
    821              RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
    822                
    823              /* PCLK2 = HCLK */
    824              RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;
    825              
    826              /* PCLK1 = HCLK */
    827              RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;
    828              
    829          #ifdef STM32F10X_CL
    830              /* Configure PLLs ------------------------------------------------------*/
    831              /* PLL2 configuration: PLL2CLK = (HSE / 5) * 8 = 40 MHz */
    832              /* PREDIV1 configuration: PREDIV1CLK = PLL2 / 5 = 8 MHz */
    833                  
    834              RCC->CFGR2 &= (uint32_t)~(RCC_CFGR2_PREDIV2 | RCC_CFGR2_PLL2MUL |
    835                                        RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC);
    836              RCC->CFGR2 |= (uint32_t)(RCC_CFGR2_PREDIV2_DIV5 | RCC_CFGR2_PLL2MUL8 |
    837                                       RCC_CFGR2_PREDIV1SRC_PLL2 | RCC_CFGR2_PREDIV1_DIV5);
    838            
    839              /* Enable PLL2 */
    840              RCC->CR |= RCC_CR_PLL2ON;
    841              /* Wait till PLL2 is ready */
    842              while((RCC->CR & RCC_CR_PLL2RDY) == 0)
    843              {
    844              }
    845              
    846             
    847              /* PLL configuration: PLLCLK = PREDIV1 * 6 = 48 MHz */ 
    848              RCC->CFGR &= (uint32_t)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);
    849              RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 | 
    850                                      RCC_CFGR_PLLMULL6); 
    851          #else    
    852              /*  PLL configuration: PLLCLK = HSE * 6 = 48 MHz */
    853              RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLMULL));
    854              RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLMULL6);
    855          #endif /* STM32F10X_CL */
    856          
    857              /* Enable PLL */
    858              RCC->CR |= RCC_CR_PLLON;
    859          
    860              /* Wait till PLL is ready */
    861              while((RCC->CR & RCC_CR_PLLRDY) == 0)
    862              {
    863              }
    864          
    865              /* Select PLL as system clock source */
    866              RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
    867              RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;    
    868          
    869              /* Wait till PLL is used as system clock source */
    870              while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)
    871              {
    872              }
    873            }
    874            else
    875            { /* If HSE fails to start-up, the application will have wrong clock 
    876                   configuration. User can add here some code to deal with this error */
    877            } 
    878          }
    879          
    880          #elif defined SYSCLK_FREQ_56MHz
    881          /**
    882            * @brief  Sets System clock frequency to 56MHz and configure HCLK, PCLK2 
    883            *         and PCLK1 prescalers. 
    884            * @note   This function should be used only after reset.
    885            * @param  None
    886            * @retval None
    887            */
    888          static void SetSysClockTo56(void)
    889          {
    890            __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
    891            
    892            /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/   
    893            /* Enable HSE */    
    894            RCC->CR |= ((uint32_t)RCC_CR_HSEON);
    895           
    896            /* Wait till HSE is ready and if Time out is reached exit */
    897            do
    898            {
    899              HSEStatus = RCC->CR & RCC_CR_HSERDY;
    900              StartUpCounter++;  
    901            } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
    902          
    903            if ((RCC->CR & RCC_CR_HSERDY) != RESET)
    904            {
    905              HSEStatus = (uint32_t)0x01;
    906            }
    907            else
    908            {
    909              HSEStatus = (uint32_t)0x00;
    910            }  
    911          
    912            if (HSEStatus == (uint32_t)0x01)
    913            {
    914              /* Enable Prefetch Buffer */
    915              FLASH->ACR |= FLASH_ACR_PRFTBE;
    916          
    917              /* Flash 2 wait state */
    918              FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
    919              FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_2;    
    920           
    921              /* HCLK = SYSCLK */
    922              RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
    923                
    924              /* PCLK2 = HCLK */
    925              RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;
    926              
    927              /* PCLK1 = HCLK */
    928              RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;
    929          
    930          #ifdef STM32F10X_CL
    931              /* Configure PLLs ------------------------------------------------------*/
    932              /* PLL2 configuration: PLL2CLK = (HSE / 5) * 8 = 40 MHz */
    933              /* PREDIV1 configuration: PREDIV1CLK = PLL2 / 5 = 8 MHz */
    934                  
    935              RCC->CFGR2 &= (uint32_t)~(RCC_CFGR2_PREDIV2 | RCC_CFGR2_PLL2MUL |
    936                                        RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC);
    937              RCC->CFGR2 |= (uint32_t)(RCC_CFGR2_PREDIV2_DIV5 | RCC_CFGR2_PLL2MUL8 |
    938                                       RCC_CFGR2_PREDIV1SRC_PLL2 | RCC_CFGR2_PREDIV1_DIV5);
    939            
    940              /* Enable PLL2 */
    941              RCC->CR |= RCC_CR_PLL2ON;
    942              /* Wait till PLL2 is ready */
    943              while((RCC->CR & RCC_CR_PLL2RDY) == 0)
    944              {
    945              }
    946              
    947             
    948              /* PLL configuration: PLLCLK = PREDIV1 * 7 = 56 MHz */ 
    949              RCC->CFGR &= (uint32_t)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);
    950              RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 | 
    951                                      RCC_CFGR_PLLMULL7); 
    952          #else     
    953              /* PLL configuration: PLLCLK = HSE * 7 = 56 MHz */
    954              RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLMULL));
    955              RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLMULL7);
    956          
    957          #endif /* STM32F10X_CL */
    958          
    959              /* Enable PLL */
    960              RCC->CR |= RCC_CR_PLLON;
    961          
    962              /* Wait till PLL is ready */
    963              while((RCC->CR & RCC_CR_PLLRDY) == 0)
    964              {
    965              }
    966          
    967              /* Select PLL as system clock source */
    968              RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
    969              RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;    
    970          
    971              /* Wait till PLL is used as system clock source */
    972              while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)
    973              {
    974              }
    975            }
    976            else
    977            { /* If HSE fails to start-up, the application will have wrong clock 
    978                   configuration. User can add here some code to deal with this error */
    979            } 
    980          }
    981          
    982          #elif defined SYSCLK_FREQ_72MHz
    983          /**
    984            * @brief  Sets System clock frequency to 72MHz and configure HCLK, PCLK2 
    985            *         and PCLK1 prescalers. 
    986            * @note   This function should be used only after reset.
    987            * @param  None
    988            * @retval None
    989            */
    990          static void SetSysClockTo72(void)
    991          {
    992            __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
    993            
    994            /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/    
    995            /* Enable HSE */    
    996            RCC->CR |= ((uint32_t)RCC_CR_HSEON);
    997           
    998            /* Wait till HSE is ready and if Time out is reached exit */
    999            do
   1000            {
   1001              HSEStatus = RCC->CR & RCC_CR_HSERDY;
   1002              StartUpCounter++;  
   1003            } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
   1004          
   1005            if ((RCC->CR & RCC_CR_HSERDY) != RESET)
   1006            {
   1007              HSEStatus = (uint32_t)0x01;
   1008            }
   1009            else
   1010            {
   1011              HSEStatus = (uint32_t)0x00;
   1012            }  
   1013          
   1014            if (HSEStatus == (uint32_t)0x01)
   1015            {
   1016              /* Enable Prefetch Buffer */
   1017              FLASH->ACR |= FLASH_ACR_PRFTBE;
   1018          
   1019              /* Flash 2 wait state */
   1020              FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
   1021              FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_2;    
   1022          
   1023           
   1024              /* HCLK = SYSCLK */
   1025              RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
   1026                
   1027              /* PCLK2 = HCLK */
   1028              RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;
   1029              
   1030              /* PCLK1 = HCLK */
   1031              RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;
   1032          
   1033          #ifdef STM32F10X_CL
   1034              /* Configure PLLs ------------------------------------------------------*/
   1035              /* PLL2 configuration: PLL2CLK = (HSE / 5) * 8 = 40 MHz */
   1036              /* PREDIV1 configuration: PREDIV1CLK = PLL2 / 5 = 8 MHz */
   1037                  
   1038              RCC->CFGR2 &= (uint32_t)~(RCC_CFGR2_PREDIV2 | RCC_CFGR2_PLL2MUL |
   1039                                        RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC);
   1040              RCC->CFGR2 |= (uint32_t)(RCC_CFGR2_PREDIV2_DIV5 | RCC_CFGR2_PLL2MUL8 |
   1041                                       RCC_CFGR2_PREDIV1SRC_PLL2 | RCC_CFGR2_PREDIV1_DIV5);
   1042            
   1043              /* Enable PLL2 */
   1044              RCC->CR |= RCC_CR_PLL2ON;
   1045              /* Wait till PLL2 is ready */
   1046              while((RCC->CR & RCC_CR_PLL2RDY) == 0)
   1047              {
   1048              }
   1049              
   1050             
   1051              /* PLL configuration: PLLCLK = PREDIV1 * 9 = 72 MHz */ 
   1052              RCC->CFGR &= (uint32_t)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);
   1053              RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 | 
   1054                                      RCC_CFGR_PLLMULL9); 
   1055          #else    
   1056              /*  PLL configuration: PLLCLK = HSE * 9 = 72 MHz */
   1057              RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE |
   1058                                                  RCC_CFGR_PLLMULL));
   1059              RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLMULL9);
   1060          #endif /* STM32F10X_CL */
   1061          
   1062              /* Enable PLL */
   1063              RCC->CR |= RCC_CR_PLLON;
   1064          
   1065              /* Wait till PLL is ready */
   1066              while((RCC->CR & RCC_CR_PLLRDY) == 0)
   1067              {
   1068              }
   1069              
   1070              /* Select PLL as system clock source */
   1071              RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
   1072              RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;    
   1073          
   1074              /* Wait till PLL is used as system clock source */
   1075              while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)
   1076              {
   1077              }
   1078            }
   1079            else
   1080            { /* If HSE fails to start-up, the application will have wrong clock 
   1081                   configuration. User can add here some code to deal with this error */
   1082            }
   1083          }
   1084          #endif
   1085          
   1086          /**
   1087            * @}
   1088            */
   1089          
   1090          /**
   1091            * @}
   1092            */
   1093            
   1094          /**
   1095            * @}
   1096            */    
   1097          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      12   SystemCoreClockUpdate
      16   SystemInit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
       4  ??DataTable1_3
       4  ??DataTable1_4
       4  ??DataTable1_5
       4  ??DataTable1_6
       4  ??DataTable1_7
       4  ??DataTable1_8
      20  AHBPrescTable
          SystemCoreClock
      64  SystemCoreClockUpdate
     214  SystemInit

 
  20 bytes in section .data
 314 bytes in section .text
 
 314 bytes of CODE memory
  20 bytes of DATA memory

Errors: none
Warnings: none
