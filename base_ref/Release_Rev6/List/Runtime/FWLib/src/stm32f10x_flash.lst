###############################################################################
#
# IAR ANSI C/C++ Compiler V9.10.2.313/W64 for ARM         28/Jul/2021  15:57:32
# Copyright 1999-2021 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\infra_pub\arch\st_fwlib\STM32F10x_StdPeriph_Driver\src\stm32f10x_flash.c
#    Command line      =
#        -f
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\Release_Rev6\List\Runtime\FWLib\src\stm32f10x_flash.lst.rsp
#        (C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\infra_pub\arch\st_fwlib\STM32F10x_StdPeriph_Driver\src\stm32f10x_flash.c
#        -D USE_STDPERIPH_DRIVER -D STM32F10X_HD -D USART_ENABLE_USART3 -D
#        CONFIG_BREAKOUT_REV=6 -D USE_FRONT_IR_SENSORS -D FEATURE_SET_V -lCN
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\Release_Rev6\List\Runtime\FWLib\src
#        --diag_suppress Pa050 -o
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\Release_Rev6\Obj\Runtime\FWLib\src
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        9.0\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\src\
#        -I
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\..\..\common\inc\
#        -I
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\..\infra_pub\
#        -I
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\..\infra_pub\arch\st_fwlib\CMSIS\CM3\CoreSupport\
#        -I
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\..\infra_pub\arch\st_fwlib\CMSIS\CM3\DeviceSupport\ST\STM32F10x\
#        -I
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\..\infra_pub\arch\st_fwlib\STM32F10x_StdPeriph_Driver\inc\
#        -I
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\..\infra_pub\arch\infra_stm32\
#        -I
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\..\infra_pub\arch\infra_stm32\32f10x\
#        -Ohz --use_c++_inline) --dependencies=n
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\Release_Rev6\Obj\Runtime\FWLib\src\stm32f10x_flash.o.d
#    Locale            =  C
#    List file         =
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\Release_Rev6\List\Runtime\FWLib\src\stm32f10x_flash.lst
#    Object file       =
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\Release_Rev6\Obj\Runtime\FWLib\src\stm32f10x_flash.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\infra_pub\arch\st_fwlib\STM32F10x_StdPeriph_Driver\src\stm32f10x_flash.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f10x_flash.c
      4            * @author  MCD Application Team
      5            * @version V3.5.0
      6            * @date    11-March-2011
      7            * @brief   This file provides all the FLASH firmware functions.
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     19            ******************************************************************************
     20            */
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "stm32f10x_flash.h"
     24          
     25          /** @addtogroup STM32F10x_StdPeriph_Driver
     26            * @{
     27            */
     28          
     29          /** @defgroup FLASH 
     30            * @brief FLASH driver modules
     31            * @{
     32            */ 
     33          
     34          /** @defgroup FLASH_Private_TypesDefinitions
     35            * @{
     36            */
     37          
     38          /**
     39            * @}
     40            */ 
     41          
     42          /** @defgroup FLASH_Private_Defines
     43            * @{
     44            */ 
     45          
     46          /* Flash Access Control Register bits */
     47          #define ACR_LATENCY_Mask         ((uint32_t)0x00000038)
     48          #define ACR_HLFCYA_Mask          ((uint32_t)0xFFFFFFF7)
     49          #define ACR_PRFTBE_Mask          ((uint32_t)0xFFFFFFEF)
     50          
     51          /* Flash Access Control Register bits */
     52          #define ACR_PRFTBS_Mask          ((uint32_t)0x00000020) 
     53          
     54          /* Flash Control Register bits */
     55          #define CR_PG_Set                ((uint32_t)0x00000001)
     56          #define CR_PG_Reset              ((uint32_t)0x00001FFE) 
     57          #define CR_PER_Set               ((uint32_t)0x00000002)
     58          #define CR_PER_Reset             ((uint32_t)0x00001FFD)
     59          #define CR_MER_Set               ((uint32_t)0x00000004)
     60          #define CR_MER_Reset             ((uint32_t)0x00001FFB)
     61          #define CR_OPTPG_Set             ((uint32_t)0x00000010)
     62          #define CR_OPTPG_Reset           ((uint32_t)0x00001FEF)
     63          #define CR_OPTER_Set             ((uint32_t)0x00000020)
     64          #define CR_OPTER_Reset           ((uint32_t)0x00001FDF)
     65          #define CR_STRT_Set              ((uint32_t)0x00000040)
     66          #define CR_LOCK_Set              ((uint32_t)0x00000080)
     67          
     68          /* FLASH Mask */
     69          #define RDPRT_Mask               ((uint32_t)0x00000002)
     70          #define WRP0_Mask                ((uint32_t)0x000000FF)
     71          #define WRP1_Mask                ((uint32_t)0x0000FF00)
     72          #define WRP2_Mask                ((uint32_t)0x00FF0000)
     73          #define WRP3_Mask                ((uint32_t)0xFF000000)
     74          #define OB_USER_BFB2             ((uint16_t)0x0008)
     75          
     76          /* FLASH Keys */
     77          #define RDP_Key                  ((uint16_t)0x00A5)
     78          #define FLASH_KEY1               ((uint32_t)0x45670123)
     79          #define FLASH_KEY2               ((uint32_t)0xCDEF89AB)
     80          
     81          /* FLASH BANK address */
     82          #define FLASH_BANK1_END_ADDRESS   ((uint32_t)0x807FFFF)
     83          
     84          /* Delay definition */   
     85          #define EraseTimeout          ((uint32_t)0x000B0000)
     86          #define ProgramTimeout        ((uint32_t)0x00002000)
     87          /**
     88            * @}
     89            */ 
     90          
     91          /** @defgroup FLASH_Private_Macros
     92            * @{
     93            */
     94          
     95          /**
     96            * @}
     97            */ 
     98          
     99          /** @defgroup FLASH_Private_Variables
    100            * @{
    101            */
    102          
    103          /**
    104            * @}
    105            */ 
    106          
    107          /** @defgroup FLASH_Private_FunctionPrototypes
    108            * @{
    109            */
    110            
    111          /**
    112            * @}
    113            */
    114          
    115          /** @defgroup FLASH_Private_Functions
    116            * @{
    117            */
    118          
    119          /**
    120          @code  
    121           
    122           This driver provides functions to configure and program the Flash memory of all STM32F10x devices,
    123           including the latest STM32F10x_XL density devices. 
    124          
    125           STM32F10x_XL devices feature up to 1 Mbyte with dual bank architecture for read-while-write (RWW) capability:
    126              - bank1: fixed size of 512 Kbytes (256 pages of 2Kbytes each)
    127              - bank2: up to 512 Kbytes (up to 256 pages of 2Kbytes each)
    128           While other STM32F10x devices features only one bank with memory up to 512 Kbytes.
    129          
    130           In version V3.3.0, some functions were updated and new ones were added to support
    131           STM32F10x_XL devices. Thus some functions manages all devices, while other are 
    132           dedicated for XL devices only.
    133           
    134           The table below presents the list of available functions depending on the used STM32F10x devices.  
    135                
    136             ***************************************************
    137             * Legacy functions used for all STM32F10x devices *
    138             ***************************************************
    139             +----------------------------------------------------------------------------------------------------------------------------------+
    140             |       Functions prototypes         |STM32F10x_XL|Other STM32F10x|    Comments                                                    |
    141             |                                    |   devices  |  devices      |                                                                |
    142             |----------------------------------------------------------------------------------------------------------------------------------|
    143             |FLASH_SetLatency                    |    Yes     |      Yes      | No change                                                      |
    144             |----------------------------------------------------------------------------------------------------------------------------------|
    145             |FLASH_HalfCycleAccessCmd            |    Yes     |      Yes      | No change                                                      |
    146             |----------------------------------------------------------------------------------------------------------------------------------|
    147             |FLASH_PrefetchBufferCmd             |    Yes     |      Yes      | No change                                                      |
    148             |----------------------------------------------------------------------------------------------------------------------------------|
    149             |FLASH_Unlock                        |    Yes     |      Yes      | - For STM32F10X_XL devices: unlock Bank1 and Bank2.            |
    150             |                                    |            |               | - For other devices: unlock Bank1 and it is equivalent         |
    151             |                                    |            |               |   to FLASH_UnlockBank1 function.                               |
    152             |----------------------------------------------------------------------------------------------------------------------------------|
    153             |FLASH_Lock                          |    Yes     |      Yes      | - For STM32F10X_XL devices: lock Bank1 and Bank2.              |
    154             |                                    |            |               | - For other devices: lock Bank1 and it is equivalent           |
    155             |                                    |            |               |   to FLASH_LockBank1 function.                                 |
    156             |----------------------------------------------------------------------------------------------------------------------------------|
    157             |FLASH_ErasePage                     |    Yes     |      Yes      | - For STM32F10x_XL devices: erase a page in Bank1 and Bank2    |
    158             |                                    |            |               | - For other devices: erase a page in Bank1                     |
    159             |----------------------------------------------------------------------------------------------------------------------------------|
    160             |FLASH_EraseAllPages                 |    Yes     |      Yes      | - For STM32F10x_XL devices: erase all pages in Bank1 and Bank2 |
    161             |                                    |            |               | - For other devices: erase all pages in Bank1                  |
    162             |----------------------------------------------------------------------------------------------------------------------------------|
    163             |FLASH_EraseOptionBytes              |    Yes     |      Yes      | No change                                                      |
    164             |----------------------------------------------------------------------------------------------------------------------------------|
    165             |FLASH_ProgramWord                   |    Yes     |      Yes      | Updated to program up to 1MByte (depending on the used device) |
    166             |----------------------------------------------------------------------------------------------------------------------------------|
    167             |FLASH_ProgramHalfWord               |    Yes     |      Yes      | Updated to program up to 1MByte (depending on the used device) |
    168             |----------------------------------------------------------------------------------------------------------------------------------|
    169             |FLASH_ProgramOptionByteData         |    Yes     |      Yes      | No change                                                      |
    170             |----------------------------------------------------------------------------------------------------------------------------------|
    171             |FLASH_EnableWriteProtection         |    Yes     |      Yes      | No change                                                      |
    172             |----------------------------------------------------------------------------------------------------------------------------------|
    173             |FLASH_ReadOutProtection             |    Yes     |      Yes      | No change                                                      |
    174             |----------------------------------------------------------------------------------------------------------------------------------|
    175             |FLASH_UserOptionByteConfig          |    Yes     |      Yes      | No change                                                      |
    176             |----------------------------------------------------------------------------------------------------------------------------------|
    177             |FLASH_GetUserOptionByte             |    Yes     |      Yes      | No change                                                      |
    178             |----------------------------------------------------------------------------------------------------------------------------------|
    179             |FLASH_GetWriteProtectionOptionByte  |    Yes     |      Yes      | No change                                                      |
    180             |----------------------------------------------------------------------------------------------------------------------------------|
    181             |FLASH_GetReadOutProtectionStatus    |    Yes     |      Yes      | No change                                                      |
    182             |----------------------------------------------------------------------------------------------------------------------------------|
    183             |FLASH_GetPrefetchBufferStatus       |    Yes     |      Yes      | No change                                                      |
    184             |----------------------------------------------------------------------------------------------------------------------------------|
    185             |FLASH_ITConfig                      |    Yes     |      Yes      | - For STM32F10x_XL devices: enable Bank1 and Bank2's interrupts|
    186             |                                    |            |               | - For other devices: enable Bank1's interrupts                 |
    187             |----------------------------------------------------------------------------------------------------------------------------------|
    188             |FLASH_GetFlagStatus                 |    Yes     |      Yes      | - For STM32F10x_XL devices: return Bank1 and Bank2's flag status|
    189             |                                    |            |               | - For other devices: return Bank1's flag status                |
    190             |----------------------------------------------------------------------------------------------------------------------------------|
    191             |FLASH_ClearFlag                     |    Yes     |      Yes      | - For STM32F10x_XL devices: clear Bank1 and Bank2's flag       |
    192             |                                    |            |               | - For other devices: clear Bank1's flag                        |
    193             |----------------------------------------------------------------------------------------------------------------------------------|
    194             |FLASH_GetStatus                     |    Yes     |      Yes      | - Return the status of Bank1 (for all devices)                 |
    195             |                                    |            |               |   equivalent to FLASH_GetBank1Status function                  |
    196             |----------------------------------------------------------------------------------------------------------------------------------|
    197             |FLASH_WaitForLastOperation          |    Yes     |      Yes      | - Wait for Bank1 last operation (for all devices)              |
    198             |                                    |            |               |   equivalent to: FLASH_WaitForLastBank1Operation function      |
    199             +----------------------------------------------------------------------------------------------------------------------------------+
    200          
    201             ************************************************************************************************************************
    202             * New functions used for all STM32F10x devices to manage Bank1:                                                        *
    203             *   - These functions are mainly useful for STM32F10x_XL density devices, to have separate control for Bank1 and bank2 *
    204             *   - For other devices, these functions are optional (covered by functions listed above)                              *
    205             ************************************************************************************************************************
    206             +----------------------------------------------------------------------------------------------------------------------------------+
    207             |       Functions prototypes         |STM32F10x_XL|Other STM32F10x|    Comments                                                    |
    208             |                                    |   devices  |  devices      |                                                                |
    209             |----------------------------------------------------------------------------------------------------------------------------------|
    210             | FLASH_UnlockBank1                  |    Yes     |      Yes      | - Unlock Bank1                                                 |
    211             |----------------------------------------------------------------------------------------------------------------------------------|
    212             |FLASH_LockBank1                     |    Yes     |      Yes      | - Lock Bank1                                                   |
    213             |----------------------------------------------------------------------------------------------------------------------------------|
    214             | FLASH_EraseAllBank1Pages           |    Yes     |      Yes      | - Erase all pages in Bank1                                     |
    215             |----------------------------------------------------------------------------------------------------------------------------------|
    216             | FLASH_GetBank1Status               |    Yes     |      Yes      | - Return the status of Bank1                                   |
    217             |----------------------------------------------------------------------------------------------------------------------------------|
    218             | FLASH_WaitForLastBank1Operation    |    Yes     |      Yes      | - Wait for Bank1 last operation                                |
    219             +----------------------------------------------------------------------------------------------------------------------------------+
    220          
    221             *****************************************************************************
    222             * New Functions used only with STM32F10x_XL density devices to manage Bank2 *
    223             *****************************************************************************
    224             +----------------------------------------------------------------------------------------------------------------------------------+
    225             |       Functions prototypes         |STM32F10x_XL|Other STM32F10x|    Comments                                                    |
    226             |                                    |   devices  |  devices      |                                                                |
    227             |----------------------------------------------------------------------------------------------------------------------------------|
    228             | FLASH_UnlockBank2                  |    Yes     |      No       | - Unlock Bank2                                                 |
    229             |----------------------------------------------------------------------------------------------------------------------------------|
    230             |FLASH_LockBank2                     |    Yes     |      No       | - Lock Bank2                                                   |
    231             |----------------------------------------------------------------------------------------------------------------------------------|
    232             | FLASH_EraseAllBank2Pages           |    Yes     |      No       | - Erase all pages in Bank2                                     |
    233             |----------------------------------------------------------------------------------------------------------------------------------|
    234             | FLASH_GetBank2Status               |    Yes     |      No       | - Return the status of Bank2                                   |
    235             |----------------------------------------------------------------------------------------------------------------------------------|
    236             | FLASH_WaitForLastBank2Operation    |    Yes     |      No       | - Wait for Bank2 last operation                                |
    237             |----------------------------------------------------------------------------------------------------------------------------------|
    238             | FLASH_BootConfig                   |    Yes     |      No       | - Configure to boot from Bank1 or Bank2                        |
    239             +----------------------------------------------------------------------------------------------------------------------------------+
    240          @endcode
    241          */
    242          
    243          
    244          /**
    245            * @brief  Sets the code latency value.
    246            * @note   This function can be used for all STM32F10x devices.
    247            * @param  FLASH_Latency: specifies the FLASH Latency value.
    248            *   This parameter can be one of the following values:
    249            *     @arg FLASH_Latency_0: FLASH Zero Latency cycle
    250            *     @arg FLASH_Latency_1: FLASH One Latency cycle
    251            *     @arg FLASH_Latency_2: FLASH Two Latency cycles
    252            * @retval None
    253            */

   \                                 In section .text, align 2, keep-with-next
    254          void FLASH_SetLatency(uint32_t FLASH_Latency)
    255          {
    256            uint32_t tmpreg = 0;
    257            
    258            /* Check the parameters */
    259            assert_param(IS_FLASH_LATENCY(FLASH_Latency));
    260            
    261            /* Read the ACR register */
    262            tmpreg = FLASH->ACR;  
   \                     FLASH_SetLatency: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable22
   \        0x4   0x680A             LDR      R2,[R1, #+0]
    263            
    264            /* Sets the Latency value */
    265            tmpreg &= ACR_LATENCY_Mask;
    266            tmpreg |= FLASH_Latency;
    267            
    268            /* Write the ACR register */
    269            FLASH->ACR = tmpreg;
   \        0x6   0xF002 0x0238      AND      R2,R2,#0x38
   \        0xA   0x4310             ORRS     R0,R0,R2
   \        0xC   0x6008             STR      R0,[R1, #+0]
    270          }
   \        0xE   0x4770             BX       LR
    271          
    272          /**
    273            * @brief  Enables or disables the Half cycle flash access.
    274            * @note   This function can be used for all STM32F10x devices.
    275            * @param  FLASH_HalfCycleAccess: specifies the FLASH Half cycle Access mode.
    276            *   This parameter can be one of the following values:
    277            *     @arg FLASH_HalfCycleAccess_Enable: FLASH Half Cycle Enable
    278            *     @arg FLASH_HalfCycleAccess_Disable: FLASH Half Cycle Disable
    279            * @retval None
    280            */

   \                                 In section .text, align 2, keep-with-next
    281          void FLASH_HalfCycleAccessCmd(uint32_t FLASH_HalfCycleAccess)
    282          {
    283            /* Check the parameters */
    284            assert_param(IS_FLASH_HALFCYCLEACCESS_STATE(FLASH_HalfCycleAccess));
    285            
    286            /* Enable or disable the Half cycle access */
    287            FLASH->ACR &= ACR_HLFCYA_Mask;
   \                     FLASH_HalfCycleAccessCmd: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable22
   \        0x4   0x680A             LDR      R2,[R1, #+0]
   \        0x6   0xF022 0x0208      BIC      R2,R2,#0x8
   \        0xA   0x....             B.N      ?Subroutine2
    288            FLASH->ACR |= FLASH_HalfCycleAccess;
    289          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0x600A             STR      R2,[R1, #+0]
   \        0x2   0x680B             LDR      R3,[R1, #+0]
   \        0x4   0x4318             ORRS     R0,R0,R3
   \        0x6   0x6008             STR      R0,[R1, #+0]
   \        0x8   0x4770             BX       LR
    290          
    291          /**
    292            * @brief  Enables or disables the Prefetch Buffer.
    293            * @note   This function can be used for all STM32F10x devices.
    294            * @param  FLASH_PrefetchBuffer: specifies the Prefetch buffer status.
    295            *   This parameter can be one of the following values:
    296            *     @arg FLASH_PrefetchBuffer_Enable: FLASH Prefetch Buffer Enable
    297            *     @arg FLASH_PrefetchBuffer_Disable: FLASH Prefetch Buffer Disable
    298            * @retval None
    299            */

   \                                 In section .text, align 2, keep-with-next
    300          void FLASH_PrefetchBufferCmd(uint32_t FLASH_PrefetchBuffer)
    301          {
    302            /* Check the parameters */
    303            assert_param(IS_FLASH_PREFETCHBUFFER_STATE(FLASH_PrefetchBuffer));
    304            
    305            /* Enable or disable the Prefetch Buffer */
    306            FLASH->ACR &= ACR_PRFTBE_Mask;
   \                     FLASH_PrefetchBufferCmd: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable22
   \        0x4   0x680A             LDR      R2,[R1, #+0]
   \        0x6   0xF022 0x0210      BIC      R2,R2,#0x10
   \        0xA                      REQUIRE ?Subroutine2
   \        0xA                      ;; // Fall through to label ?Subroutine2
    307            FLASH->ACR |= FLASH_PrefetchBuffer;
    308          }
    309          
    310          /**
    311            * @brief  Unlocks the FLASH Program Erase Controller.
    312            * @note   This function can be used for all STM32F10x devices.
    313            *         - For STM32F10X_XL devices this function unlocks Bank1 and Bank2.
    314            *         - For all other devices it unlocks Bank1 and it is equivalent 
    315            *           to FLASH_UnlockBank1 function.. 
    316            * @param  None
    317            * @retval None
    318            */

   \                                 In section .text, align 2, keep-with-next
    319          void FLASH_Unlock(void)
    320          {
    321            /* Authorize the FPEC of Bank1 Access */
    322            FLASH->KEYR = FLASH_KEY1;
   \                     FLASH_Unlock: (+1)
   \        0x0   0x....             B.N      ?Subroutine0
    323            FLASH->KEYR = FLASH_KEY2;
    324          
    325          #ifdef STM32F10X_XL
    326            /* Authorize the FPEC of Bank2 Access */
    327            FLASH->KEYR2 = FLASH_KEY1;
    328            FLASH->KEYR2 = FLASH_KEY2;
    329          #endif /* STM32F10X_XL */
    330          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable22_1
   \        0x4   0x.... 0x....      LDR.W    R1,??DataTable22_2
   \        0x8   0x.... 0x....      LDR.W    R2,??DataTable22_3
   \        0xC   0x6001             STR      R1,[R0, #+0]
   \        0xE   0x6002             STR      R2,[R0, #+0]
   \       0x10   0x4770             BX       LR
    331          /**
    332            * @brief  Unlocks the FLASH Bank1 Program Erase Controller.
    333            * @note   This function can be used for all STM32F10x devices.
    334            *         - For STM32F10X_XL devices this function unlocks Bank1.
    335            *         - For all other devices it unlocks Bank1 and it is 
    336            *           equivalent to FLASH_Unlock function.
    337            * @param  None
    338            * @retval None
    339            */

   \                                 In section .text, align 4, keep-with-next
    340          void FLASH_UnlockBank1(void)
    341          {
    342            /* Authorize the FPEC of Bank1 Access */
    343            FLASH->KEYR = FLASH_KEY1;
   \                     FLASH_UnlockBank1: (+1)
   \        0x0   0xBF00             Nop
   \        0x2                      REQUIRE ?Subroutine0
   \        0x2                      ;; // Fall through to label ?Subroutine0
    344            FLASH->KEYR = FLASH_KEY2;
    345          }
    346          
    347          #ifdef STM32F10X_XL
    348          /**
    349            * @brief  Unlocks the FLASH Bank2 Program Erase Controller.
    350            * @note   This function can be used only for STM32F10X_XL density devices.
    351            * @param  None
    352            * @retval None
    353            */
    354          void FLASH_UnlockBank2(void)
    355          {
    356            /* Authorize the FPEC of Bank2 Access */
    357            FLASH->KEYR2 = FLASH_KEY1;
    358            FLASH->KEYR2 = FLASH_KEY2;
    359          
    360          }
    361          #endif /* STM32F10X_XL */
    362          
    363          /**
    364            * @brief  Locks the FLASH Program Erase Controller.
    365            * @note   This function can be used for all STM32F10x devices.
    366            *         - For STM32F10X_XL devices this function Locks Bank1 and Bank2.
    367            *         - For all other devices it Locks Bank1 and it is equivalent 
    368            *           to FLASH_LockBank1 function.
    369            * @param  None
    370            * @retval None
    371            */

   \                                 In section .text, align 2, keep-with-next
    372          void FLASH_Lock(void)
    373          {
    374            /* Set the Lock Bit to lock the FPEC and the CR of  Bank1 */
    375            FLASH->CR |= CR_LOCK_Set;
   \                     FLASH_Lock: (+1)
   \        0x0   0x....             B.N      ?Subroutine1
    376          
    377          #ifdef STM32F10X_XL
    378            /* Set the Lock Bit to lock the FPEC and the CR of  Bank2 */
    379            FLASH->CR2 |= CR_LOCK_Set;
    380          #endif /* STM32F10X_XL */
    381          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable22_4
   \        0x4   0x6801             LDR      R1,[R0, #+0]
   \        0x6   0xF041 0x0180      ORR      R1,R1,#0x80
   \        0xA   0x6001             STR      R1,[R0, #+0]
   \        0xC   0x4770             BX       LR
    382          
    383          /**
    384            * @brief  Locks the FLASH Bank1 Program Erase Controller.
    385            * @note   this function can be used for all STM32F10x devices.
    386            *         - For STM32F10X_XL devices this function Locks Bank1.
    387            *         - For all other devices it Locks Bank1 and it is equivalent 
    388            *           to FLASH_Lock function.
    389            * @param  None
    390            * @retval None
    391            */

   \                                 In section .text, align 4, keep-with-next
    392          void FLASH_LockBank1(void)
    393          {
    394            /* Set the Lock Bit to lock the FPEC and the CR of  Bank1 */
    395            FLASH->CR |= CR_LOCK_Set;
   \                     FLASH_LockBank1: (+1)
   \        0x0   0xBF00             Nop
   \        0x2                      REQUIRE ?Subroutine1
   \        0x2                      ;; // Fall through to label ?Subroutine1
    396          }
    397          
    398          #ifdef STM32F10X_XL
    399          /**
    400            * @brief  Locks the FLASH Bank2 Program Erase Controller.
    401            * @note   This function can be used only for STM32F10X_XL density devices.
    402            * @param  None
    403            * @retval None
    404            */
    405          void FLASH_LockBank2(void)
    406          {
    407            /* Set the Lock Bit to lock the FPEC and the CR of  Bank2 */
    408            FLASH->CR2 |= CR_LOCK_Set;
    409          }
    410          #endif /* STM32F10X_XL */
    411          
    412          /**
    413            * @brief  Erases a specified FLASH page.
    414            * @note   This function can be used for all STM32F10x devices.
    415            * @param  Page_Address: The page address to be erased.
    416            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PG,
    417            *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
    418            */

   \                                 In section .text, align 2, keep-with-next
    419          FLASH_Status FLASH_ErasePage(uint32_t Page_Address)
    420          {
   \                     FLASH_ErasePage: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x.... 0x....      BL       ?Subroutine5
    421            FLASH_Status status = FLASH_COMPLETE;
    422            /* Check the parameters */
    423            assert_param(IS_FLASH_ADDRESS(Page_Address));
    424          
    425          #ifdef STM32F10X_XL
    426            if(Page_Address < FLASH_BANK1_END_ADDRESS)  
    427            {
    428              /* Wait for last operation to be completed */
    429              status = FLASH_WaitForLastBank1Operation(EraseTimeout);
    430              if(status == FLASH_COMPLETE)
    431              { 
    432                /* if the previous operation is completed, proceed to erase the page */
    433                FLASH->CR|= CR_PER_Set;
    434                FLASH->AR = Page_Address; 
    435                FLASH->CR|= CR_STRT_Set;
    436              
    437                /* Wait for last operation to be completed */
    438                status = FLASH_WaitForLastBank1Operation(EraseTimeout);
    439          
    440                /* Disable the PER Bit */
    441                FLASH->CR &= CR_PER_Reset;
    442              }
    443            }
    444            else
    445            {
    446              /* Wait for last operation to be completed */
    447              status = FLASH_WaitForLastBank2Operation(EraseTimeout);
    448              if(status == FLASH_COMPLETE)
    449              { 
    450                /* if the previous operation is completed, proceed to erase the page */
    451                FLASH->CR2|= CR_PER_Set;
    452                FLASH->AR2 = Page_Address; 
    453                FLASH->CR2|= CR_STRT_Set;
    454              
    455                /* Wait for last operation to be completed */
    456                status = FLASH_WaitForLastBank2Operation(EraseTimeout);
    457                
    458                /* Disable the PER Bit */
    459                FLASH->CR2 &= CR_PER_Reset;
    460              }
    461            }
    462          #else
    463            /* Wait for last operation to be completed */
    464            status = FLASH_WaitForLastOperation(EraseTimeout);
    465            
    466            if(status == FLASH_COMPLETE)
   \                     ??CrossCallReturnLabel_6: (+1)
   \        0x6   0x2804             CMP      R0,#+4
   \        0x8   0xD113             BNE.N    ??FLASH_ErasePage_0
    467            { 
    468              /* if the previous operation is completed, proceed to erase the page */
    469              FLASH->CR|= CR_PER_Set;
   \        0xA   0x.... 0x....      LDR.W    R5,??DataTable22_4
   \        0xE   0x6828             LDR      R0,[R5, #+0]
   \       0x10   0xF040 0x0002      ORR      R0,R0,#0x2
   \       0x14   0x6028             STR      R0,[R5, #+0]
    470              FLASH->AR = Page_Address; 
   \       0x16   0x606C             STR      R4,[R5, #+4]
    471              FLASH->CR|= CR_STRT_Set;
    472              
    473              /* Wait for last operation to be completed */
    474              status = FLASH_WaitForLastOperation(EraseTimeout);
   \       0x18   0xF44F 0x2030      MOV      R0,#+720896
   \       0x1C   0x6829             LDR      R1,[R5, #+0]
   \       0x1E   0xF041 0x0140      ORR      R1,R1,#0x40
   \       0x22   0x6029             STR      R1,[R5, #+0]
   \       0x24   0x.... 0x....      BL       FLASH_WaitForLastOperation
    475              
    476              /* Disable the PER Bit */
    477              FLASH->CR &= CR_PER_Reset;
   \       0x28   0x682A             LDR      R2,[R5, #+0]
   \       0x2A   0xF641 0x71FD      MOVW     R1,#+8189
   \       0x2E   0x400A             ANDS     R2,R1,R2
   \       0x30   0x602A             STR      R2,[R5, #+0]
    478            }
    479          #endif /* STM32F10X_XL */
    480          
    481            /* Return the Erase Status */
    482            return status;
   \                     ??FLASH_ErasePage_0: (+1)
   \       0x32   0xBD32             POP      {R1,R4,R5,PC}
    483          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \        0x0   0x4604             MOV      R4,R0
   \                     ??Subroutine5_0: (+1)
   \        0x2   0xF44F 0x2030      MOV      R0,#+720896
   \        0x6   0x....             B.N      FLASH_WaitForLastOperation
    484          
    485          /**
    486            * @brief  Erases all FLASH pages.
    487            * @note   This function can be used for all STM32F10x devices.
    488            * @param  None
    489            * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
    490            *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
    491            */

   \                                 In section .text, align 2, keep-with-next
    492          FLASH_Status FLASH_EraseAllPages(void)
    493          {
   \                     FLASH_EraseAllPages: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    494            FLASH_Status status = FLASH_COMPLETE;
    495          
    496          #ifdef STM32F10X_XL
    497            /* Wait for last operation to be completed */
    498            status = FLASH_WaitForLastBank1Operation(EraseTimeout);
    499            
    500            if(status == FLASH_COMPLETE)
    501            {
    502              /* if the previous operation is completed, proceed to erase all pages */
    503               FLASH->CR |= CR_MER_Set;
    504               FLASH->CR |= CR_STRT_Set;
    505              
    506              /* Wait for last operation to be completed */
    507              status = FLASH_WaitForLastBank1Operation(EraseTimeout);
    508              
    509              /* Disable the MER Bit */
    510              FLASH->CR &= CR_MER_Reset;
    511            }    
    512            if(status == FLASH_COMPLETE)
    513            {
    514              /* if the previous operation is completed, proceed to erase all pages */
    515               FLASH->CR2 |= CR_MER_Set;
    516               FLASH->CR2 |= CR_STRT_Set;
    517              
    518              /* Wait for last operation to be completed */
    519              status = FLASH_WaitForLastBank2Operation(EraseTimeout);
    520              
    521              /* Disable the MER Bit */
    522              FLASH->CR2 &= CR_MER_Reset;
    523            }
    524          #else
    525            /* Wait for last operation to be completed */
    526            status = FLASH_WaitForLastOperation(EraseTimeout);
   \        0x2   0x.... 0x....      BL       ??Subroutine5_0
    527            if(status == FLASH_COMPLETE)
   \                     ??CrossCallReturnLabel_4: (+1)
   \        0x6   0x2804             CMP      R0,#+4
   \        0x8   0xD105             BNE.N    ??CrossCallReturnLabel_14
    528            {
    529              /* if the previous operation is completed, proceed to erase all pages */
    530               FLASH->CR |= CR_MER_Set;
   \        0xA   0x.... 0x....      BL       ?Subroutine6
    531               FLASH->CR |= CR_STRT_Set;
    532              
    533              /* Wait for last operation to be completed */
    534              status = FLASH_WaitForLastOperation(EraseTimeout);
   \                     ??CrossCallReturnLabel_7: (+1)
   \        0xE   0x.... 0x....      BL       FLASH_WaitForLastOperation
    535          
    536              /* Disable the MER Bit */
    537              FLASH->CR &= CR_MER_Reset;
   \       0x12   0x.... 0x....      BL       ?Subroutine10
    538            }
    539          #endif /* STM32F10X_XL */
    540          
    541            /* Return the Erase Status */
    542            return status;
   \                     ??CrossCallReturnLabel_14: (+1)
   \       0x16   0xBD10             POP      {R4,PC}
    543          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine10: (+1)
   \        0x0   0x6822             LDR      R2,[R4, #+0]
   \        0x2   0xF641 0x71FB      MOVW     R1,#+8187
   \        0x6   0x400A             ANDS     R2,R1,R2
   \        0x8   0x6022             STR      R2,[R4, #+0]
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \        0x0   0x....             LDR.N    R4,??DataTable22_4
   \        0x2   0x6820             LDR      R0,[R4, #+0]
   \        0x4   0xF040 0x0004      ORR      R0,R0,#0x4
   \        0x8   0x6020             STR      R0,[R4, #+0]
   \        0xA   0xF44F 0x2030      MOV      R0,#+720896
   \        0xE   0x6821             LDR      R1,[R4, #+0]
   \       0x10   0xF041 0x0140      ORR      R1,R1,#0x40
   \       0x14   0x6021             STR      R1,[R4, #+0]
   \       0x16   0x4770             BX       LR
    544          
    545          /**
    546            * @brief  Erases all Bank1 FLASH pages.
    547            * @note   This function can be used for all STM32F10x devices.
    548            *         - For STM32F10X_XL devices this function erases all Bank1 pages.
    549            *         - For all other devices it erases all Bank1 pages and it is equivalent 
    550            *           to FLASH_EraseAllPages function.
    551            * @param  None
    552            * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
    553            *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
    554            */

   \                                 In section .text, align 2, keep-with-next
    555          FLASH_Status FLASH_EraseAllBank1Pages(void)
    556          {
   \                     FLASH_EraseAllBank1Pages: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    557            FLASH_Status status = FLASH_COMPLETE;
    558            /* Wait for last operation to be completed */
    559            status = FLASH_WaitForLastBank1Operation(EraseTimeout);
   \        0x2   0xF44F 0x2030      MOV      R0,#+720896
   \        0x6   0x.... 0x....      BL       FLASH_WaitForLastBank1Operation
    560            
    561            if(status == FLASH_COMPLETE)
   \        0xA   0x2804             CMP      R0,#+4
   \        0xC   0xD105             BNE.N    ??CrossCallReturnLabel_15
    562            {
    563              /* if the previous operation is completed, proceed to erase all pages */
    564               FLASH->CR |= CR_MER_Set;
   \        0xE   0x.... 0x....      BL       ?Subroutine6
    565               FLASH->CR |= CR_STRT_Set;
    566              
    567              /* Wait for last operation to be completed */
    568              status = FLASH_WaitForLastBank1Operation(EraseTimeout);
   \                     ??CrossCallReturnLabel_8: (+1)
   \       0x12   0x.... 0x....      BL       FLASH_WaitForLastBank1Operation
    569              
    570              /* Disable the MER Bit */
    571              FLASH->CR &= CR_MER_Reset;
   \       0x16   0x.... 0x....      BL       ?Subroutine10
    572            }    
    573            /* Return the Erase Status */
    574            return status;
   \                     ??CrossCallReturnLabel_15: (+1)
   \       0x1A   0xBD10             POP      {R4,PC}
    575          }
    576          
    577          #ifdef STM32F10X_XL
    578          /**
    579            * @brief  Erases all Bank2 FLASH pages.
    580            * @note   This function can be used only for STM32F10x_XL density devices.
    581            * @param  None
    582            * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
    583            *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
    584            */
    585          FLASH_Status FLASH_EraseAllBank2Pages(void)
    586          {
    587            FLASH_Status status = FLASH_COMPLETE;
    588            /* Wait for last operation to be completed */
    589            status = FLASH_WaitForLastBank2Operation(EraseTimeout);
    590            
    591            if(status == FLASH_COMPLETE)
    592            {
    593              /* if the previous operation is completed, proceed to erase all pages */
    594               FLASH->CR2 |= CR_MER_Set;
    595               FLASH->CR2 |= CR_STRT_Set;
    596              
    597              /* Wait for last operation to be completed */
    598              status = FLASH_WaitForLastBank2Operation(EraseTimeout);
    599          
    600              /* Disable the MER Bit */
    601              FLASH->CR2 &= CR_MER_Reset;
    602            }    
    603            /* Return the Erase Status */
    604            return status;
    605          }
    606          #endif /* STM32F10X_XL */
    607          
    608          /**
    609            * @brief  Erases the FLASH option bytes.
    610            * @note   This functions erases all option bytes except the Read protection (RDP). 
    611            * @note   This function can be used for all STM32F10x devices.
    612            * @param  None
    613            * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
    614            *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
    615            */

   \                                 In section .text, align 2, keep-with-next
    616          FLASH_Status FLASH_EraseOptionBytes(void)
    617          {
   \                     FLASH_EraseOptionBytes: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
    618            uint16_t rdptmp = RDP_Key;
    619          
    620            FLASH_Status status = FLASH_COMPLETE;
    621          
    622            /* Get the actual read protection Option Byte value */ 
    623            if(FLASH_GetReadOutProtectionStatus() != RESET)
   \        0x2   0x....             LDR.N    R4,??DataTable22_5
   \        0x4   0x6960             LDR      R0,[R4, #+20]
   \        0x6   0x25A5             MOVS     R5,#+165
   \        0x8   0x0780             LSLS     R0,R0,#+30
   \        0xA   0xBF48             IT       MI
   \        0xC   0x2500             MOVMI    R5,#+0
    624            {
    625              rdptmp = 0x00;  
    626            }
    627          
    628            /* Wait for last operation to be completed */
    629            status = FLASH_WaitForLastOperation(EraseTimeout);
   \        0xE   0x.... 0x....      BL       ??Subroutine5_0
    630            if(status == FLASH_COMPLETE)
   \                     ??CrossCallReturnLabel_3: (+1)
   \       0x12   0x2804             CMP      R0,#+4
   \       0x14   0xD121             BNE.N    ??FLASH_EraseOptionBytes_0
    631            {
    632              /* Authorize the small information block programming */
    633              FLASH->OPTKEYR = FLASH_KEY1;
   \       0x16   0x.... 0x....      BL       ?Subroutine9
    634              FLASH->OPTKEYR = FLASH_KEY2;
    635              
    636              /* if the previous operation is completed, proceed to erase the option bytes */
    637              FLASH->CR |= CR_OPTER_Set;
    638              FLASH->CR |= CR_STRT_Set;
    639              /* Wait for last operation to be completed */
    640              status = FLASH_WaitForLastOperation(EraseTimeout);
   \                     ??CrossCallReturnLabel_12: (+1)
   \       0x1A   0xF641 0x76EF      MOVW     R6,#+8175
   \       0x1E   0x68A2             LDR      R2,[R4, #+8]
   \       0x20   0xF042 0x0220      ORR      R2,R2,#0x20
   \       0x24   0x60A2             STR      R2,[R4, #+8]
   \       0x26   0x68A0             LDR      R0,[R4, #+8]
   \       0x28   0xF040 0x0040      ORR      R0,R0,#0x40
   \       0x2C   0x60A0             STR      R0,[R4, #+8]
   \       0x2E   0x.... 0x....      BL       ??Subroutine5_0
    641              
    642              if(status == FLASH_COMPLETE)
   \                     ??CrossCallReturnLabel_2: (+1)
   \       0x32   0x2804             CMP      R0,#+4
   \       0x34   0xD10C             BNE.N    ??CrossCallReturnLabel_26
    643              {
    644                /* if the erase operation is completed, disable the OPTER Bit */
    645                FLASH->CR &= CR_OPTER_Reset;
   \       0x36   0x68A1             LDR      R1,[R4, #+8]
   \       0x38   0xF641 0x70DF      MOVW     R0,#+8159
   \       0x3C   0x4001             ANDS     R1,R0,R1
   \       0x3E   0x60A1             STR      R1,[R4, #+8]
    646                 
    647                /* Enable the Option Bytes Programming operation */
    648                FLASH->CR |= CR_OPTPG_Set;
    649                /* Restore the last read protection Option Byte value */
    650                OB->RDP = (uint16_t)rdptmp; 
   \       0x40   0x....             LDR.N    R0,??DataTable22_6
   \       0x42   0x68A1             LDR      R1,[R4, #+8]
   \       0x44   0xF041 0x0110      ORR      R1,R1,#0x10
   \       0x48   0x60A1             STR      R1,[R4, #+8]
   \       0x4A   0x8005             STRH     R5,[R0, #+0]
    651                /* Wait for last operation to be completed */
    652                status = FLASH_WaitForLastOperation(ProgramTimeout);
   \       0x4C   0x.... 0x....      BL       ??Subroutine11_0
    653           
    654                if(status != FLASH_TIMEOUT)
    655                {
    656                  /* if the program operation is completed, disable the OPTPG Bit */
    657                  FLASH->CR &= CR_OPTPG_Reset;
    658                }
    659              }
    660              else
    661              {
    662                if (status != FLASH_TIMEOUT)
   \                     ??CrossCallReturnLabel_26: (+1)
   \       0x50   0x2805             CMP      R0,#+5
   \       0x52   0xD002             BEQ.N    ??FLASH_EraseOptionBytes_0
    663                {
    664                  /* Disable the OPTPG Bit */
    665                  FLASH->CR &= CR_OPTPG_Reset;
   \       0x54   0x68A1             LDR      R1,[R4, #+8]
   \       0x56   0x400E             ANDS     R6,R6,R1
   \       0x58   0x60A6             STR      R6,[R4, #+8]
    666                }
    667              }  
    668            }
    669            /* Return the erase status */
    670            return status;
   \                     ??FLASH_EraseOptionBytes_0: (+1)
   \       0x5A   0xBD70             POP      {R4-R6,PC}
    671          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine9: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable22_2
   \        0x2   0x....             LDR.N    R1,??DataTable22_3
   \        0x4   0x6020             STR      R0,[R4, #+0]
   \        0x6   0x6021             STR      R1,[R4, #+0]
   \        0x8   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine11_0: (+1)
   \        0x0   0xF44F 0x5000      MOV      R0,#+8192
   \        0x4   0x....             B.N      FLASH_WaitForLastOperation
    672          
    673          /**
    674            * @brief  Programs a word at a specified address.
    675            * @note   This function can be used for all STM32F10x devices.
    676            * @param  Address: specifies the address to be programmed.
    677            * @param  Data: specifies the data to be programmed.
    678            * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
    679            *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT. 
    680            */

   \                                 In section .text, align 2, keep-with-next
    681          FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
    682          {
   \                     FLASH_ProgramWord: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x460D             MOV      R5,R1
    683            FLASH_Status status = FLASH_COMPLETE;
    684            __IO uint32_t tmp = 0;
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x4604             MOV      R4,R0
   \        0x8   0x9100             STR      R1,[SP, #+0]
    685          
    686            /* Check the parameters */
    687            assert_param(IS_FLASH_ADDRESS(Address));
    688          
    689          #ifdef STM32F10X_XL
    690            if(Address < FLASH_BANK1_END_ADDRESS - 2)
    691            { 
    692              /* Wait for last operation to be completed */
    693              status = FLASH_WaitForLastBank1Operation(ProgramTimeout); 
    694              if(status == FLASH_COMPLETE)
    695              {
    696                /* if the previous operation is completed, proceed to program the new first 
    697                  half word */
    698                FLASH->CR |= CR_PG_Set;
    699            
    700                *(__IO uint16_t*)Address = (uint16_t)Data;
    701                /* Wait for last operation to be completed */
    702                status = FLASH_WaitForLastOperation(ProgramTimeout);
    703           
    704                if(status == FLASH_COMPLETE)
    705                {
    706                  /* if the previous operation is completed, proceed to program the new second 
    707                  half word */
    708                  tmp = Address + 2;
    709          
    710                  *(__IO uint16_t*) tmp = Data >> 16;
    711              
    712                  /* Wait for last operation to be completed */
    713                  status = FLASH_WaitForLastOperation(ProgramTimeout);
    714                  
    715                  /* Disable the PG Bit */
    716                  FLASH->CR &= CR_PG_Reset;
    717                }
    718                else
    719                {
    720                  /* Disable the PG Bit */
    721                  FLASH->CR &= CR_PG_Reset;
    722                 }
    723              }
    724            }
    725            else if(Address == (FLASH_BANK1_END_ADDRESS - 1))
    726            {
    727              /* Wait for last operation to be completed */
    728              status = FLASH_WaitForLastBank1Operation(ProgramTimeout);
    729          
    730              if(status == FLASH_COMPLETE)
    731              {
    732                /* if the previous operation is completed, proceed to program the new first 
    733                  half word */
    734                FLASH->CR |= CR_PG_Set;
    735            
    736                *(__IO uint16_t*)Address = (uint16_t)Data;
    737          
    738                /* Wait for last operation to be completed */
    739                status = FLASH_WaitForLastBank1Operation(ProgramTimeout);
    740                
    741          	  /* Disable the PG Bit */
    742                FLASH->CR &= CR_PG_Reset;
    743              }
    744              else
    745              {
    746                /* Disable the PG Bit */
    747                FLASH->CR &= CR_PG_Reset;
    748              }
    749          
    750              /* Wait for last operation to be completed */
    751              status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
    752          
    753              if(status == FLASH_COMPLETE)
    754              {
    755                /* if the previous operation is completed, proceed to program the new second 
    756                half word */
    757                FLASH->CR2 |= CR_PG_Set;
    758                tmp = Address + 2;
    759          
    760                *(__IO uint16_t*) tmp = Data >> 16;
    761              
    762                /* Wait for last operation to be completed */
    763                status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
    764                  
    765                /* Disable the PG Bit */
    766                FLASH->CR2 &= CR_PG_Reset;
    767              }
    768              else
    769              {
    770                /* Disable the PG Bit */
    771                FLASH->CR2 &= CR_PG_Reset;
    772              }
    773            }
    774            else
    775            {
    776              /* Wait for last operation to be completed */
    777              status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
    778          
    779              if(status == FLASH_COMPLETE)
    780              {
    781                /* if the previous operation is completed, proceed to program the new first 
    782                  half word */
    783                FLASH->CR2 |= CR_PG_Set;
    784            
    785                *(__IO uint16_t*)Address = (uint16_t)Data;
    786                /* Wait for last operation to be completed */
    787                status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
    788           
    789                if(status == FLASH_COMPLETE)
    790                {
    791                  /* if the previous operation is completed, proceed to program the new second 
    792                  half word */
    793                  tmp = Address + 2;
    794          
    795                  *(__IO uint16_t*) tmp = Data >> 16;
    796              
    797                  /* Wait for last operation to be completed */
    798                  status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
    799                  
    800                  /* Disable the PG Bit */
    801                  FLASH->CR2 &= CR_PG_Reset;
    802                }
    803                else
    804                {
    805                  /* Disable the PG Bit */
    806                  FLASH->CR2 &= CR_PG_Reset;
    807                }
    808              }
    809            }
    810          #else
    811            /* Wait for last operation to be completed */
    812            status = FLASH_WaitForLastOperation(ProgramTimeout);
   \        0xA   0x.... 0x....      BL       ??Subroutine11_0
    813            
    814            if(status == FLASH_COMPLETE)
   \                     ??CrossCallReturnLabel_25: (+1)
   \        0xE   0x2804             CMP      R0,#+4
   \       0x10   0xD112             BNE.N    ??FLASH_ProgramWord_0
    815            {
    816              /* if the previous operation is completed, proceed to program the new first 
    817              half word */
    818              FLASH->CR |= CR_PG_Set;
   \       0x12   0x.... 0x....      BL       ?Subroutine7
    819            
    820              *(__IO uint16_t*)Address = (uint16_t)Data;
    821              /* Wait for last operation to be completed */
    822              status = FLASH_WaitForLastOperation(ProgramTimeout);
    823           
    824              if(status == FLASH_COMPLETE)
   \                     ??CrossCallReturnLabel_28: (+1)
   \       0x16   0x2804             CMP      R0,#+4
   \       0x18   0xF641 0x77FE      MOVW     R7,#+8190
   \       0x1C   0xD109             BNE.N    ??FLASH_ProgramWord_1
    825              {
    826                /* if the previous operation is completed, proceed to program the new second 
    827                half word */
    828                tmp = Address + 2;
   \       0x1E   0x1CA4             ADDS     R4,R4,#+2
   \       0x20   0x9400             STR      R4,[SP, #+0]
    829          
    830                *(__IO uint16_t*) tmp = Data >> 16;
   \       0x22   0x0C2D             LSRS     R5,R5,#+16
   \       0x24   0x9800             LDR      R0,[SP, #+0]
   \       0x26   0x8005             STRH     R5,[R0, #+0]
    831              
    832                /* Wait for last operation to be completed */
    833                status = FLASH_WaitForLastOperation(ProgramTimeout);
   \       0x28   0x.... 0x....      BL       ??Subroutine11_0
    834                  
    835                /* Disable the PG Bit */
    836                FLASH->CR &= CR_PG_Reset;
   \                     ??CrossCallReturnLabel_24: (+1)
   \       0x2C   0x6831             LDR      R1,[R6, #+0]
   \       0x2E   0x400F             ANDS     R7,R7,R1
   \       0x30   0xE001             B.N      ??FLASH_ProgramWord_2
    837              }
    838              else
    839              {
    840                /* Disable the PG Bit */
    841                FLASH->CR &= CR_PG_Reset;
   \                     ??FLASH_ProgramWord_1: (+1)
   \       0x32   0x6832             LDR      R2,[R6, #+0]
   \       0x34   0x4017             ANDS     R7,R7,R2
   \                     ??FLASH_ProgramWord_2: (+1)
   \       0x36   0x6037             STR      R7,[R6, #+0]
    842              }
    843            }         
    844          #endif /* STM32F10X_XL */
    845             
    846            /* Return the Program Status */
    847            return status;
   \                     ??FLASH_ProgramWord_0: (+1)
   \       0x38   0xBDF2             POP      {R1,R4-R7,PC}
    848          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \        0x0   0x....             LDR.N    R6,??DataTable22_4
   \        0x2   0x6830             LDR      R0,[R6, #+0]
   \        0x4   0xF040 0x0001      ORR      R0,R0,#0x1
   \        0x8   0x6030             STR      R0,[R6, #+0]
   \        0xA   0x8025             STRH     R5,[R4, #+0]
   \        0xC                      REQUIRE ??Subroutine11_0
   \        0xC                      ;; // Fall through to label ??Subroutine11_0
    849          
    850          /**
    851            * @brief  Programs a half word at a specified address.
    852            * @note   This function can be used for all STM32F10x devices.
    853            * @param  Address: specifies the address to be programmed.
    854            * @param  Data: specifies the data to be programmed.
    855            * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
    856            *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT. 
    857            */

   \                                 In section .text, align 2, keep-with-next
    858          FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data)
    859          {
   \                     FLASH_ProgramHalfWord: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
    860            FLASH_Status status = FLASH_COMPLETE;
    861            /* Check the parameters */
    862            assert_param(IS_FLASH_ADDRESS(Address));
    863          
    864          #ifdef STM32F10X_XL
    865            /* Wait for last operation to be completed */
    866            status = FLASH_WaitForLastOperation(ProgramTimeout);
    867            
    868            if(Address < FLASH_BANK1_END_ADDRESS)
    869            {
    870              if(status == FLASH_COMPLETE)
    871              {
    872                /* if the previous operation is completed, proceed to program the new data */
    873                FLASH->CR |= CR_PG_Set;
    874            
    875                *(__IO uint16_t*)Address = Data;
    876                /* Wait for last operation to be completed */
    877                status = FLASH_WaitForLastBank1Operation(ProgramTimeout);
    878          
    879                /* Disable the PG Bit */
    880                FLASH->CR &= CR_PG_Reset;
    881              }
    882            }
    883            else
    884            {
    885              if(status == FLASH_COMPLETE)
    886              {
    887                /* if the previous operation is completed, proceed to program the new data */
    888                FLASH->CR2 |= CR_PG_Set;
    889            
    890                *(__IO uint16_t*)Address = Data;
    891                /* Wait for last operation to be completed */
    892                status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
    893          
    894                /* Disable the PG Bit */
    895                FLASH->CR2 &= CR_PG_Reset;
    896              }
    897            }
    898          #else
    899            /* Wait for last operation to be completed */
    900            status = FLASH_WaitForLastOperation(ProgramTimeout);
   \        0x6   0x.... 0x....      BL       ??Subroutine11_0
    901            
    902            if(status == FLASH_COMPLETE)
   \                     ??CrossCallReturnLabel_23: (+1)
   \        0xA   0x2804             CMP      R0,#+4
   \        0xC   0xD106             BNE.N    ??FLASH_ProgramHalfWord_0
    903            {
    904              /* if the previous operation is completed, proceed to program the new data */
    905              FLASH->CR |= CR_PG_Set;
   \        0xE   0x.... 0x....      BL       ?Subroutine7
    906            
    907              *(__IO uint16_t*)Address = Data;
    908              /* Wait for last operation to be completed */
    909              status = FLASH_WaitForLastOperation(ProgramTimeout);
    910              
    911              /* Disable the PG Bit */
    912              FLASH->CR &= CR_PG_Reset;
   \                     ??CrossCallReturnLabel_27: (+1)
   \       0x12   0x6832             LDR      R2,[R6, #+0]
   \       0x14   0xF641 0x71FE      MOVW     R1,#+8190
   \       0x18   0x400A             ANDS     R2,R1,R2
   \       0x1A   0x6032             STR      R2,[R6, #+0]
    913            } 
    914          #endif  /* STM32F10X_XL */
    915            
    916            /* Return the Program Status */
    917            return status;
   \                     ??FLASH_ProgramHalfWord_0: (+1)
   \       0x1C   0xBD70             POP      {R4-R6,PC}
    918          }
    919          
    920          /**
    921            * @brief  Programs a half word at a specified Option Byte Data address.
    922            * @note   This function can be used for all STM32F10x devices.
    923            * @param  Address: specifies the address to be programmed.
    924            *   This parameter can be 0x1FFFF804 or 0x1FFFF806. 
    925            * @param  Data: specifies the data to be programmed.
    926            * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
    927            *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT. 
    928            */

   \                                 In section .text, align 2, keep-with-next
    929          FLASH_Status FLASH_ProgramOptionByteData(uint32_t Address, uint8_t Data)
    930          {
   \                     FLASH_ProgramOptionByteData: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460E             MOV      R6,R1
    931            FLASH_Status status = FLASH_COMPLETE;
    932            /* Check the parameters */
    933            assert_param(IS_OB_DATA_ADDRESS(Address));
    934            status = FLASH_WaitForLastOperation(ProgramTimeout);
   \        0x6   0x.... 0x....      BL       ??Subroutine11_0
    935          
    936            if(status == FLASH_COMPLETE)
   \                     ??CrossCallReturnLabel_22: (+1)
   \        0xA   0x2804             CMP      R0,#+4
   \        0xC   0xD10F             BNE.N    ??CrossCallReturnLabel_9
    937            {
    938              /* Authorize the small information block programming */
    939              FLASH->OPTKEYR = FLASH_KEY1;
   \        0xE   0x....             LDR.N    R4,??DataTable22_5
   \       0x10   0x.... 0x....      BL       ?Subroutine9
    940              FLASH->OPTKEYR = FLASH_KEY2;
    941              /* Enables the Option Bytes Programming operation */
    942              FLASH->CR |= CR_OPTPG_Set; 
    943              *(__IO uint16_t*)Address = Data;
    944              
    945              /* Wait for last operation to be completed */
    946              status = FLASH_WaitForLastOperation(ProgramTimeout);
   \                     ??CrossCallReturnLabel_13: (+1)
   \       0x14   0xF44F 0x5000      MOV      R0,#+8192
   \       0x18   0x68A2             LDR      R2,[R4, #+8]
   \       0x1A   0xF042 0x0210      ORR      R2,R2,#0x10
   \       0x1E   0x60A2             STR      R2,[R4, #+8]
   \       0x20   0x802E             STRH     R6,[R5, #+0]
   \       0x22   0x.... 0x....      BL       FLASH_WaitForLastOperation
    947              if(status != FLASH_TIMEOUT)
   \       0x26   0x2805             CMP      R0,#+5
   \       0x28   0xD001             BEQ.N    ??CrossCallReturnLabel_9
    948              {
    949                /* if the program operation is completed, disable the OPTPG Bit */
    950                FLASH->CR &= CR_OPTPG_Reset;
   \       0x2A   0x.... 0x....      BL       ?Subroutine8
    951              }
    952            }
    953            /* Return the Option Byte Data Program Status */
    954            return status;
   \                     ??CrossCallReturnLabel_9: (+1)
   \       0x2E   0xBD70             POP      {R4-R6,PC}
    955          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8: (+1)
   \        0x0   0x68A2             LDR      R2,[R4, #+8]
   \        0x2   0xF641 0x71EF      MOVW     R1,#+8175
   \        0x6   0x400A             ANDS     R2,R1,R2
   \        0x8   0x60A2             STR      R2,[R4, #+8]
   \        0xA   0x4770             BX       LR
    956          
    957          /**
    958            * @brief  Write protects the desired pages
    959            * @note   This function can be used for all STM32F10x devices.
    960            * @param  FLASH_Pages: specifies the address of the pages to be write protected.
    961            *   This parameter can be:
    962            *     @arg For @b STM32_Low-density_devices: value between FLASH_WRProt_Pages0to3 and FLASH_WRProt_Pages28to31  
    963            *     @arg For @b STM32_Medium-density_devices: value between FLASH_WRProt_Pages0to3
    964            *       and FLASH_WRProt_Pages124to127
    965            *     @arg For @b STM32_High-density_devices: value between FLASH_WRProt_Pages0to1 and
    966            *       FLASH_WRProt_Pages60to61 or FLASH_WRProt_Pages62to255
    967            *     @arg For @b STM32_Connectivity_line_devices: value between FLASH_WRProt_Pages0to1 and
    968            *       FLASH_WRProt_Pages60to61 or FLASH_WRProt_Pages62to127    
    969            *     @arg For @b STM32_XL-density_devices: value between FLASH_WRProt_Pages0to1 and
    970            *       FLASH_WRProt_Pages60to61 or FLASH_WRProt_Pages62to511
    971            *     @arg FLASH_WRProt_AllPages
    972            * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
    973            *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
    974            */

   \                                 In section .text, align 2, keep-with-next
    975          FLASH_Status FLASH_EnableWriteProtection(uint32_t FLASH_Pages)
    976          {
   \                     FLASH_EnableWriteProtection: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
    977            uint16_t WRP0_Data = 0xFFFF, WRP1_Data = 0xFFFF, WRP2_Data = 0xFFFF, WRP3_Data = 0xFFFF;
    978            
    979            FLASH_Status status = FLASH_COMPLETE;
    980            
    981            /* Check the parameters */
    982            assert_param(IS_FLASH_WRPROT_PAGE(FLASH_Pages));
    983            
    984            FLASH_Pages = (uint32_t)(~FLASH_Pages);
   \        0x4   0x43C5             MVNS     R5,R0
    985            WRP0_Data = (uint16_t)(FLASH_Pages & WRP0_Mask);
    986            WRP1_Data = (uint16_t)((FLASH_Pages & WRP1_Mask) >> 8);
    987            WRP2_Data = (uint16_t)((FLASH_Pages & WRP2_Mask) >> 16);
    988            WRP3_Data = (uint16_t)((FLASH_Pages & WRP3_Mask) >> 24);
    989            
    990            /* Wait for last operation to be completed */
    991            status = FLASH_WaitForLastOperation(ProgramTimeout);
   \        0x6   0xF44F 0x5000      MOV      R0,#+8192
   \        0xA   0xF005 0x08FF      AND      R8,R5,#0xFF
   \        0xE   0xF3C5 0x2907      UBFX     R9,R5,#+8,#+8
   \       0x12   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \       0x16   0x0C2F             LSRS     R7,R5,#+16
   \       0x18   0x0E2D             LSRS     R5,R5,#+24
    992            
    993            if(status == FLASH_COMPLETE)
   \       0x1A   0x2804             CMP      R0,#+4
   \       0x1C   0xF007 0x07FF      AND      R7,R7,#0xFF
   \       0x20   0xD12B             BNE.N    ??CrossCallReturnLabel_10
    994            {
    995              /* Authorizes the small information block programming */
    996              FLASH->OPTKEYR = FLASH_KEY1;
   \       0x22   0x....             LDR.N    R4,??DataTable22_5
   \       0x24   0x....             LDR.N    R1,??DataTable22_2
    997              FLASH->OPTKEYR = FLASH_KEY2;
   \       0x26   0x....             LDR.N    R2,??DataTable22_3
    998              FLASH->CR |= CR_OPTPG_Set;
    999              if(WRP0_Data != 0xFF)
   \       0x28   0x....             LDR.N    R6,??DataTable22_7
   \       0x2A   0x6021             STR      R1,[R4, #+0]
   \       0x2C   0x6022             STR      R2,[R4, #+0]
   \       0x2E   0xF1B8 0x0FFF      CMP      R8,#+255
   \       0x32   0x68A3             LDR      R3,[R4, #+8]
   \       0x34   0xF043 0x0310      ORR      R3,R3,#0x10
   \       0x38   0x60A3             STR      R3,[R4, #+8]
   \       0x3A   0xD005             BEQ.N    ??FLASH_EnableWriteProtection_0
   1000              {
   1001                OB->WRP0 = WRP0_Data;
   \       0x3C   0xF8A6 0x8000      STRH     R8,[R6, #+0]
   1002                
   1003                /* Wait for last operation to be completed */
   1004                status = FLASH_WaitForLastOperation(ProgramTimeout);
   \       0x40   0x.... 0x....      BL       ??Subroutine11_0
   1005              }
   1006              if((status == FLASH_COMPLETE) && (WRP1_Data != 0xFF))
   \                     ??CrossCallReturnLabel_21: (+1)
   \       0x44   0x2804             CMP      R0,#+4
   \       0x46   0xD106             BNE.N    ??CrossCallReturnLabel_20
   \                     ??FLASH_EnableWriteProtection_0: (+1)
   \       0x48   0xF1B9 0x0FFF      CMP      R9,#+255
   \       0x4C   0xD005             BEQ.N    ??FLASH_EnableWriteProtection_1
   1007              {
   1008                OB->WRP1 = WRP1_Data;
   \       0x4E   0xF8A6 0x9002      STRH     R9,[R6, #+2]
   1009                
   1010                /* Wait for last operation to be completed */
   1011                status = FLASH_WaitForLastOperation(ProgramTimeout);
   \       0x52   0x.... 0x....      BL       ??Subroutine11_0
   1012              }
   1013              if((status == FLASH_COMPLETE) && (WRP2_Data != 0xFF))
   \                     ??CrossCallReturnLabel_20: (+1)
   \       0x56   0x2804             CMP      R0,#+4
   \       0x58   0xD104             BNE.N    ??CrossCallReturnLabel_19
   \                     ??FLASH_EnableWriteProtection_1: (+1)
   \       0x5A   0x2FFF             CMP      R7,#+255
   \       0x5C   0xD004             BEQ.N    ??FLASH_EnableWriteProtection_2
   1014              {
   1015                OB->WRP2 = WRP2_Data;
   \       0x5E   0x80B7             STRH     R7,[R6, #+4]
   1016                
   1017                /* Wait for last operation to be completed */
   1018                status = FLASH_WaitForLastOperation(ProgramTimeout);
   \       0x60   0x.... 0x....      BL       ??Subroutine11_0
   1019              }
   1020              
   1021              if((status == FLASH_COMPLETE)&& (WRP3_Data != 0xFF))
   \                     ??CrossCallReturnLabel_19: (+1)
   \       0x64   0x2804             CMP      R0,#+4
   \       0x66   0xD104             BNE.N    ??CrossCallReturnLabel_18
   \                     ??FLASH_EnableWriteProtection_2: (+1)
   \       0x68   0x2DFF             CMP      R5,#+255
   \       0x6A   0xD004             BEQ.N    ??FLASH_EnableWriteProtection_3
   1022              {
   1023                OB->WRP3 = WRP3_Data;
   \       0x6C   0x80F5             STRH     R5,[R6, #+6]
   1024               
   1025                /* Wait for last operation to be completed */
   1026                status = FLASH_WaitForLastOperation(ProgramTimeout);
   \       0x6E   0x.... 0x....      BL       ??Subroutine11_0
   1027              }
   1028                    
   1029              if(status != FLASH_TIMEOUT)
   \                     ??CrossCallReturnLabel_18: (+1)
   \       0x72   0x2805             CMP      R0,#+5
   \       0x74   0xD001             BEQ.N    ??CrossCallReturnLabel_10
   1030              {
   1031                /* if the program operation is completed, disable the OPTPG Bit */
   1032                FLASH->CR &= CR_OPTPG_Reset;
   \                     ??FLASH_EnableWriteProtection_3: (+1)
   \       0x76   0x.... 0x....      BL       ?Subroutine8
   1033              }
   1034            } 
   1035            /* Return the write protection operation Status */
   1036            return status;       
   \                     ??CrossCallReturnLabel_10: (+1)
   \       0x7A   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   1037          }
   1038          
   1039          /**
   1040            * @brief  Enables or disables the read out protection.
   1041            * @note   If the user has already programmed the other option bytes before calling 
   1042            *   this function, he must re-program them since this function erases all option bytes.
   1043            * @note   This function can be used for all STM32F10x devices.
   1044            * @param  Newstate: new state of the ReadOut Protection.
   1045            *   This parameter can be: ENABLE or DISABLE.
   1046            * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
   1047            *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
   1048            */

   \                                 In section .text, align 2, keep-with-next
   1049          FLASH_Status FLASH_ReadOutProtection(FunctionalState NewState)
   1050          {
   \                     FLASH_ReadOutProtection: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x.... 0x....      BL       ?Subroutine5
   1051            FLASH_Status status = FLASH_COMPLETE;
   1052            /* Check the parameters */
   1053            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1054            status = FLASH_WaitForLastOperation(EraseTimeout);
   1055            if(status == FLASH_COMPLETE)
   \                     ??CrossCallReturnLabel_5: (+1)
   \        0x6   0x2804             CMP      R0,#+4
   \        0x8   0xD12F             BNE.N    ??FLASH_ReadOutProtection_0
   1056            {
   1057              /* Authorizes the small information block programming */
   1058              FLASH->OPTKEYR = FLASH_KEY1;
   \        0xA   0x....             LDR.N    R5,??DataTable22_5
   \        0xC   0x....             LDR.N    R0,??DataTable22_2
   1059              FLASH->OPTKEYR = FLASH_KEY2;
   \        0xE   0x....             LDR.N    R1,??DataTable22_3
   \       0x10   0x6028             STR      R0,[R5, #+0]
   \       0x12   0x6029             STR      R1,[R5, #+0]
   1060              FLASH->CR |= CR_OPTER_Set;
   \       0x14   0x68AA             LDR      R2,[R5, #+8]
   \       0x16   0xF042 0x0220      ORR      R2,R2,#0x20
   \       0x1A   0x60AA             STR      R2,[R5, #+8]
   1061              FLASH->CR |= CR_STRT_Set;
   \       0x1C   0x68A8             LDR      R0,[R5, #+8]
   \       0x1E   0xF040 0x0040      ORR      R0,R0,#0x40
   \       0x22   0x60A8             STR      R0,[R5, #+8]
   1062              /* Wait for last operation to be completed */
   1063              status = FLASH_WaitForLastOperation(EraseTimeout);
   \       0x24   0x.... 0x....      BL       ??Subroutine5_0
   1064              if(status == FLASH_COMPLETE)
   \                     ??CrossCallReturnLabel_1: (+1)
   \       0x28   0x2804             CMP      R0,#+4
   \       0x2A   0xF641 0x71DF      MOVW     R1,#+8159
   \       0x2E   0xD117             BNE.N    ??FLASH_ReadOutProtection_1
   1065              {
   1066                /* if the erase operation is completed, disable the OPTER Bit */
   1067                FLASH->CR &= CR_OPTER_Reset;
   \       0x30   0x68A8             LDR      R0,[R5, #+8]
   \       0x32   0x4001             ANDS     R1,R1,R0
   \       0x34   0x60A9             STR      R1,[R5, #+8]
   1068                /* Enable the Option Bytes Programming operation */
   1069                FLASH->CR |= CR_OPTPG_Set; 
   1070                if(NewState != DISABLE)
   \       0x36   0x2C00             CMP      R4,#+0
   \       0x38   0x68A9             LDR      R1,[R5, #+8]
   \       0x3A   0x....             LDR.N    R0,??DataTable22_6
   \       0x3C   0xF041 0x0110      ORR      R1,R1,#0x10
   \       0x40   0x60A9             STR      R1,[R5, #+8]
   \       0x42   0xBF19             ITTEE    NE
   \       0x44   0x2100             MOVNE    R1,#+0
   \       0x46   0x8001             STRHNE   R1,[R0, #+0]
   \       0x48   0x22A5             MOVEQ    R2,#+165
   \       0x4A   0x8002             STRHEQ   R2,[R0, #+0]
   1071                {
   1072                  OB->RDP = 0x00;
   1073                }
   1074                else
   1075                {
   1076                  OB->RDP = RDP_Key;  
   1077                }
   1078                /* Wait for last operation to be completed */
   1079                status = FLASH_WaitForLastOperation(EraseTimeout); 
   \       0x4C   0x.... 0x....      BL       ??Subroutine5_0
   1080              
   1081                if(status != FLASH_TIMEOUT)
   \                     ??CrossCallReturnLabel_0: (+1)
   \       0x50   0x2805             CMP      R0,#+5
   \       0x52   0xD00A             BEQ.N    ??FLASH_ReadOutProtection_0
   1082                {
   1083                  /* if the program operation is completed, disable the OPTPG Bit */
   1084                  FLASH->CR &= CR_OPTPG_Reset;
   \       0x54   0x68AA             LDR      R2,[R5, #+8]
   \       0x56   0xF641 0x71EF      MOVW     R1,#+8175
   \       0x5A   0x400A             ANDS     R2,R1,R2
   \       0x5C   0x60AA             STR      R2,[R5, #+8]
   \       0x5E   0xBD32             POP      {R1,R4,R5,PC}
   1085                }
   1086              }
   1087              else 
   1088              {
   1089                if(status != FLASH_TIMEOUT)
   \                     ??FLASH_ReadOutProtection_1: (+1)
   \       0x60   0x2805             CMP      R0,#+5
   \       0x62   0xD002             BEQ.N    ??FLASH_ReadOutProtection_0
   1090                {
   1091                  /* Disable the OPTER Bit */
   1092                  FLASH->CR &= CR_OPTER_Reset;
   \       0x64   0x68AA             LDR      R2,[R5, #+8]
   \       0x66   0x4011             ANDS     R1,R1,R2
   \       0x68   0x60A9             STR      R1,[R5, #+8]
   1093                }
   1094              }
   1095            }
   1096            /* Return the protection operation Status */
   1097            return status;       
   \                     ??FLASH_ReadOutProtection_0: (+1)
   \       0x6A   0xBD32             POP      {R1,R4,R5,PC}
   1098          }
   1099          
   1100          /**
   1101            * @brief  Programs the FLASH User Option Byte: IWDG_SW / RST_STOP / RST_STDBY.
   1102            * @note   This function can be used for all STM32F10x devices.
   1103            * @param  OB_IWDG: Selects the IWDG mode
   1104            *   This parameter can be one of the following values:
   1105            *     @arg OB_IWDG_SW: Software IWDG selected
   1106            *     @arg OB_IWDG_HW: Hardware IWDG selected
   1107            * @param  OB_STOP: Reset event when entering STOP mode.
   1108            *   This parameter can be one of the following values:
   1109            *     @arg OB_STOP_NoRST: No reset generated when entering in STOP
   1110            *     @arg OB_STOP_RST: Reset generated when entering in STOP
   1111            * @param  OB_STDBY: Reset event when entering Standby mode.
   1112            *   This parameter can be one of the following values:
   1113            *     @arg OB_STDBY_NoRST: No reset generated when entering in STANDBY
   1114            *     @arg OB_STDBY_RST: Reset generated when entering in STANDBY
   1115            * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG, 
   1116            *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
   1117            */

   \                                 In section .text, align 2, keep-with-next
   1118          FLASH_Status FLASH_UserOptionByteConfig(uint16_t OB_IWDG, uint16_t OB_STOP, uint16_t OB_STDBY)
   1119          {
   \                     FLASH_UserOptionByteConfig: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x460E             MOV      R6,R1
   1120            FLASH_Status status = FLASH_COMPLETE; 
   1121          
   1122            /* Check the parameters */
   1123            assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
   1124            assert_param(IS_OB_STOP_SOURCE(OB_STOP));
   1125            assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));
   1126          
   1127            /* Authorize the small information block programming */
   1128            FLASH->OPTKEYR = FLASH_KEY1;
   \        0x4   0x....             LDR.N    R4,??DataTable22_5
   \        0x6   0x....             LDR.N    R1,??DataTable22_2
   \        0x8   0x6021             STR      R1,[R4, #+0]
   \        0xA   0x4617             MOV      R7,R2
   1129            FLASH->OPTKEYR = FLASH_KEY2;
   \        0xC   0x....             LDR.N    R2,??DataTable22_3
   \        0xE   0x6022             STR      R2,[R4, #+0]
   \       0x10   0x4605             MOV      R5,R0
   1130            
   1131            /* Wait for last operation to be completed */
   1132            status = FLASH_WaitForLastOperation(ProgramTimeout);
   \       0x12   0x.... 0x....      BL       ??Subroutine11_0
   1133            
   1134            if(status == FLASH_COMPLETE)
   \                     ??CrossCallReturnLabel_17: (+1)
   \       0x16   0x2804             CMP      R0,#+4
   \       0x18   0xD10F             BNE.N    ??CrossCallReturnLabel_11
   1135            {  
   1136              /* Enable the Option Bytes Programming operation */
   1137              FLASH->CR |= CR_OPTPG_Set; 
   \       0x1A   0x68A0             LDR      R0,[R4, #+8]
   \       0x1C   0xF040 0x0010      ORR      R0,R0,#0x10
   \       0x20   0x60A0             STR      R0,[R4, #+8]
   1138                     
   1139              OB->USER = OB_IWDG | (uint16_t)(OB_STOP | (uint16_t)(OB_STDBY | ((uint16_t)0xF8))); 
   \       0x22   0x4335             ORRS     R5,R6,R5
   \       0x24   0x433D             ORRS     R5,R7,R5
   \       0x26   0x....             LDR.N    R0,??DataTable22_8
   \       0x28   0xF045 0x05F8      ORR      R5,R5,#0xF8
   \       0x2C   0x8005             STRH     R5,[R0, #+0]
   1140            
   1141              /* Wait for last operation to be completed */
   1142              status = FLASH_WaitForLastOperation(ProgramTimeout);
   \       0x2E   0x.... 0x....      BL       ??Subroutine11_0
   1143              if(status != FLASH_TIMEOUT)
   \                     ??CrossCallReturnLabel_16: (+1)
   \       0x32   0x2805             CMP      R0,#+5
   \       0x34   0xD001             BEQ.N    ??CrossCallReturnLabel_11
   1144              {
   1145                /* if the program operation is completed, disable the OPTPG Bit */
   1146                FLASH->CR &= CR_OPTPG_Reset;
   \       0x36   0x.... 0x....      BL       ?Subroutine8
   1147              }
   1148            }    
   1149            /* Return the Option Byte program Status */
   1150            return status;
   \                     ??CrossCallReturnLabel_11: (+1)
   \       0x3A   0xBDF2             POP      {R1,R4-R7,PC}
   1151          }
   1152          
   1153          #ifdef STM32F10X_XL
   1154          /**
   1155            * @brief  Configures to boot from Bank1 or Bank2.  
   1156            * @note   This function can be used only for STM32F10x_XL density devices.
   1157            * @param  FLASH_BOOT: select the FLASH Bank to boot from.
   1158            *   This parameter can be one of the following values:
   1159            *     @arg FLASH_BOOT_Bank1: At startup, if boot pins are set in boot from user Flash
   1160            *        position and this parameter is selected the device will boot from Bank1(Default).
   1161            *     @arg FLASH_BOOT_Bank2: At startup, if boot pins are set in boot from user Flash
   1162            *        position and this parameter is selected the device will boot from Bank2 or Bank1,
   1163            *        depending on the activation of the bank. The active banks are checked in
   1164            *        the following order: Bank2, followed by Bank1.
   1165            *        The active bank is recognized by the value programmed at the base address
   1166            *        of the respective bank (corresponding to the initial stack pointer value
   1167            *        in the interrupt vector table).
   1168            *        For more information, please refer to AN2606 from www.st.com.    
   1169            * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG, 
   1170            *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
   1171            */
   1172          FLASH_Status FLASH_BootConfig(uint16_t FLASH_BOOT)
   1173          { 
   1174            FLASH_Status status = FLASH_COMPLETE; 
   1175            assert_param(IS_FLASH_BOOT(FLASH_BOOT));
   1176            /* Authorize the small information block programming */
   1177            FLASH->OPTKEYR = FLASH_KEY1;
   1178            FLASH->OPTKEYR = FLASH_KEY2;
   1179            
   1180            /* Wait for last operation to be completed */
   1181            status = FLASH_WaitForLastOperation(ProgramTimeout);
   1182            
   1183            if(status == FLASH_COMPLETE)
   1184            {  
   1185              /* Enable the Option Bytes Programming operation */
   1186              FLASH->CR |= CR_OPTPG_Set; 
   1187          
   1188              if(FLASH_BOOT == FLASH_BOOT_Bank1)
   1189              {
   1190                OB->USER |= OB_USER_BFB2;
   1191              }
   1192              else
   1193              {
   1194                OB->USER &= (uint16_t)(~(uint16_t)(OB_USER_BFB2));
   1195              }
   1196              /* Wait for last operation to be completed */
   1197              status = FLASH_WaitForLastOperation(ProgramTimeout);
   1198              if(status != FLASH_TIMEOUT)
   1199              {
   1200                /* if the program operation is completed, disable the OPTPG Bit */
   1201                FLASH->CR &= CR_OPTPG_Reset;
   1202              }
   1203            }    
   1204            /* Return the Option Byte program Status */
   1205            return status;
   1206          }
   1207          #endif /* STM32F10X_XL */
   1208          
   1209          /**
   1210            * @brief  Returns the FLASH User Option Bytes values.
   1211            * @note   This function can be used for all STM32F10x devices.
   1212            * @param  None
   1213            * @retval The FLASH User Option Bytes values:IWDG_SW(Bit0), RST_STOP(Bit1)
   1214            *         and RST_STDBY(Bit2).
   1215            */

   \                                 In section .text, align 2, keep-with-next
   1216          uint32_t FLASH_GetUserOptionByte(void)
   1217          {
   1218            /* Return the User Option Byte */
   1219            return (uint32_t)(FLASH->OBR >> 2);
   \                     FLASH_GetUserOptionByte: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable22_9
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x0880             LSRS     R0,R0,#+2
   \        0x6   0x4770             BX       LR
   1220          }
   1221          
   1222          /**
   1223            * @brief  Returns the FLASH Write Protection Option Bytes Register value.
   1224            * @note   This function can be used for all STM32F10x devices.
   1225            * @param  None
   1226            * @retval The FLASH Write Protection  Option Bytes Register value
   1227            */

   \                                 In section .text, align 2, keep-with-next
   1228          uint32_t FLASH_GetWriteProtectionOptionByte(void)
   1229          {
   1230            /* Return the Flash write protection Register value */
   1231            return (uint32_t)(FLASH->WRPR);
   \                     FLASH_GetWriteProtectionOptionByte: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable22_10
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x4770             BX       LR
   1232          }
   1233          
   1234          /**
   1235            * @brief  Checks whether the FLASH Read Out Protection Status is set or not.
   1236            * @note   This function can be used for all STM32F10x devices.
   1237            * @param  None
   1238            * @retval FLASH ReadOut Protection Status(SET or RESET)
   1239            */

   \                                 In section .text, align 2, keep-with-next
   1240          FlagStatus FLASH_GetReadOutProtectionStatus(void)
   1241          {
   1242            FlagStatus readoutstatus = RESET;
   1243            if ((FLASH->OBR & RDPRT_Mask) != (uint32_t)RESET)
   \                     FLASH_GetReadOutProtectionStatus: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable22_9
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   1244            {
   1245              readoutstatus = SET;
   1246            }
   1247            else
   1248            {
   1249              readoutstatus = RESET;
   1250            }
   1251            return readoutstatus;
   \        0x4   0x0840             LSRS     R0,R0,#+1
   \        0x6   0x....             B.N      ?Subroutine3
   1252          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \        0x0   0xF000 0x0001      AND      R0,R0,#0x1
   \        0x4   0x4770             BX       LR
   1253          
   1254          /**
   1255            * @brief  Checks whether the FLASH Prefetch Buffer status is set or not.
   1256            * @note   This function can be used for all STM32F10x devices.
   1257            * @param  None
   1258            * @retval FLASH Prefetch Buffer Status (SET or RESET).
   1259            */

   \                                 In section .text, align 2, keep-with-next
   1260          FlagStatus FLASH_GetPrefetchBufferStatus(void)
   1261          {
   1262            FlagStatus bitstatus = RESET;
   1263            
   1264            if ((FLASH->ACR & ACR_PRFTBS_Mask) != (uint32_t)RESET)
   \                     FLASH_GetPrefetchBufferStatus: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable22
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   1265            {
   1266              bitstatus = SET;
   1267            }
   1268            else
   1269            {
   1270              bitstatus = RESET;
   1271            }
   1272            /* Return the new state of FLASH Prefetch Buffer Status (SET or RESET) */
   1273            return bitstatus; 
   \        0x4   0x0940             LSRS     R0,R0,#+5
   \        0x6                      REQUIRE ?Subroutine3
   \        0x6                      ;; // Fall through to label ?Subroutine3
   1274          }
   1275          
   1276          /**
   1277            * @brief  Enables or disables the specified FLASH interrupts.
   1278            * @note   This function can be used for all STM32F10x devices.
   1279            *         - For STM32F10X_XL devices, enables or disables the specified FLASH interrupts
   1280                        for Bank1 and Bank2.
   1281            *         - For other devices it enables or disables the specified FLASH interrupts for Bank1.
   1282            * @param  FLASH_IT: specifies the FLASH interrupt sources to be enabled or disabled.
   1283            *   This parameter can be any combination of the following values:
   1284            *     @arg FLASH_IT_ERROR: FLASH Error Interrupt
   1285            *     @arg FLASH_IT_EOP: FLASH end of operation Interrupt
   1286            * @param  NewState: new state of the specified Flash interrupts.
   1287            *   This parameter can be: ENABLE or DISABLE.      
   1288            * @retval None 
   1289            */

   \                                 In section .text, align 2, keep-with-next
   1290          void FLASH_ITConfig(uint32_t FLASH_IT, FunctionalState NewState)
   1291          {
   1292          #ifdef STM32F10X_XL
   1293            /* Check the parameters */
   1294            assert_param(IS_FLASH_IT(FLASH_IT)); 
   1295            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1296          
   1297            if((FLASH_IT & 0x80000000) != 0x0)
   1298            {
   1299              if(NewState != DISABLE)
   1300              {
   1301                /* Enable the interrupt sources */
   1302                FLASH->CR2 |= (FLASH_IT & 0x7FFFFFFF);
   1303              }
   1304              else
   1305              {
   1306                /* Disable the interrupt sources */
   1307                FLASH->CR2 &= ~(uint32_t)(FLASH_IT & 0x7FFFFFFF);
   1308              }
   1309            }
   1310            else
   1311            {
   1312              if(NewState != DISABLE)
   1313              {
   1314                /* Enable the interrupt sources */
   1315                FLASH->CR |= FLASH_IT;
   1316              }
   1317              else
   1318              {
   1319                /* Disable the interrupt sources */
   1320                FLASH->CR &= ~(uint32_t)FLASH_IT;
   1321              }
   1322            }
   1323          #else
   1324            /* Check the parameters */
   1325            assert_param(IS_FLASH_IT(FLASH_IT)); 
   1326            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1327          
   1328            if(NewState != DISABLE)
   \                     FLASH_ITConfig: (+1)
   \        0x0   0x....             LDR.N    R2,??DataTable22_4
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xBF19             ITTEE    NE
   \        0x6   0x6811             LDRNE    R1,[R2, #+0]
   \        0x8   0x4308             ORRNE    R0,R0,R1
   \        0xA   0x6813             LDREQ    R3,[R2, #+0]
   \        0xC   0xEA23 0x0000      BICEQ    R0,R3,R0
   1329            {
   1330              /* Enable the interrupt sources */
   1331              FLASH->CR |= FLASH_IT;
   1332            }
   1333            else
   1334            {
   1335              /* Disable the interrupt sources */
   1336              FLASH->CR &= ~(uint32_t)FLASH_IT;
   \       0x10   0x6010             STR      R0,[R2, #+0]
   1337            }
   1338          #endif /* STM32F10X_XL */
   1339          }
   \       0x12   0x4770             BX       LR
   1340          
   1341          /**
   1342            * @brief  Checks whether the specified FLASH flag is set or not.
   1343            * @note   This function can be used for all STM32F10x devices.
   1344            *         - For STM32F10X_XL devices, this function checks whether the specified 
   1345            *           Bank1 or Bank2 flag is set or not.
   1346            *         - For other devices, it checks whether the specified Bank1 flag is 
   1347            *           set or not.
   1348            * @param  FLASH_FLAG: specifies the FLASH flag to check.
   1349            *   This parameter can be one of the following values:
   1350            *     @arg FLASH_FLAG_BSY: FLASH Busy flag           
   1351            *     @arg FLASH_FLAG_PGERR: FLASH Program error flag       
   1352            *     @arg FLASH_FLAG_WRPRTERR: FLASH Write protected error flag      
   1353            *     @arg FLASH_FLAG_EOP: FLASH End of Operation flag           
   1354            *     @arg FLASH_FLAG_OPTERR:  FLASH Option Byte error flag     
   1355            * @retval The new state of FLASH_FLAG (SET or RESET).
   1356            */

   \                                 In section .text, align 2, keep-with-next
   1357          FlagStatus FLASH_GetFlagStatus(uint32_t FLASH_FLAG)
   1358          {
   \                     FLASH_GetFlagStatus: (+1)
   \        0x0   0x4601             MOV      R1,R0
   1359            FlagStatus bitstatus = RESET;
   \        0x2   0x2000             MOVS     R0,#+0
   1360          
   1361          #ifdef STM32F10X_XL
   1362            /* Check the parameters */
   1363            assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG)) ;
   1364            if(FLASH_FLAG == FLASH_FLAG_OPTERR) 
   1365            {
   1366              if((FLASH->OBR & FLASH_FLAG_OPTERR) != (uint32_t)RESET)
   1367              {
   1368                bitstatus = SET;
   1369              }
   1370              else
   1371              {
   1372                bitstatus = RESET;
   1373              }
   1374            }
   1375            else
   1376            {
   1377              if((FLASH_FLAG & 0x80000000) != 0x0)
   1378              {
   1379                if((FLASH->SR2 & FLASH_FLAG) != (uint32_t)RESET)
   1380                {
   1381                  bitstatus = SET;
   1382                }
   1383                else
   1384                {
   1385                  bitstatus = RESET;
   1386                }
   1387              }
   1388              else
   1389              {
   1390                if((FLASH->SR & FLASH_FLAG) != (uint32_t)RESET)
   1391                {
   1392                  bitstatus = SET;
   1393                }
   1394                else
   1395                {
   1396                  bitstatus = RESET;
   1397                }
   1398              }
   1399            }
   1400          #else
   1401            /* Check the parameters */
   1402            assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG)) ;
   1403            if(FLASH_FLAG == FLASH_FLAG_OPTERR) 
   \        0x4   0x2901             CMP      R1,#+1
   \        0x6   0x....             LDR.N    R2,??DataTable22_11
   \        0x8   0xD101             BNE.N    ??FLASH_GetFlagStatus_0
   1404            {
   1405              if((FLASH->OBR & FLASH_FLAG_OPTERR) != (uint32_t)RESET)
   \        0xA   0x6910             LDR      R0,[R2, #+16]
   1406              {
   1407                bitstatus = SET;
   1408              }
   1409              else
   1410              {
   1411                bitstatus = RESET;
   \        0xC   0x....             B.N      ?Subroutine3
   1412              }
   1413            }
   1414            else
   1415            {
   1416             if((FLASH->SR & FLASH_FLAG) != (uint32_t)RESET)
   \                     ??FLASH_GetFlagStatus_0: (+1)
   \        0xE   0x6812             LDR      R2,[R2, #+0]
   \       0x10   0x420A             TST      R2,R1
   \       0x12   0xBF18             IT       NE
   \       0x14   0x2001             MOVNE    R0,#+1
   1417              {
   1418                bitstatus = SET;
   1419              }
   1420              else
   1421              {
   1422                bitstatus = RESET;
   1423              }
   1424            }
   1425          #endif /* STM32F10X_XL */
   1426          
   1427            /* Return the new state of FLASH_FLAG (SET or RESET) */
   1428            return bitstatus;
   \       0x16   0x4770             BX       LR
   1429          }
   1430          
   1431          /**
   1432            * @brief  Clears the FLASH's pending flags.
   1433            * @note   This function can be used for all STM32F10x devices.
   1434            *         - For STM32F10X_XL devices, this function clears Bank1 or Bank2s pending flags
   1435            *         - For other devices, it clears Bank1s pending flags.
   1436            * @param  FLASH_FLAG: specifies the FLASH flags to clear.
   1437            *   This parameter can be any combination of the following values:         
   1438            *     @arg FLASH_FLAG_PGERR: FLASH Program error flag       
   1439            *     @arg FLASH_FLAG_WRPRTERR: FLASH Write protected error flag      
   1440            *     @arg FLASH_FLAG_EOP: FLASH End of Operation flag           
   1441            * @retval None
   1442            */

   \                                 In section .text, align 2, keep-with-next
   1443          void FLASH_ClearFlag(uint32_t FLASH_FLAG)
   1444          {
   1445          #ifdef STM32F10X_XL
   1446            /* Check the parameters */
   1447            assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG)) ;
   1448          
   1449            if((FLASH_FLAG & 0x80000000) != 0x0)
   1450            {
   1451              /* Clear the flags */
   1452              FLASH->SR2 = FLASH_FLAG;
   1453            }
   1454            else
   1455            {
   1456              /* Clear the flags */
   1457              FLASH->SR = FLASH_FLAG;
   1458            }  
   1459          
   1460          #else
   1461            /* Check the parameters */
   1462            assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG)) ;
   1463            
   1464            /* Clear the flags */
   1465            FLASH->SR = FLASH_FLAG;
   \                     FLASH_ClearFlag: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable22_11
   \        0x2   0x6008             STR      R0,[R1, #+0]
   1466          #endif /* STM32F10X_XL */
   1467          }
   \        0x4   0x4770             BX       LR
   1468          
   1469          /**
   1470            * @brief  Returns the FLASH Status.
   1471            * @note   This function can be used for all STM32F10x devices, it is equivalent
   1472            *         to FLASH_GetBank1Status function.
   1473            * @param  None
   1474            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PG,
   1475            *         FLASH_ERROR_WRP or FLASH_COMPLETE
   1476            */

   \                                 In section .text, align 2, keep-with-next
   1477          FLASH_Status FLASH_GetStatus(void)
   1478          {
   1479            FLASH_Status flashstatus = FLASH_COMPLETE;
   1480            
   1481            if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
   \                     FLASH_GetStatus: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable22_11
   \        0x2   0x680A             LDR      R2,[R1, #+0]
   \        0x4   0x2004             MOVS     R0,#+4
   \        0x6   0x07D3             LSLS     R3,R2,#+31
   \        0x8   0xD501             BPL.N    ??FLASH_GetStatus_0
   1482            {
   1483              flashstatus = FLASH_BUSY;
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0x4770             BX       LR
   1484            }
   1485            else 
   1486            {  
   1487              if((FLASH->SR & FLASH_FLAG_PGERR) != 0)
   \                     ??FLASH_GetStatus_0: (+1)
   \        0xE   0x680A             LDR      R2,[R1, #+0]
   \       0x10   0x0753             LSLS     R3,R2,#+29
   \       0x12   0xD501             BPL.N    ??FLASH_GetStatus_1
   1488              { 
   1489                flashstatus = FLASH_ERROR_PG;
   \       0x14   0x2002             MOVS     R0,#+2
   \       0x16   0x4770             BX       LR
   1490              }
   1491              else 
   1492              {
   1493                if((FLASH->SR & FLASH_FLAG_WRPRTERR) != 0 )
   \                     ??FLASH_GetStatus_1: (+1)
   \       0x18   0x6809             LDR      R1,[R1, #+0]
   \       0x1A   0x06CA             LSLS     R2,R1,#+27
   \       0x1C   0xBF48             IT       MI
   \       0x1E   0x2003             MOVMI    R0,#+3
   1494                {
   1495                  flashstatus = FLASH_ERROR_WRP;
   1496                }
   1497                else
   1498                {
   1499                  flashstatus = FLASH_COMPLETE;
   1500                }
   1501              }
   1502            }
   1503            /* Return the Flash Status */
   1504            return flashstatus;
   \       0x20   0x4770             BX       LR
   1505          }
   1506          
   1507          /**
   1508            * @brief  Returns the FLASH Bank1 Status.
   1509            * @note   This function can be used for all STM32F10x devices, it is equivalent
   1510            *         to FLASH_GetStatus function.
   1511            * @param  None
   1512            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PG,
   1513            *         FLASH_ERROR_WRP or FLASH_COMPLETE
   1514            */

   \                                 In section .text, align 2, keep-with-next
   1515          FLASH_Status FLASH_GetBank1Status(void)
   1516          {
   1517            FLASH_Status flashstatus = FLASH_COMPLETE;
   1518            
   1519            if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
   \                     FLASH_GetBank1Status: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable22_11
   \        0x2   0x680A             LDR      R2,[R1, #+0]
   \        0x4   0x2004             MOVS     R0,#+4
   \        0x6   0x07D3             LSLS     R3,R2,#+31
   \        0x8   0xD501             BPL.N    ??FLASH_GetBank1Status_0
   1520            {
   1521              flashstatus = FLASH_BUSY;
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0x4770             BX       LR
   1522            }
   1523            else 
   1524            {  
   1525              if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
   \                     ??FLASH_GetBank1Status_0: (+1)
   \        0xE   0x680A             LDR      R2,[R1, #+0]
   \       0x10   0x0753             LSLS     R3,R2,#+29
   \       0x12   0xD501             BPL.N    ??FLASH_GetBank1Status_1
   1526              { 
   1527                flashstatus = FLASH_ERROR_PG;
   \       0x14   0x2002             MOVS     R0,#+2
   \       0x16   0x4770             BX       LR
   1528              }
   1529              else 
   1530              {
   1531                if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
   \                     ??FLASH_GetBank1Status_1: (+1)
   \       0x18   0x6809             LDR      R1,[R1, #+0]
   \       0x1A   0x06CA             LSLS     R2,R1,#+27
   \       0x1C   0xBF48             IT       MI
   \       0x1E   0x2003             MOVMI    R0,#+3
   1532                {
   1533                  flashstatus = FLASH_ERROR_WRP;
   1534                }
   1535                else
   1536                {
   1537                  flashstatus = FLASH_COMPLETE;
   1538                }
   1539              }
   1540            }
   1541            /* Return the Flash Status */
   1542            return flashstatus;
   \       0x20   0x4770             BX       LR
   1543          }
   1544          
   1545          #ifdef STM32F10X_XL
   1546          /**
   1547            * @brief  Returns the FLASH Bank2 Status.
   1548            * @note   This function can be used for STM32F10x_XL density devices.
   1549            * @param  None
   1550            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PG,
   1551            *        FLASH_ERROR_WRP or FLASH_COMPLETE
   1552            */
   1553          FLASH_Status FLASH_GetBank2Status(void)
   1554          {
   1555            FLASH_Status flashstatus = FLASH_COMPLETE;
   1556            
   1557            if((FLASH->SR2 & (FLASH_FLAG_BANK2_BSY & 0x7FFFFFFF)) == (FLASH_FLAG_BANK2_BSY & 0x7FFFFFFF)) 
   1558            {
   1559              flashstatus = FLASH_BUSY;
   1560            }
   1561            else 
   1562            {  
   1563              if((FLASH->SR2 & (FLASH_FLAG_BANK2_PGERR & 0x7FFFFFFF)) != 0)
   1564              { 
   1565                flashstatus = FLASH_ERROR_PG;
   1566              }
   1567              else 
   1568              {
   1569                if((FLASH->SR2 & (FLASH_FLAG_BANK2_WRPRTERR & 0x7FFFFFFF)) != 0 )
   1570                {
   1571                  flashstatus = FLASH_ERROR_WRP;
   1572                }
   1573                else
   1574                {
   1575                  flashstatus = FLASH_COMPLETE;
   1576                }
   1577              }
   1578            }
   1579            /* Return the Flash Status */
   1580            return flashstatus;
   1581          }
   1582          #endif /* STM32F10X_XL */
   1583          /**
   1584            * @brief  Waits for a Flash operation to complete or a TIMEOUT to occur.
   1585            * @note   This function can be used for all STM32F10x devices, 
   1586            *         it is equivalent to FLASH_WaitForLastBank1Operation.
   1587            *         - For STM32F10X_XL devices this function waits for a Bank1 Flash operation
   1588            *           to complete or a TIMEOUT to occur.
   1589            *         - For all other devices it waits for a Flash operation to complete 
   1590            *           or a TIMEOUT to occur.
   1591            * @param  Timeout: FLASH programming Timeout
   1592            * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
   1593            *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
   1594            */

   \                                 In section .text, align 2, keep-with-next
   1595          FLASH_Status FLASH_WaitForLastOperation(uint32_t Timeout)
   1596          { 
   \                     FLASH_WaitForLastOperation: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x....             B.N      ?Subroutine4

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \        0x0   0x4604             MOV      R4,R0
   1597            FLASH_Status status = FLASH_COMPLETE;
   1598             
   1599            /* Check for the Flash Status */
   1600            status = FLASH_GetBank1Status();
   \        0x2   0x.... 0x....      BL       FLASH_GetBank1Status
   \        0x6   0xE003             B.N      ??Subroutine4_0
   1601            /* Wait for a Flash operation to complete or a TIMEOUT to occur */
   1602            while((status == FLASH_BUSY) && (Timeout != 0x00))
   \                     ??Subroutine4_1: (+1)
   \        0x8   0xB12C             CBZ.N    R4,??Subroutine4_2
   1603            {
   1604              status = FLASH_GetBank1Status();
   \        0xA   0x.... 0x....      BL       FLASH_GetBank1Status
   1605              Timeout--;
   \        0xE   0x1E64             SUBS     R4,R4,#+1
   \                     ??Subroutine4_0: (+1)
   \       0x10   0x2801             CMP      R0,#+1
   \       0x12   0xD0F9             BEQ.N    ??Subroutine4_1
   1606            }
   1607            if(Timeout == 0x00 )
   \       0x14   0xB904             CBNZ.N   R4,??Subroutine4_3
   1608            {
   1609              status = FLASH_TIMEOUT;
   \                     ??Subroutine4_2: (+1)
   \       0x16   0x2005             MOVS     R0,#+5
   1610            }
   1611            /* Return the operation status */
   1612            return status;
   \                     ??Subroutine4_3: (+1)
   \       0x18   0xBD10             POP      {R4,PC}
   1613          }
   1614          
   1615          /**
   1616            * @brief  Waits for a Flash operation on Bank1 to complete or a TIMEOUT to occur.
   1617            * @note   This function can be used for all STM32F10x devices, 
   1618            *         it is equivalent to FLASH_WaitForLastOperation.
   1619            * @param  Timeout: FLASH programming Timeout
   1620            * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
   1621            *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
   1622            */

   \                                 In section .text, align 2, keep-with-next
   1623          FLASH_Status FLASH_WaitForLastBank1Operation(uint32_t Timeout)
   1624          { 
   \                     FLASH_WaitForLastBank1Operation: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2                      REQUIRE ?Subroutine4
   \        0x2                      ;; // Fall through to label ?Subroutine4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22:
   \        0x0   0x4002'2000        DC32     0x40022000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_1:
   \        0x0   0x4002'2004        DC32     0x40022004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_2:
   \        0x0   0x4567'0123        DC32     0x45670123

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_3:
   \        0x0   0xCDEF'89AB        DC32     0xcdef89ab

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_4:
   \        0x0   0x4002'2010        DC32     0x40022010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_5:
   \        0x0   0x4002'2008        DC32     0x40022008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_6:
   \        0x0   0x1FFF'F800        DC32     0x1ffff800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_7:
   \        0x0   0x1FFF'F808        DC32     0x1ffff808

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_8:
   \        0x0   0x1FFF'F802        DC32     0x1ffff802

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_9:
   \        0x0   0x4002'201C        DC32     0x4002201c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_10:
   \        0x0   0x4002'2020        DC32     0x40022020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_11:
   \        0x0   0x4002'200C        DC32     0x4002200c
   1625            FLASH_Status status = FLASH_COMPLETE;
   1626             
   1627            /* Check for the Flash Status */
   1628            status = FLASH_GetBank1Status();
   1629            /* Wait for a Flash operation to complete or a TIMEOUT to occur */
   1630            while((status == FLASH_FLAG_BANK1_BSY) && (Timeout != 0x00))
   1631            {
   1632              status = FLASH_GetBank1Status();
   1633              Timeout--;
   1634            }
   1635            if(Timeout == 0x00 )
   1636            {
   1637              status = FLASH_TIMEOUT;
   1638            }
   1639            /* Return the operation status */
   1640            return status;
   1641          }
   1642          
   1643          #ifdef STM32F10X_XL
   1644          /**
   1645            * @brief  Waits for a Flash operation on Bank2 to complete or a TIMEOUT to occur.
   1646            * @note   This function can be used only for STM32F10x_XL density devices.
   1647            * @param  Timeout: FLASH programming Timeout
   1648            * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
   1649            *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
   1650            */
   1651          FLASH_Status FLASH_WaitForLastBank2Operation(uint32_t Timeout)
   1652          { 
   1653            FLASH_Status status = FLASH_COMPLETE;
   1654             
   1655            /* Check for the Flash Status */
   1656            status = FLASH_GetBank2Status();
   1657            /* Wait for a Flash operation to complete or a TIMEOUT to occur */
   1658            while((status == (FLASH_FLAG_BANK2_BSY & 0x7FFFFFFF)) && (Timeout != 0x00))
   1659            {
   1660              status = FLASH_GetBank2Status();
   1661              Timeout--;
   1662            }
   1663            if(Timeout == 0x00 )
   1664            {
   1665              status = FLASH_TIMEOUT;
   1666            }
   1667            /* Return the operation status */
   1668            return status;
   1669          }
   1670          #endif /* STM32F10X_XL */
   1671          
   1672          /**
   1673            * @}
   1674            */
   1675          
   1676          /**
   1677            * @}
   1678            */
   1679          
   1680          /**
   1681            * @}
   1682            */
   1683          
   1684          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   FLASH_ClearFlag
      32   FLASH_EnableWriteProtection
        32   -> FLASH_WaitForLastOperation
       8   FLASH_EraseAllBank1Pages
         8   -> FLASH_WaitForLastBank1Operation
       8   FLASH_EraseAllPages
         8   -> FLASH_WaitForLastOperation
      16   FLASH_EraseOptionBytes
        16   -> FLASH_WaitForLastOperation
      16   FLASH_ErasePage
        16   -> FLASH_WaitForLastOperation
       0   FLASH_GetBank1Status
       0   FLASH_GetFlagStatus
       0   FLASH_GetPrefetchBufferStatus
       0   FLASH_GetReadOutProtectionStatus
       0   FLASH_GetStatus
       0   FLASH_GetUserOptionByte
       0   FLASH_GetWriteProtectionOptionByte
       0   FLASH_HalfCycleAccessCmd
       0   FLASH_ITConfig
       0   FLASH_Lock
       0   FLASH_LockBank1
       0   FLASH_PrefetchBufferCmd
      16   FLASH_ProgramHalfWord
        16   -> FLASH_WaitForLastOperation
      16   FLASH_ProgramOptionByteData
        16   -> FLASH_WaitForLastOperation
      24   FLASH_ProgramWord
        24   -> FLASH_WaitForLastOperation
      16   FLASH_ReadOutProtection
        16   -> FLASH_WaitForLastOperation
       0   FLASH_SetLatency
       0   FLASH_Unlock
       0   FLASH_UnlockBank1
      24   FLASH_UserOptionByteConfig
        24   -> FLASH_WaitForLastOperation
       0   FLASH_WaitForLastBank1Operation
         8   -> FLASH_GetBank1Status
       8   FLASH_WaitForLastOperation
         8   -> FLASH_GetBank1Status


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable22
       4  ??DataTable22_1
       4  ??DataTable22_10
       4  ??DataTable22_11
       4  ??DataTable22_2
       4  ??DataTable22_3
       4  ??DataTable22_4
       4  ??DataTable22_5
       4  ??DataTable22_6
       4  ??DataTable22_7
       4  ??DataTable22_8
       4  ??DataTable22_9
       6  ??Subroutine11_0
      18  ?Subroutine0
      14  ?Subroutine1
      12  ?Subroutine10
      10  ?Subroutine2
       6  ?Subroutine3
      26  ?Subroutine4
       8  ?Subroutine5
      24  ?Subroutine6
      12  ?Subroutine7
      12  ?Subroutine8
      10  ?Subroutine9
       6  FLASH_ClearFlag
     126  FLASH_EnableWriteProtection
      28  FLASH_EraseAllBank1Pages
      24  FLASH_EraseAllPages
      92  FLASH_EraseOptionBytes
      52  FLASH_ErasePage
      34  FLASH_GetBank1Status
      24  FLASH_GetFlagStatus
       6  FLASH_GetPrefetchBufferStatus
       8  FLASH_GetReadOutProtectionStatus
      34  FLASH_GetStatus
       8  FLASH_GetUserOptionByte
       6  FLASH_GetWriteProtectionOptionByte
      12  FLASH_HalfCycleAccessCmd
      20  FLASH_ITConfig
       2  FLASH_Lock
       2  FLASH_LockBank1
      10  FLASH_PrefetchBufferCmd
      30  FLASH_ProgramHalfWord
      48  FLASH_ProgramOptionByteData
      58  FLASH_ProgramWord
     108  FLASH_ReadOutProtection
      16  FLASH_SetLatency
       2  FLASH_Unlock
       2  FLASH_UnlockBank1
      60  FLASH_UserOptionByteConfig
       2  FLASH_WaitForLastBank1Operation
       4  FLASH_WaitForLastOperation

 
 1'030 bytes in section .text
 
 1'030 bytes of CODE memory

Errors: none
Warnings: none
