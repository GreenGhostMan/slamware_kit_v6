###############################################################################
#
# IAR ANSI C/C++ Compiler V9.10.2.313/W64 for ARM         28/Jul/2021  15:57:34
# Copyright 1999-2021 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\infra_pub\arch\st_fwlib\STM32F10x_StdPeriph_Driver\src\stm32f10x_fsmc.c
#    Command line      =
#        -f
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\Release_Rev6\List\Runtime\FWLib\src\stm32f10x_fsmc.lst.rsp
#        (C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\infra_pub\arch\st_fwlib\STM32F10x_StdPeriph_Driver\src\stm32f10x_fsmc.c
#        -D USE_STDPERIPH_DRIVER -D STM32F10X_HD -D USART_ENABLE_USART3 -D
#        CONFIG_BREAKOUT_REV=6 -D USE_FRONT_IR_SENSORS -D FEATURE_SET_V -lCN
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\Release_Rev6\List\Runtime\FWLib\src
#        --diag_suppress Pa050 -o
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\Release_Rev6\Obj\Runtime\FWLib\src
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        9.0\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\src\
#        -I
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\..\..\common\inc\
#        -I
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\..\infra_pub\
#        -I
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\..\infra_pub\arch\st_fwlib\CMSIS\CM3\CoreSupport\
#        -I
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\..\infra_pub\arch\st_fwlib\CMSIS\CM3\DeviceSupport\ST\STM32F10x\
#        -I
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\..\infra_pub\arch\st_fwlib\STM32F10x_StdPeriph_Driver\inc\
#        -I
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\..\infra_pub\arch\infra_stm32\
#        -I
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\..\infra_pub\arch\infra_stm32\32f10x\
#        -Ohz --use_c++_inline) --dependencies=n
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\Release_Rev6\Obj\Runtime\FWLib\src\stm32f10x_fsmc.o.d
#    Locale            =  C
#    List file         =
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\Release_Rev6\List\Runtime\FWLib\src\stm32f10x_fsmc.lst
#    Object file       =
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\Release_Rev6\Obj\Runtime\FWLib\src\stm32f10x_fsmc.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\infra_pub\arch\st_fwlib\STM32F10x_StdPeriph_Driver\src\stm32f10x_fsmc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f10x_fsmc.c
      4            * @author  MCD Application Team
      5            * @version V3.5.0
      6            * @date    11-March-2011
      7            * @brief   This file provides all the FSMC firmware functions.
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     19            ******************************************************************************
     20            */
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "stm32f10x_fsmc.h"
     24          #include "stm32f10x_rcc.h"
     25          
     26          /** @addtogroup STM32F10x_StdPeriph_Driver
     27            * @{
     28            */
     29          
     30          /** @defgroup FSMC 
     31            * @brief FSMC driver modules
     32            * @{
     33            */ 
     34          
     35          /** @defgroup FSMC_Private_TypesDefinitions
     36            * @{
     37            */ 
     38          /**
     39            * @}
     40            */
     41          
     42          /** @defgroup FSMC_Private_Defines
     43            * @{
     44            */
     45          
     46          /* --------------------- FSMC registers bit mask ---------------------------- */
     47          
     48          /* FSMC BCRx Mask */
     49          #define BCR_MBKEN_Set                       ((uint32_t)0x00000001)
     50          #define BCR_MBKEN_Reset                     ((uint32_t)0x000FFFFE)
     51          #define BCR_FACCEN_Set                      ((uint32_t)0x00000040)
     52          
     53          /* FSMC PCRx Mask */
     54          #define PCR_PBKEN_Set                       ((uint32_t)0x00000004)
     55          #define PCR_PBKEN_Reset                     ((uint32_t)0x000FFFFB)
     56          #define PCR_ECCEN_Set                       ((uint32_t)0x00000040)
     57          #define PCR_ECCEN_Reset                     ((uint32_t)0x000FFFBF)
     58          #define PCR_MemoryType_NAND                 ((uint32_t)0x00000008)
     59          /**
     60            * @}
     61            */
     62          
     63          /** @defgroup FSMC_Private_Macros
     64            * @{
     65            */
     66          
     67          /**
     68            * @}
     69            */
     70          
     71          /** @defgroup FSMC_Private_Variables
     72            * @{
     73            */
     74          
     75          /**
     76            * @}
     77            */
     78          
     79          /** @defgroup FSMC_Private_FunctionPrototypes
     80            * @{
     81            */
     82          
     83          /**
     84            * @}
     85            */
     86          
     87          /** @defgroup FSMC_Private_Functions
     88            * @{
     89            */
     90          
     91          /**
     92            * @brief  Deinitializes the FSMC NOR/SRAM Banks registers to their default 
     93            *         reset values.
     94            * @param  FSMC_Bank: specifies the FSMC Bank to be used
     95            *   This parameter can be one of the following values:
     96            *     @arg FSMC_Bank1_NORSRAM1: FSMC Bank1 NOR/SRAM1  
     97            *     @arg FSMC_Bank1_NORSRAM2: FSMC Bank1 NOR/SRAM2 
     98            *     @arg FSMC_Bank1_NORSRAM3: FSMC Bank1 NOR/SRAM3 
     99            *     @arg FSMC_Bank1_NORSRAM4: FSMC Bank1 NOR/SRAM4 
    100            * @retval None
    101            */

   \                                 In section .text, align 2, keep-with-next
    102          void FSMC_NORSRAMDeInit(uint32_t FSMC_Bank)
    103          {
   \                     FSMC_NORSRAMDeInit: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    104            /* Check the parameter */
    105            assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
    106            
    107            /* FSMC_Bank1_NORSRAM1 */
    108            if(FSMC_Bank == FSMC_Bank1_NORSRAM1)
   \        0x2   0xF04F 0x4120      MOV      R1,#+2684354560
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xBF07             ITTEE    EQ
   \        0xA   0xF243 0x02DB      MOVWEQ   R2,#+12507
   \        0xE   0x600A             STREQ    R2,[R1, #+0]
   \       0x10   0xF243 0x03D2      MOVWNE   R3,#+12498
   \       0x14   0xF841 0x3020      STRNE    R3,[R1, R0, LSL #+2]
    109            {
    110              FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030DB;    
    111            }
    112            /* FSMC_Bank1_NORSRAM2,  FSMC_Bank1_NORSRAM3 or FSMC_Bank1_NORSRAM4 */
    113            else
    114            {   
    115              FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030D2; 
    116            }
    117            FSMC_Bank1->BTCR[FSMC_Bank + 1] = 0x0FFFFFFF;
   \       0x18   0xF04F 0x4220      MOV      R2,#+2684354560
   \       0x1C   0xEB02 0x0380      ADD      R3,R2,R0, LSL #+2
   \       0x20   0xF06F 0x4170      MVN      R1,#+4026531840
    118            FSMC_Bank1E->BWTR[FSMC_Bank] = 0x0FFFFFFF;  
   \       0x24   0x.... 0x....      LDR.W    R4,??DataTable15
   \       0x28   0x6059             STR      R1,[R3, #+4]
   \       0x2A   0xF844 0x1020      STR      R1,[R4, R0, LSL #+2]
    119          }
   \       0x2E   0xBD10             POP      {R4,PC}
    120          
    121          /**
    122            * @brief  Deinitializes the FSMC NAND Banks registers to their default reset values.
    123            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    124            *   This parameter can be one of the following values:
    125            *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    126            *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND 
    127            * @retval None
    128            */

   \                                 In section .text, align 2, keep-with-next
    129          void FSMC_NANDDeInit(uint32_t FSMC_Bank)
    130          {
    131            /* Check the parameter */
    132            assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
    133            
    134            if(FSMC_Bank == FSMC_Bank2_NAND)
   \                     FSMC_NANDDeInit: (+1)
   \        0x0   0x2810             CMP      R0,#+16
   \        0x2   0xF04F 0x31FC      MOV      R1,#+4244438268
   \        0x6   0x.... 0x....      LDR.W    R2,??DataTable15_1
   \        0xA   0xD106             BNE.N    ??FSMC_NANDDeInit_0
    135            {
    136              /* Set the FSMC_Bank2 registers to their reset values */
    137              FSMC_Bank2->PCR2 = 0x00000018;
   \        0xC   0x2018             MOVS     R0,#+24
   \        0xE   0x6010             STR      R0,[R2, #+0]
    138              FSMC_Bank2->SR2 = 0x00000040;
   \       0x10   0x2340             MOVS     R3,#+64
   \       0x12   0x6053             STR      R3,[R2, #+4]
    139              FSMC_Bank2->PMEM2 = 0xFCFCFCFC;
   \       0x14   0x6091             STR      R1,[R2, #+8]
    140              FSMC_Bank2->PATT2 = 0xFCFCFCFC;  
   \       0x16   0x60D1             STR      R1,[R2, #+12]
   \       0x18   0x4770             BX       LR
    141            }
    142            /* FSMC_Bank3_NAND */  
    143            else
    144            {
    145              /* Set the FSMC_Bank3 registers to their reset values */
    146              FSMC_Bank3->PCR3 = 0x00000018;
   \                     ??FSMC_NANDDeInit_0: (+1)
   \       0x1A   0x2018             MOVS     R0,#+24
   \       0x1C   0x6210             STR      R0,[R2, #+32]
    147              FSMC_Bank3->SR3 = 0x00000040;
   \       0x1E   0x2340             MOVS     R3,#+64
   \       0x20   0x6253             STR      R3,[R2, #+36]
    148              FSMC_Bank3->PMEM3 = 0xFCFCFCFC;
   \       0x22   0x6291             STR      R1,[R2, #+40]
    149              FSMC_Bank3->PATT3 = 0xFCFCFCFC; 
   \       0x24   0x62D1             STR      R1,[R2, #+44]
    150            }  
    151          }
   \       0x26   0x4770             BX       LR
    152          
    153          /**
    154            * @brief  Deinitializes the FSMC PCCARD Bank registers to their default reset values.
    155            * @param  None                       
    156            * @retval None
    157            */

   \                                 In section .text, align 2, keep-with-next
    158          void FSMC_PCCARDDeInit(void)
    159          {
    160            /* Set the FSMC_Bank4 registers to their reset values */
    161            FSMC_Bank4->PCR4 = 0x00000018; 
   \                     FSMC_PCCARDDeInit: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable15_2
   \        0x4   0x2118             MOVS     R1,#+24
   \        0x6   0x6001             STR      R1,[R0, #+0]
    162            FSMC_Bank4->SR4 = 0x00000000;	
   \        0x8   0x2200             MOVS     R2,#+0
   \        0xA   0x6042             STR      R2,[R0, #+4]
    163            FSMC_Bank4->PMEM4 = 0xFCFCFCFC;
   \        0xC   0xF04F 0x31FC      MOV      R1,#+4244438268
   \       0x10   0x6081             STR      R1,[R0, #+8]
    164            FSMC_Bank4->PATT4 = 0xFCFCFCFC;
   \       0x12   0x60C1             STR      R1,[R0, #+12]
    165            FSMC_Bank4->PIO4 = 0xFCFCFCFC;
   \       0x14   0x6101             STR      R1,[R0, #+16]
    166          }
   \       0x16   0x4770             BX       LR
    167          
    168          /**
    169            * @brief  Initializes the FSMC NOR/SRAM Banks according to the specified
    170            *         parameters in the FSMC_NORSRAMInitStruct.
    171            * @param  FSMC_NORSRAMInitStruct : pointer to a FSMC_NORSRAMInitTypeDef
    172            *         structure that contains the configuration information for 
    173            *        the FSMC NOR/SRAM specified Banks.                       
    174            * @retval None
    175            */

   \                                 In section .text, align 2, keep-with-next
    176          void FSMC_NORSRAMInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
    177          { 
   \                     FSMC_NORSRAMInit: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
    178            /* Check the parameters */
    179            assert_param(IS_FSMC_NORSRAM_BANK(FSMC_NORSRAMInitStruct->FSMC_Bank));
    180            assert_param(IS_FSMC_MUX(FSMC_NORSRAMInitStruct->FSMC_DataAddressMux));
    181            assert_param(IS_FSMC_MEMORY(FSMC_NORSRAMInitStruct->FSMC_MemoryType));
    182            assert_param(IS_FSMC_MEMORY_WIDTH(FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth));
    183            assert_param(IS_FSMC_BURSTMODE(FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode));
    184            assert_param(IS_FSMC_ASYNWAIT(FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait));
    185            assert_param(IS_FSMC_WAIT_POLARITY(FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity));
    186            assert_param(IS_FSMC_WRAP_MODE(FSMC_NORSRAMInitStruct->FSMC_WrapMode));
    187            assert_param(IS_FSMC_WAIT_SIGNAL_ACTIVE(FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive));
    188            assert_param(IS_FSMC_WRITE_OPERATION(FSMC_NORSRAMInitStruct->FSMC_WriteOperation));
    189            assert_param(IS_FSMC_WAITE_SIGNAL(FSMC_NORSRAMInitStruct->FSMC_WaitSignal));
    190            assert_param(IS_FSMC_EXTENDED_MODE(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode));
    191            assert_param(IS_FSMC_WRITE_BURST(FSMC_NORSRAMInitStruct->FSMC_WriteBurst));  
    192            assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime));
    193            assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime));
    194            assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime));
    195            assert_param(IS_FSMC_TURNAROUND_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration));
    196            assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision));
    197            assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency));
    198            assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode)); 
    199            
    200            /* Bank1 NOR/SRAM control register configuration */ 
    201            FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
    202                      (uint32_t)FSMC_NORSRAMInitStruct->FSMC_DataAddressMux |
    203                      FSMC_NORSRAMInitStruct->FSMC_MemoryType |
    204                      FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth |
    205                      FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode |
    206                      FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait |
    207                      FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity |
    208                      FSMC_NORSRAMInitStruct->FSMC_WrapMode |
    209                      FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive |
    210                      FSMC_NORSRAMInitStruct->FSMC_WriteOperation |
    211                      FSMC_NORSRAMInitStruct->FSMC_WaitSignal |
    212                      FSMC_NORSRAMInitStruct->FSMC_ExtendedMode |
    213                      FSMC_NORSRAMInitStruct->FSMC_WriteBurst;
   \        0x2   0x6844             LDR      R4,[R0, #+4]
   \        0x4   0x6881             LDR      R1,[R0, #+8]
   \        0x6   0x68C2             LDR      R2,[R0, #+12]
   \        0x8   0x6805             LDR      R5,[R0, #+0]
   \        0xA   0x430C             ORRS     R4,R1,R4
   \        0xC   0x6901             LDR      R1,[R0, #+16]
   \        0xE   0x4314             ORRS     R4,R2,R4
   \       0x10   0x6942             LDR      R2,[R0, #+20]
   \       0x12   0x430C             ORRS     R4,R1,R4
   \       0x14   0x6981             LDR      R1,[R0, #+24]
   \       0x16   0x4314             ORRS     R4,R2,R4
   \       0x18   0x69C2             LDR      R2,[R0, #+28]
   \       0x1A   0x430C             ORRS     R4,R1,R4
   \       0x1C   0x6A01             LDR      R1,[R0, #+32]
   \       0x1E   0x4314             ORRS     R4,R2,R4
   \       0x20   0x6A42             LDR      R2,[R0, #+36]
   \       0x22   0x430C             ORRS     R4,R1,R4
   \       0x24   0x6A81             LDR      R1,[R0, #+40]
   \       0x26   0x4314             ORRS     R4,R2,R4
   \       0x28   0x6AC2             LDR      R2,[R0, #+44]
   \       0x2A   0x430C             ORRS     R4,R1,R4
   \       0x2C   0x6B01             LDR      R1,[R0, #+48]
   \       0x2E   0xF04F 0x4320      MOV      R3,#+2684354560
   \       0x32   0x4314             ORRS     R4,R2,R4
   \       0x34   0x430C             ORRS     R4,R1,R4
   \       0x36   0xF843 0x4025      STR      R4,[R3, R5, LSL #+2]
    214          
    215            if(FSMC_NORSRAMInitStruct->FSMC_MemoryType == FSMC_MemoryType_NOR)
   \       0x3A   0x6881             LDR      R1,[R0, #+8]
   \       0x3C   0x2908             CMP      R1,#+8
   \       0x3E   0xD106             BNE.N    ??FSMC_NORSRAMInit_0
    216            {
    217              FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] |= (uint32_t)BCR_FACCEN_Set;
   \       0x40   0x6801             LDR      R1,[R0, #+0]
   \       0x42   0xF853 0x2021      LDR      R2,[R3, R1, LSL #+2]
   \       0x46   0xF042 0x0240      ORR      R2,R2,#0x40
   \       0x4A   0xF843 0x2021      STR      R2,[R3, R1, LSL #+2]
    218            }
    219            
    220            /* Bank1 NOR/SRAM timing register configuration */
    221            FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank+1] = 
    222                      (uint32_t)FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime |
    223                      (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime << 4) |
    224                      (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime << 8) |
    225                      (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration << 16) |
    226                      (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision << 20) |
    227                      (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency << 24) |
    228                       FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode;
   \                     ??FSMC_NORSRAMInit_0: (+1)
   \       0x4E   0x6B41             LDR      R1,[R0, #+52]
   \       0x50   0x680A             LDR      R2,[R1, #+0]
   \       0x52   0x684B             LDR      R3,[R1, #+4]
   \       0x54   0x688C             LDR      R4,[R1, #+8]
   \       0x56   0xEA42 0x1203      ORR      R2,R2,R3, LSL #+4
   \       0x5A   0x68CB             LDR      R3,[R1, #+12]
   \       0x5C   0xEA42 0x2204      ORR      R2,R2,R4, LSL #+8
   \       0x60   0x690C             LDR      R4,[R1, #+16]
   \       0x62   0xEA42 0x4203      ORR      R2,R2,R3, LSL #+16
   \       0x66   0x694B             LDR      R3,[R1, #+20]
   \       0x68   0x6989             LDR      R1,[R1, #+24]
   \       0x6A   0xEA42 0x5204      ORR      R2,R2,R4, LSL #+20
   \       0x6E   0x6804             LDR      R4,[R0, #+0]
   \       0x70   0xEA42 0x6203      ORR      R2,R2,R3, LSL #+24
   \       0x74   0xF04F 0x4320      MOV      R3,#+2684354560
   \       0x78   0xEB03 0x0584      ADD      R5,R3,R4, LSL #+2
   \       0x7C   0x430A             ORRS     R2,R1,R2
   \       0x7E   0x606A             STR      R2,[R5, #+4]
    229                      
    230              
    231            /* Bank1 NOR/SRAM timing register for write configuration, if extended mode is used */
    232            if(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode == FSMC_ExtendedMode_Enable)
   \       0x80   0x6AC3             LDR      R3,[R0, #+44]
   \       0x82   0x6801             LDR      R1,[R0, #+0]
   \       0x84   0x....             LDR.N    R2,??DataTable15
   \       0x86   0xF5B3 0x4F80      CMP      R3,#+16384
   \       0x8A   0xD110             BNE.N    ??FSMC_NORSRAMInit_1
    233            {
    234              assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime));
    235              assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime));
    236              assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime));
    237              assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision));
    238              assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency));
    239              assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode));
    240              FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
    241                        (uint32_t)FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime |
    242                        (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime << 4 )|
    243                        (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime << 8) |
    244                        (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision << 20) |
    245                        (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency << 24) |
    246                         FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode;
   \       0x8C   0x6B80             LDR      R0,[R0, #+56]
   \       0x8E   0x6803             LDR      R3,[R0, #+0]
   \       0x90   0x6844             LDR      R4,[R0, #+4]
   \       0x92   0x6885             LDR      R5,[R0, #+8]
   \       0x94   0xEA43 0x1304      ORR      R3,R3,R4, LSL #+4
   \       0x98   0x6904             LDR      R4,[R0, #+16]
   \       0x9A   0xEA43 0x2305      ORR      R3,R3,R5, LSL #+8
   \       0x9E   0x6945             LDR      R5,[R0, #+20]
   \       0xA0   0x6980             LDR      R0,[R0, #+24]
   \       0xA2   0xEA43 0x5304      ORR      R3,R3,R4, LSL #+20
   \       0xA6   0xEA43 0x6305      ORR      R3,R3,R5, LSL #+24
   \       0xAA   0x4303             ORRS     R3,R0,R3
   \       0xAC   0xE001             B.N      ??FSMC_NORSRAMInit_2
    247            }
    248            else
    249            {
    250              FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 0x0FFFFFFF;
   \                     ??FSMC_NORSRAMInit_1: (+1)
   \       0xAE   0xF06F 0x4370      MVN      R3,#+4026531840
   \                     ??FSMC_NORSRAMInit_2: (+1)
   \       0xB2   0xF842 0x3021      STR      R3,[R2, R1, LSL #+2]
    251            }
    252          }
   \       0xB6   0xBD30             POP      {R4,R5,PC}
    253          
    254          /**
    255            * @brief  Initializes the FSMC NAND Banks according to the specified 
    256            *         parameters in the FSMC_NANDInitStruct.
    257            * @param  FSMC_NANDInitStruct : pointer to a FSMC_NANDInitTypeDef 
    258            *         structure that contains the configuration information for the FSMC 
    259            *         NAND specified Banks.                       
    260            * @retval None
    261            */

   \                                 In section .text, align 2, keep-with-next
    262          void FSMC_NANDInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
    263          {
   \                     FSMC_NANDInit: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
    264            uint32_t tmppcr = 0x00000000, tmppmem = 0x00000000, tmppatt = 0x00000000; 
    265              
    266            /* Check the parameters */
    267            assert_param( IS_FSMC_NAND_BANK(FSMC_NANDInitStruct->FSMC_Bank));
    268            assert_param( IS_FSMC_WAIT_FEATURE(FSMC_NANDInitStruct->FSMC_Waitfeature));
    269            assert_param( IS_FSMC_MEMORY_WIDTH(FSMC_NANDInitStruct->FSMC_MemoryDataWidth));
    270            assert_param( IS_FSMC_ECC_STATE(FSMC_NANDInitStruct->FSMC_ECC));
    271            assert_param( IS_FSMC_ECCPAGE_SIZE(FSMC_NANDInitStruct->FSMC_ECCPageSize));
    272            assert_param( IS_FSMC_TCLR_TIME(FSMC_NANDInitStruct->FSMC_TCLRSetupTime));
    273            assert_param( IS_FSMC_TAR_TIME(FSMC_NANDInitStruct->FSMC_TARSetupTime));
    274            assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime));
    275            assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime));
    276            assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime));
    277            assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime));
    278            assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime));
    279            assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
    280            assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
    281            assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
    282            
    283            /* Set the tmppcr value according to FSMC_NANDInitStruct parameters */
    284            tmppcr = (uint32_t)FSMC_NANDInitStruct->FSMC_Waitfeature |
    285                      PCR_MemoryType_NAND |
    286                      FSMC_NANDInitStruct->FSMC_MemoryDataWidth |
    287                      FSMC_NANDInitStruct->FSMC_ECC |
    288                      FSMC_NANDInitStruct->FSMC_ECCPageSize |
    289                      (FSMC_NANDInitStruct->FSMC_TCLRSetupTime << 9 )|
    290                      (FSMC_NANDInitStruct->FSMC_TARSetupTime << 13);
   \        0x2   0x6843             LDR      R3,[R0, #+4]
   \        0x4   0x6881             LDR      R1,[R0, #+8]
   \        0x6   0x68C2             LDR      R2,[R0, #+12]
   \        0x8   0x430B             ORRS     R3,R1,R3
   \        0xA   0x6901             LDR      R1,[R0, #+16]
   \        0xC   0x4313             ORRS     R3,R2,R3
   \        0xE   0x6942             LDR      R2,[R0, #+20]
   \       0x10   0x430B             ORRS     R3,R1,R3
   \       0x12   0x6981             LDR      R1,[R0, #+24]
   \       0x14   0xEA43 0x2342      ORR      R3,R3,R2, LSL #+9
    291                      
    292            /* Set tmppmem value according to FSMC_CommonSpaceTimingStructure parameters */
    293            tmppmem = (uint32_t)FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
    294                      (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
    295                      (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
    296                      (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
   \       0x18   0x69C2             LDR      R2,[R0, #+28]
   \       0x1A   0x6854             LDR      R4,[R2, #+4]
   \       0x1C   0x6895             LDR      R5,[R2, #+8]
   \       0x1E   0xEA43 0x3341      ORR      R3,R3,R1, LSL #+13
   \       0x22   0x6811             LDR      R1,[R2, #+0]
   \       0x24   0x68D2             LDR      R2,[R2, #+12]
   \       0x26   0xEA41 0x2104      ORR      R1,R1,R4, LSL #+8
    297                      
    298            /* Set tmppatt value according to FSMC_AttributeSpaceTimingStructure parameters */
    299            tmppatt = (uint32_t)FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
    300                      (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
    301                      (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
    302                      (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);
   \       0x2A   0x6A04             LDR      R4,[R0, #+32]
    303            
    304            if(FSMC_NANDInitStruct->FSMC_Bank == FSMC_Bank2_NAND)
   \       0x2C   0x6800             LDR      R0,[R0, #+0]
   \       0x2E   0x68A6             LDR      R6,[R4, #+8]
   \       0x30   0xEA41 0x4105      ORR      R1,R1,R5, LSL #+16
   \       0x34   0xEA41 0x6102      ORR      R1,R1,R2, LSL #+24
   \       0x38   0x6822             LDR      R2,[R4, #+0]
   \       0x3A   0x6865             LDR      R5,[R4, #+4]
   \       0x3C   0x68E4             LDR      R4,[R4, #+12]
   \       0x3E   0xEA42 0x2205      ORR      R2,R2,R5, LSL #+8
   \       0x42   0xEA42 0x4206      ORR      R2,R2,R6, LSL #+16
   \       0x46   0xEA42 0x6204      ORR      R2,R2,R4, LSL #+24
   \       0x4A   0x2810             CMP      R0,#+16
   \       0x4C   0xF043 0x0308      ORR      R3,R3,#0x8
   \       0x50   0x....             LDR.N    R4,??DataTable15_1
   \       0x52   0xD103             BNE.N    ??FSMC_NANDInit_0
    305            {
    306              /* FSMC_Bank2_NAND registers configuration */
    307              FSMC_Bank2->PCR2 = tmppcr;
   \       0x54   0x6023             STR      R3,[R4, #+0]
    308              FSMC_Bank2->PMEM2 = tmppmem;
   \       0x56   0x60A1             STR      R1,[R4, #+8]
    309              FSMC_Bank2->PATT2 = tmppatt;
   \       0x58   0x60E2             STR      R2,[R4, #+12]
   \       0x5A   0xBD70             POP      {R4-R6,PC}
    310            }
    311            else
    312            {
    313              /* FSMC_Bank3_NAND registers configuration */
    314              FSMC_Bank3->PCR3 = tmppcr;
   \                     ??FSMC_NANDInit_0: (+1)
   \       0x5C   0x6223             STR      R3,[R4, #+32]
    315              FSMC_Bank3->PMEM3 = tmppmem;
   \       0x5E   0x62A1             STR      R1,[R4, #+40]
    316              FSMC_Bank3->PATT3 = tmppatt;
   \       0x60   0x62E2             STR      R2,[R4, #+44]
    317            }
    318          }
   \       0x62   0xBD70             POP      {R4-R6,PC}
    319          
    320          /**
    321            * @brief  Initializes the FSMC PCCARD Bank according to the specified 
    322            *         parameters in the FSMC_PCCARDInitStruct.
    323            * @param  FSMC_PCCARDInitStruct : pointer to a FSMC_PCCARDInitTypeDef
    324            *         structure that contains the configuration information for the FSMC 
    325            *         PCCARD Bank.                       
    326            * @retval None
    327            */

   \                                 In section .text, align 2, keep-with-next
    328          void FSMC_PCCARDInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
    329          {
   \                     FSMC_PCCARDInit: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
    330            /* Check the parameters */
    331            assert_param(IS_FSMC_WAIT_FEATURE(FSMC_PCCARDInitStruct->FSMC_Waitfeature));
    332            assert_param(IS_FSMC_TCLR_TIME(FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime));
    333            assert_param(IS_FSMC_TAR_TIME(FSMC_PCCARDInitStruct->FSMC_TARSetupTime));
    334           
    335            assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime));
    336            assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime));
    337            assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime));
    338            assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime));
    339            
    340            assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime));
    341            assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
    342            assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
    343            assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
    344            assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime));
    345            assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime));
    346            assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime));
    347            assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime));
    348            
    349            /* Set the PCR4 register value according to FSMC_PCCARDInitStruct parameters */
    350            FSMC_Bank4->PCR4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_Waitfeature |
    351                               FSMC_MemoryDataWidth_16b |  
    352                               (FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime << 9) |
    353                               (FSMC_PCCARDInitStruct->FSMC_TARSetupTime << 13);
   \        0x2   0x6802             LDR      R2,[R0, #+0]
   \        0x4   0x6843             LDR      R3,[R0, #+4]
   \        0x6   0x6884             LDR      R4,[R0, #+8]
   \        0x8   0x....             LDR.N    R1,??DataTable15_2
   \        0xA   0xEA42 0x2243      ORR      R2,R2,R3, LSL #+9
   \        0xE   0xEA42 0x3244      ORR      R2,R2,R4, LSL #+13
   \       0x12   0xF042 0x0210      ORR      R2,R2,#0x10
   \       0x16   0x600A             STR      R2,[R1, #+0]
    354                      
    355            /* Set PMEM4 register value according to FSMC_CommonSpaceTimingStructure parameters */
    356            FSMC_Bank4->PMEM4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
    357                                (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
    358                                (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
    359                                (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
   \       0x18   0x68C2             LDR      R2,[R0, #+12]
   \       0x1A   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_0: (+1)
   \       0x1E   0x608B             STR      R3,[R1, #+8]
    360                      
    361            /* Set PATT4 register value according to FSMC_AttributeSpaceTimingStructure parameters */
    362            FSMC_Bank4->PATT4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
    363                                (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
    364                                (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
    365                                (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);	
   \       0x20   0x6902             LDR      R2,[R0, #+16]
   \       0x22   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_1: (+1)
   \       0x26   0x60CB             STR      R3,[R1, #+12]
    366                      
    367            /* Set PIO4 register value according to FSMC_IOSpaceTimingStructure parameters */
    368            FSMC_Bank4->PIO4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime |
    369                               (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
    370                               (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
    371                               (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime << 24);             
   \       0x28   0x6940             LDR      R0,[R0, #+20]
   \       0x2A   0x6802             LDR      R2,[R0, #+0]
   \       0x2C   0x6843             LDR      R3,[R0, #+4]
   \       0x2E   0x6884             LDR      R4,[R0, #+8]
   \       0x30   0x68C0             LDR      R0,[R0, #+12]
   \       0x32   0xEA42 0x2203      ORR      R2,R2,R3, LSL #+8
   \       0x36   0xEA42 0x4204      ORR      R2,R2,R4, LSL #+16
   \       0x3A   0xEA42 0x6200      ORR      R2,R2,R0, LSL #+24
   \       0x3E   0x610A             STR      R2,[R1, #+16]
    372          }
   \       0x40   0xBD30             POP      {R4,R5,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \        0x0   0x6813             LDR      R3,[R2, #+0]
   \        0x2   0x6854             LDR      R4,[R2, #+4]
   \        0x4   0x6895             LDR      R5,[R2, #+8]
   \        0x6   0x68D2             LDR      R2,[R2, #+12]
   \        0x8   0xEA43 0x2304      ORR      R3,R3,R4, LSL #+8
   \        0xC   0xEA43 0x4305      ORR      R3,R3,R5, LSL #+16
   \       0x10   0xEA43 0x6302      ORR      R3,R3,R2, LSL #+24
   \       0x14   0x4770             BX       LR
    373          
    374          /**
    375            * @brief  Fills each FSMC_NORSRAMInitStruct member with its default value.
    376            * @param  FSMC_NORSRAMInitStruct: pointer to a FSMC_NORSRAMInitTypeDef 
    377            *         structure which will be initialized.
    378            * @retval None
    379            */

   \                                 In section .text, align 2, keep-with-next
    380          void FSMC_NORSRAMStructInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
    381          {  
   \                     FSMC_NORSRAMStructInit: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    382            /* Reset NOR/SRAM Init structure parameters values */
    383            FSMC_NORSRAMInitStruct->FSMC_Bank = FSMC_Bank1_NORSRAM1;
   \        0x2   0x2100             MOVS     R1,#+0
   \        0x4   0x6001             STR      R1,[R0, #+0]
    384            FSMC_NORSRAMInitStruct->FSMC_DataAddressMux = FSMC_DataAddressMux_Enable;
    385            FSMC_NORSRAMInitStruct->FSMC_MemoryType = FSMC_MemoryType_SRAM;
    386            FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
   \        0x6   0x60C1             STR      R1,[R0, #+12]
    387            FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;
   \        0x8   0x6101             STR      R1,[R0, #+16]
    388            FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait = FSMC_AsynchronousWait_Disable;
   \        0xA   0x6141             STR      R1,[R0, #+20]
    389            FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
   \        0xC   0x6181             STR      R1,[R0, #+24]
    390            FSMC_NORSRAMInitStruct->FSMC_WrapMode = FSMC_WrapMode_Disable;
   \        0xE   0x61C1             STR      R1,[R0, #+28]
    391            FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
   \       0x10   0x6201             STR      R1,[R0, #+32]
   \       0x12   0x2202             MOVS     R2,#+2
   \       0x14   0x6042             STR      R2,[R0, #+4]
    392            FSMC_NORSRAMInitStruct->FSMC_WriteOperation = FSMC_WriteOperation_Enable;
   \       0x16   0xF44F 0x5180      MOV      R1,#+4096
   \       0x1A   0x6241             STR      R1,[R0, #+36]
    393            FSMC_NORSRAMInitStruct->FSMC_WaitSignal = FSMC_WaitSignal_Enable;
   \       0x1C   0xF44F 0x5200      MOV      R2,#+8192
   \       0x20   0x6282             STR      R2,[R0, #+40]
   \       0x22   0x2300             MOVS     R3,#+0
    394            FSMC_NORSRAMInitStruct->FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
    395            FSMC_NORSRAMInitStruct->FSMC_WriteBurst = FSMC_WriteBurst_Disable;
    396            FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime = 0xF;
   \       0x24   0x6B41             LDR      R1,[R0, #+52]
   \       0x26   0x6083             STR      R3,[R0, #+8]
   \       0x28   0x62C3             STR      R3,[R0, #+44]
   \       0x2A   0x6303             STR      R3,[R0, #+48]
   \       0x2C   0x220F             MOVS     R2,#+15
   \       0x2E   0x600A             STR      R2,[R1, #+0]
    397            FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime = 0xF;
   \       0x30   0x230F             MOVS     R3,#+15
    398            FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime = 0xFF;
   \       0x32   0x22FF             MOVS     R2,#+255
    399            FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration = 0xF;
    400            FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision = 0xF;
    401            FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency = 0xF;
    402            FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode = FSMC_AccessMode_A; 
   \       0x34   0x2400             MOVS     R4,#+0
   \       0x36   0x604B             STR      R3,[R1, #+4]
   \       0x38   0x608A             STR      R2,[R1, #+8]
   \       0x3A   0x60CB             STR      R3,[R1, #+12]
   \       0x3C   0x610B             STR      R3,[R1, #+16]
   \       0x3E   0x614B             STR      R3,[R1, #+20]
   \       0x40   0x618C             STR      R4,[R1, #+24]
    403            FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime = 0xF;
   \       0x42   0x6B80             LDR      R0,[R0, #+56]
   \       0x44   0x6003             STR      R3,[R0, #+0]
    404            FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime = 0xF;
    405            FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime = 0xFF;
    406            FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_BusTurnAroundDuration = 0xF;
    407            FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision = 0xF;
    408            FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency = 0xF;
    409            FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode = FSMC_AccessMode_A;
   \       0x46   0x6184             STR      R4,[R0, #+24]
   \       0x48   0x6043             STR      R3,[R0, #+4]
   \       0x4A   0x6082             STR      R2,[R0, #+8]
   \       0x4C   0x60C3             STR      R3,[R0, #+12]
   \       0x4E   0x6103             STR      R3,[R0, #+16]
   \       0x50   0x6143             STR      R3,[R0, #+20]
    410          }
   \       0x52   0xBD10             POP      {R4,PC}
    411          
    412          /**
    413            * @brief  Fills each FSMC_NANDInitStruct member with its default value.
    414            * @param  FSMC_NANDInitStruct: pointer to a FSMC_NANDInitTypeDef 
    415            *         structure which will be initialized.
    416            * @retval None
    417            */

   \                                 In section .text, align 2, keep-with-next
    418          void FSMC_NANDStructInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
    419          { 
    420            /* Reset NAND Init structure parameters values */
    421            FSMC_NANDInitStruct->FSMC_Bank = FSMC_Bank2_NAND;
   \                     FSMC_NANDStructInit: (+1)
   \        0x0   0x2110             MOVS     R1,#+16
   \        0x2   0x6001             STR      R1,[R0, #+0]
    422            FSMC_NANDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
   \        0x4   0x2200             MOVS     R2,#+0
   \        0x6   0x6042             STR      R2,[R0, #+4]
    423            FSMC_NANDInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
   \        0x8   0x6082             STR      R2,[R0, #+8]
    424            FSMC_NANDInitStruct->FSMC_ECC = FSMC_ECC_Disable;
   \        0xA   0x60C2             STR      R2,[R0, #+12]
    425            FSMC_NANDInitStruct->FSMC_ECCPageSize = FSMC_ECCPageSize_256Bytes;
   \        0xC   0x6102             STR      R2,[R0, #+16]
    426            FSMC_NANDInitStruct->FSMC_TCLRSetupTime = 0x0;
   \        0xE   0x6142             STR      R2,[R0, #+20]
    427            FSMC_NANDInitStruct->FSMC_TARSetupTime = 0x0;
   \       0x10   0x6182             STR      R2,[R0, #+24]
    428            FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
   \       0x12   0x22FC             MOVS     R2,#+252
   \       0x14   0x69C1             LDR      R1,[R0, #+28]
   \       0x16   0x600A             STR      R2,[R1, #+0]
    429            FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
   \       0x18   0x604A             STR      R2,[R1, #+4]
    430            FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
   \       0x1A   0x608A             STR      R2,[R1, #+8]
    431            FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
   \       0x1C   0x60CA             STR      R2,[R1, #+12]
    432            FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
   \       0x1E   0x6A00             LDR      R0,[R0, #+32]
   \       0x20   0x....             B.N      ?Subroutine0
    433            FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
    434            FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
    435            FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	  
    436          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0x6002             STR      R2,[R0, #+0]
   \        0x2   0x6042             STR      R2,[R0, #+4]
   \        0x4   0x6082             STR      R2,[R0, #+8]
   \        0x6   0x60C2             STR      R2,[R0, #+12]
   \        0x8   0x4770             BX       LR
    437          
    438          /**
    439            * @brief  Fills each FSMC_PCCARDInitStruct member with its default value.
    440            * @param  FSMC_PCCARDInitStruct: pointer to a FSMC_PCCARDInitTypeDef 
    441            *         structure which will be initialized.
    442            * @retval None
    443            */

   \                                 In section .text, align 2, keep-with-next
    444          void FSMC_PCCARDStructInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
    445          {
    446            /* Reset PCCARD Init structure parameters values */
    447            FSMC_PCCARDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
   \                     FSMC_PCCARDStructInit: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x6001             STR      R1,[R0, #+0]
    448            FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime = 0x0;
   \        0x4   0x6041             STR      R1,[R0, #+4]
    449            FSMC_PCCARDInitStruct->FSMC_TARSetupTime = 0x0;
   \        0x6   0x6081             STR      R1,[R0, #+8]
    450            FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
   \        0x8   0x22FC             MOVS     R2,#+252
   \        0xA   0x68C1             LDR      R1,[R0, #+12]
   \        0xC   0x600A             STR      R2,[R1, #+0]
    451            FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
   \        0xE   0x604A             STR      R2,[R1, #+4]
    452            FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
   \       0x10   0x608A             STR      R2,[R1, #+8]
    453            FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
   \       0x12   0x60CA             STR      R2,[R1, #+12]
    454            FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
   \       0x14   0x6901             LDR      R1,[R0, #+16]
   \       0x16   0x600A             STR      R2,[R1, #+0]
    455            FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
   \       0x18   0x604A             STR      R2,[R1, #+4]
    456            FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
   \       0x1A   0x608A             STR      R2,[R1, #+8]
    457            FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	
   \       0x1C   0x60CA             STR      R2,[R1, #+12]
    458            FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime = 0xFC;
   \       0x1E   0x6940             LDR      R0,[R0, #+20]
   \       0x20                      REQUIRE ?Subroutine0
   \       0x20                      ;; // Fall through to label ?Subroutine0
    459            FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
    460            FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
    461            FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
    462          }
    463          
    464          /**
    465            * @brief  Enables or disables the specified NOR/SRAM Memory Bank.
    466            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    467            *   This parameter can be one of the following values:
    468            *     @arg FSMC_Bank1_NORSRAM1: FSMC Bank1 NOR/SRAM1  
    469            *     @arg FSMC_Bank1_NORSRAM2: FSMC Bank1 NOR/SRAM2 
    470            *     @arg FSMC_Bank1_NORSRAM3: FSMC Bank1 NOR/SRAM3 
    471            *     @arg FSMC_Bank1_NORSRAM4: FSMC Bank1 NOR/SRAM4 
    472            * @param  NewState: new state of the FSMC_Bank. This parameter can be: ENABLE or DISABLE.
    473            * @retval None
    474            */

   \                                 In section .text, align 2, keep-with-next
    475          void FSMC_NORSRAMCmd(uint32_t FSMC_Bank, FunctionalState NewState)
    476          {
    477            assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
    478            assert_param(IS_FUNCTIONAL_STATE(NewState));
    479            
    480            if (NewState != DISABLE)
   \                     FSMC_NORSRAMCmd: (+1)
   \        0x0   0xF04F 0x4220      MOV      R2,#+2684354560
   \        0x4   0xB131             CBZ.N    R1,??FSMC_NORSRAMCmd_0
    481            {
    482              /* Enable the selected NOR/SRAM Bank by setting the PBKEN bit in the BCRx register */
    483              FSMC_Bank1->BTCR[FSMC_Bank] |= BCR_MBKEN_Set;
   \        0x6   0xF852 0x1020      LDR      R1,[R2, R0, LSL #+2]
   \        0xA   0xF041 0x0101      ORR      R1,R1,#0x1
   \        0xE   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
   \       0x12   0x4770             BX       LR
    484            }
    485            else
    486            {
    487              /* Disable the selected NOR/SRAM Bank by clearing the PBKEN bit in the BCRx register */
    488              FSMC_Bank1->BTCR[FSMC_Bank] &= BCR_MBKEN_Reset;
   \                     ??FSMC_NORSRAMCmd_0: (+1)
   \       0x14   0xF852 0x3020      LDR      R3,[R2, R0, LSL #+2]
   \       0x18   0x....             LDR.N    R1,??DataTable15_3
   \       0x1A   0x400B             ANDS     R3,R1,R3
   \       0x1C   0xF842 0x3020      STR      R3,[R2, R0, LSL #+2]
    489            }
    490          }
   \       0x20   0x4770             BX       LR
    491          
    492          /**
    493            * @brief  Enables or disables the specified NAND Memory Bank.
    494            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    495            *   This parameter can be one of the following values:
    496            *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    497            *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
    498            * @param  NewState: new state of the FSMC_Bank. This parameter can be: ENABLE or DISABLE.
    499            * @retval None
    500            */

   \                                 In section .text, align 2, keep-with-next
    501          void FSMC_NANDCmd(uint32_t FSMC_Bank, FunctionalState NewState)
    502          {
    503            assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
    504            assert_param(IS_FUNCTIONAL_STATE(NewState));
    505            
    506            if (NewState != DISABLE)
   \                     FSMC_NANDCmd: (+1)
   \        0x0   0x....             LDR.N    R2,??DataTable15_1
   \        0x2   0xB159             CBZ.N    R1,??FSMC_NANDCmd_0
    507            {
    508              /* Enable the selected NAND Bank by setting the PBKEN bit in the PCRx register */
    509              if(FSMC_Bank == FSMC_Bank2_NAND)
   \        0x4   0x2810             CMP      R0,#+16
   \        0x6   0xD104             BNE.N    ??FSMC_NANDCmd_1
    510              {
    511                FSMC_Bank2->PCR2 |= PCR_PBKEN_Set;
   \        0x8   0x6810             LDR      R0,[R2, #+0]
   \        0xA   0xF040 0x0004      ORR      R0,R0,#0x4
   \        0xE   0x6010             STR      R0,[R2, #+0]
   \       0x10   0x4770             BX       LR
    512              }
    513              else
    514              {
    515                FSMC_Bank3->PCR3 |= PCR_PBKEN_Set;
   \                     ??FSMC_NANDCmd_1: (+1)
   \       0x12   0x6A10             LDR      R0,[R2, #+32]
   \       0x14   0xF040 0x0004      ORR      R0,R0,#0x4
   \       0x18   0x6210             STR      R0,[R2, #+32]
   \       0x1A   0x4770             BX       LR
    516              }
    517            }
    518            else
    519            {
    520              /* Disable the selected NAND Bank by clearing the PBKEN bit in the PCRx register */
    521              if(FSMC_Bank == FSMC_Bank2_NAND)
   \                     ??FSMC_NANDCmd_0: (+1)
   \       0x1C   0x2810             CMP      R0,#+16
   \       0x1E   0x....             LDR.N    R1,??DataTable15_4
   \       0x20   0xD100             BNE.N    ??FSMC_NANDCmd_2
    522              {
    523                FSMC_Bank2->PCR2 &= PCR_PBKEN_Reset;
   \       0x22   0x....             B.N      ?Subroutine2
    524              }
    525              else
    526              {
    527                FSMC_Bank3->PCR3 &= PCR_PBKEN_Reset;
   \                     ??FSMC_NANDCmd_2: (+1)
   \       0x24   0x....             B.N      ?Subroutine1
    528              }
    529            }
    530          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0x6810             LDR      R0,[R2, #+0]
   \        0x2   0x4001             ANDS     R1,R1,R0
   \        0x4   0x6011             STR      R1,[R2, #+0]
   \        0x6   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0x6A13             LDR      R3,[R2, #+32]
   \        0x2   0x4019             ANDS     R1,R1,R3
   \        0x4   0x6211             STR      R1,[R2, #+32]
   \        0x6   0x4770             BX       LR
    531          
    532          /**
    533            * @brief  Enables or disables the PCCARD Memory Bank.
    534            * @param  NewState: new state of the PCCARD Memory Bank.  
    535            *   This parameter can be: ENABLE or DISABLE.
    536            * @retval None
    537            */

   \                                 In section .text, align 2, keep-with-next
    538          void FSMC_PCCARDCmd(FunctionalState NewState)
    539          {
    540            assert_param(IS_FUNCTIONAL_STATE(NewState));
    541            
    542            if (NewState != DISABLE)
   \                     FSMC_PCCARDCmd: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable15_2
   \        0x2   0xB120             CBZ.N    R0,??FSMC_PCCARDCmd_0
    543            {
    544              /* Enable the PCCARD Bank by setting the PBKEN bit in the PCR4 register */
    545              FSMC_Bank4->PCR4 |= PCR_PBKEN_Set;
   \        0x4   0x6808             LDR      R0,[R1, #+0]
   \        0x6   0xF040 0x0004      ORR      R0,R0,#0x4
   \        0xA   0x6008             STR      R0,[R1, #+0]
   \        0xC   0x4770             BX       LR
    546            }
    547            else
    548            {
    549              /* Disable the PCCARD Bank by clearing the PBKEN bit in the PCR4 register */
    550              FSMC_Bank4->PCR4 &= PCR_PBKEN_Reset;
   \                     ??FSMC_PCCARDCmd_0: (+1)
   \        0xE   0x680A             LDR      R2,[R1, #+0]
   \       0x10   0x....             LDR.N    R0,??DataTable15_4
   \       0x12   0x4002             ANDS     R2,R0,R2
   \       0x14   0x600A             STR      R2,[R1, #+0]
    551            }
    552          }
   \       0x16   0x4770             BX       LR
    553          
    554          /**
    555            * @brief  Enables or disables the FSMC NAND ECC feature.
    556            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    557            *   This parameter can be one of the following values:
    558            *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    559            *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
    560            * @param  NewState: new state of the FSMC NAND ECC feature.  
    561            *   This parameter can be: ENABLE or DISABLE.
    562            * @retval None
    563            */

   \                                 In section .text, align 2, keep-with-next
    564          void FSMC_NANDECCCmd(uint32_t FSMC_Bank, FunctionalState NewState)
    565          {
    566            assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
    567            assert_param(IS_FUNCTIONAL_STATE(NewState));
    568            
    569            if (NewState != DISABLE)
   \                     FSMC_NANDECCCmd: (+1)
   \        0x0   0x....             LDR.N    R2,??DataTable15_1
   \        0x2   0xB159             CBZ.N    R1,??FSMC_NANDECCCmd_0
    570            {
    571              /* Enable the selected NAND Bank ECC function by setting the ECCEN bit in the PCRx register */
    572              if(FSMC_Bank == FSMC_Bank2_NAND)
   \        0x4   0x2810             CMP      R0,#+16
   \        0x6   0xD104             BNE.N    ??FSMC_NANDECCCmd_1
    573              {
    574                FSMC_Bank2->PCR2 |= PCR_ECCEN_Set;
   \        0x8   0x6810             LDR      R0,[R2, #+0]
   \        0xA   0xF040 0x0040      ORR      R0,R0,#0x40
   \        0xE   0x6010             STR      R0,[R2, #+0]
   \       0x10   0x4770             BX       LR
    575              }
    576              else
    577              {
    578                FSMC_Bank3->PCR3 |= PCR_ECCEN_Set;
   \                     ??FSMC_NANDECCCmd_1: (+1)
   \       0x12   0x6A10             LDR      R0,[R2, #+32]
   \       0x14   0xF040 0x0040      ORR      R0,R0,#0x40
   \       0x18   0x6210             STR      R0,[R2, #+32]
   \       0x1A   0x4770             BX       LR
    579              }
    580            }
    581            else
    582            {
    583              /* Disable the selected NAND Bank ECC function by clearing the ECCEN bit in the PCRx register */
    584              if(FSMC_Bank == FSMC_Bank2_NAND)
   \                     ??FSMC_NANDECCCmd_0: (+1)
   \       0x1C   0x2810             CMP      R0,#+16
   \       0x1E   0x....             LDR.N    R1,??DataTable15_5
   \       0x20   0xD100             BNE.N    ??FSMC_NANDECCCmd_2
    585              {
    586                FSMC_Bank2->PCR2 &= PCR_ECCEN_Reset;
   \       0x22   0x....             B.N      ?Subroutine2
    587              }
    588              else
    589              {
    590                FSMC_Bank3->PCR3 &= PCR_ECCEN_Reset;
   \                     ??FSMC_NANDECCCmd_2: (+1)
   \       0x24   0x....             B.N      ?Subroutine1
    591              }
    592            }
    593          }
    594          
    595          /**
    596            * @brief  Returns the error correction code register value.
    597            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    598            *   This parameter can be one of the following values:
    599            *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    600            *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
    601            * @retval The Error Correction Code (ECC) value.
    602            */

   \                                 In section .text, align 2, keep-with-next
    603          uint32_t FSMC_GetECC(uint32_t FSMC_Bank)
    604          {
    605            uint32_t eccval = 0x00000000;
    606            
    607            if(FSMC_Bank == FSMC_Bank2_NAND)
   \                     FSMC_GetECC: (+1)
   \        0x0   0x2810             CMP      R0,#+16
   \        0x2   0x....             LDR.N    R1,??DataTable15_6
   \        0x4   0xD101             BNE.N    ??FSMC_GetECC_0
    608            {
    609              /* Get the ECCR2 register value */
    610              eccval = FSMC_Bank2->ECCR2;
   \        0x6   0x6808             LDR      R0,[R1, #+0]
   \        0x8   0x4770             BX       LR
    611            }
    612            else
    613            {
    614              /* Get the ECCR3 register value */
    615              eccval = FSMC_Bank3->ECCR3;
   \                     ??FSMC_GetECC_0: (+1)
   \        0xA   0x6A08             LDR      R0,[R1, #+32]
    616            }
    617            /* Return the error correction code value */
    618            return(eccval);
   \        0xC   0x4770             BX       LR
    619          }
    620          
    621          /**
    622            * @brief  Enables or disables the specified FSMC interrupts.
    623            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    624            *   This parameter can be one of the following values:
    625            *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    626            *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
    627            *     @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
    628            * @param  FSMC_IT: specifies the FSMC interrupt sources to be enabled or disabled.
    629            *   This parameter can be any combination of the following values:
    630            *     @arg FSMC_IT_RisingEdge: Rising edge detection interrupt. 
    631            *     @arg FSMC_IT_Level: Level edge detection interrupt.
    632            *     @arg FSMC_IT_FallingEdge: Falling edge detection interrupt.
    633            * @param  NewState: new state of the specified FSMC interrupts.
    634            *   This parameter can be: ENABLE or DISABLE.
    635            * @retval None
    636            */

   \                                 In section .text, align 2, keep-with-next
    637          void FSMC_ITConfig(uint32_t FSMC_Bank, uint32_t FSMC_IT, FunctionalState NewState)
    638          {
    639            assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
    640            assert_param(IS_FSMC_IT(FSMC_IT));	
    641            assert_param(IS_FUNCTIONAL_STATE(NewState));
    642            
    643            if (NewState != DISABLE)
   \                     FSMC_ITConfig: (+1)
   \        0x0   0x....             LDR.N    R3,??DataTable15_7
   \        0x2   0xB16A             CBZ.N    R2,??FSMC_ITConfig_0
    644            {
    645              /* Enable the selected FSMC_Bank2 interrupts */
    646              if(FSMC_Bank == FSMC_Bank2_NAND)
   \        0x4   0x2810             CMP      R0,#+16
   \        0x6   0xD102             BNE.N    ??FSMC_ITConfig_1
    647              {
    648                FSMC_Bank2->SR2 |= FSMC_IT;
   \        0x8   0x6818             LDR      R0,[R3, #+0]
   \        0xA   0x4301             ORRS     R1,R1,R0
   \        0xC   0xE00D             B.N      ??FSMC_ITConfig_2
    649              }
    650              /* Enable the selected FSMC_Bank3 interrupts */
    651              else if (FSMC_Bank == FSMC_Bank3_NAND)
   \                     ??FSMC_ITConfig_1: (+1)
   \        0xE   0xF5B0 0x7F80      CMP      R0,#+256
   \       0x12   0xD102             BNE.N    ??FSMC_ITConfig_3
    652              {
    653                FSMC_Bank3->SR3 |= FSMC_IT;
   \       0x14   0x6A18             LDR      R0,[R3, #+32]
   \       0x16   0x4301             ORRS     R1,R1,R0
   \       0x18   0xE00E             B.N      ??FSMC_ITConfig_4
    654              }
    655              /* Enable the selected FSMC_Bank4 interrupts */
    656              else
    657              {
    658                FSMC_Bank4->SR4 |= FSMC_IT;    
   \                     ??FSMC_ITConfig_3: (+1)
   \       0x1A   0x6C18             LDR      R0,[R3, #+64]
   \       0x1C   0x4301             ORRS     R1,R1,R0
   \       0x1E   0xE00F             B.N      ??FSMC_ITConfig_5
    659              }
    660            }
    661            else
    662            {
    663              /* Disable the selected FSMC_Bank2 interrupts */
    664              if(FSMC_Bank == FSMC_Bank2_NAND)
   \                     ??FSMC_ITConfig_0: (+1)
   \       0x20   0x43C9             MVNS     R1,R1
   \       0x22   0x2810             CMP      R0,#+16
   \       0x24   0xD103             BNE.N    ??FSMC_ITConfig_6
    665              {
    666                
    667                FSMC_Bank2->SR2 &= (uint32_t)~FSMC_IT;
   \       0x26   0x6818             LDR      R0,[R3, #+0]
   \       0x28   0x4001             ANDS     R1,R1,R0
   \                     ??FSMC_ITConfig_2: (+1)
   \       0x2A   0x6019             STR      R1,[R3, #+0]
   \       0x2C   0x4770             BX       LR
    668              }
    669              /* Disable the selected FSMC_Bank3 interrupts */
    670              else if (FSMC_Bank == FSMC_Bank3_NAND)
   \                     ??FSMC_ITConfig_6: (+1)
   \       0x2E   0xF5B0 0x7F80      CMP      R0,#+256
   \       0x32   0xD103             BNE.N    ??FSMC_ITConfig_7
    671              {
    672                FSMC_Bank3->SR3 &= (uint32_t)~FSMC_IT;
   \       0x34   0x6A18             LDR      R0,[R3, #+32]
   \       0x36   0x4001             ANDS     R1,R1,R0
   \                     ??FSMC_ITConfig_4: (+1)
   \       0x38   0x6219             STR      R1,[R3, #+32]
   \       0x3A   0x4770             BX       LR
    673              }
    674              /* Disable the selected FSMC_Bank4 interrupts */
    675              else
    676              {
    677                FSMC_Bank4->SR4 &= (uint32_t)~FSMC_IT;    
   \                     ??FSMC_ITConfig_7: (+1)
   \       0x3C   0x6C18             LDR      R0,[R3, #+64]
   \       0x3E   0x4001             ANDS     R1,R1,R0
   \                     ??FSMC_ITConfig_5: (+1)
   \       0x40   0x6419             STR      R1,[R3, #+64]
    678              }
    679            }
    680          }
   \       0x42   0x4770             BX       LR
    681          
    682          /**
    683            * @brief  Checks whether the specified FSMC flag is set or not.
    684            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    685            *   This parameter can be one of the following values:
    686            *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    687            *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
    688            *     @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
    689            * @param  FSMC_FLAG: specifies the flag to check.
    690            *   This parameter can be one of the following values:
    691            *     @arg FSMC_FLAG_RisingEdge: Rising egde detection Flag.
    692            *     @arg FSMC_FLAG_Level: Level detection Flag.
    693            *     @arg FSMC_FLAG_FallingEdge: Falling egde detection Flag.
    694            *     @arg FSMC_FLAG_FEMPT: Fifo empty Flag. 
    695            * @retval The new state of FSMC_FLAG (SET or RESET).
    696            */

   \                                 In section .text, align 2, keep-with-next
    697          FlagStatus FSMC_GetFlagStatus(uint32_t FSMC_Bank, uint32_t FSMC_FLAG)
    698          {
   \                     FSMC_GetFlagStatus: (+1)
   \        0x0   0x4602             MOV      R2,R0
    699            FlagStatus bitstatus = RESET;
   \        0x2   0x2000             MOVS     R0,#+0
    700            uint32_t tmpsr = 0x00000000;
    701            
    702            /* Check the parameters */
    703            assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
    704            assert_param(IS_FSMC_GET_FLAG(FSMC_FLAG));
    705            
    706            if(FSMC_Bank == FSMC_Bank2_NAND)
   \        0x4   0x....             LDR.N    R3,??DataTable15_7
   \        0x6   0x2A10             CMP      R2,#+16
   \        0x8   0xBF08             IT       EQ
   \        0xA   0x681A             LDREQ    R2,[R3, #+0]
    707            {
    708              tmpsr = FSMC_Bank2->SR2;
   \        0xC   0xD004             BEQ.N    ??FSMC_GetFlagStatus_0
    709            }  
    710            else if(FSMC_Bank == FSMC_Bank3_NAND)
   \        0xE   0xF5B2 0x7F80      CMP      R2,#+256
   \       0x12   0xBF0C             ITE      EQ
   \       0x14   0x6A1A             LDREQ    R2,[R3, #+32]
   \       0x16   0x6C1A             LDRNE    R2,[R3, #+64]
    711            {
    712              tmpsr = FSMC_Bank3->SR3;
    713            }
    714            /* FSMC_Bank4_PCCARD*/
    715            else
    716            {
    717              tmpsr = FSMC_Bank4->SR4;
    718            } 
    719            
    720            /* Get the flag status */
    721            if ((tmpsr & FSMC_FLAG) != (uint16_t)RESET )
   \                     ??FSMC_GetFlagStatus_0: (+1)
   \       0x18   0x420A             TST      R2,R1
   \       0x1A   0xBF18             IT       NE
   \       0x1C   0x2001             MOVNE    R0,#+1
    722            {
    723              bitstatus = SET;
    724            }
    725            else
    726            {
    727              bitstatus = RESET;
    728            }
    729            /* Return the flag status */
    730            return bitstatus;
   \       0x1E   0x4770             BX       LR
    731          }
    732          
    733          /**
    734            * @brief  Clears the FSMC's pending flags.
    735            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    736            *   This parameter can be one of the following values:
    737            *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    738            *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
    739            *     @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
    740            * @param  FSMC_FLAG: specifies the flag to clear.
    741            *   This parameter can be any combination of the following values:
    742            *     @arg FSMC_FLAG_RisingEdge: Rising egde detection Flag.
    743            *     @arg FSMC_FLAG_Level: Level detection Flag.
    744            *     @arg FSMC_FLAG_FallingEdge: Falling egde detection Flag.
    745            * @retval None
    746            */

   \                                 In section .text, align 2, keep-with-next
    747          void FSMC_ClearFlag(uint32_t FSMC_Bank, uint32_t FSMC_FLAG)
    748          {
    749           /* Check the parameters */
    750            assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
    751            assert_param(IS_FSMC_CLEAR_FLAG(FSMC_FLAG)) ;
    752              
    753            if(FSMC_Bank == FSMC_Bank2_NAND)
   \                     FSMC_ClearFlag: (+1)
   \        0x0   0x43C9             MVNS     R1,R1
   \        0x2   0x2810             CMP      R0,#+16
   \        0x4   0x....             LDR.N    R2,??DataTable15_7
   \        0x6   0xD100             BNE.N    ??FSMC_ClearFlag_0
    754            {
    755              FSMC_Bank2->SR2 &= ~FSMC_FLAG; 
   \        0x8   0x....             B.N      ?Subroutine2
    756            }  
    757            else if(FSMC_Bank == FSMC_Bank3_NAND)
   \                     ??FSMC_ClearFlag_0: (+1)
   \        0xA   0xF5B0 0x7F80      CMP      R0,#+256
   \        0xE   0xD100             BNE.N    ??FSMC_ClearFlag_1
    758            {
    759              FSMC_Bank3->SR3 &= ~FSMC_FLAG;
   \       0x10   0x....             B.N      ?Subroutine4
    760            }
    761            /* FSMC_Bank4_PCCARD*/
    762            else
    763            {
    764              FSMC_Bank4->SR4 &= ~FSMC_FLAG;
   \                     ??FSMC_ClearFlag_1: (+1)
   \       0x12   0x....             B.N      ?Subroutine3
    765            }
    766          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \        0x0   0x6A10             LDR      R0,[R2, #+32]
   \        0x2   0x4001             ANDS     R1,R1,R0
   \        0x4   0x6211             STR      R1,[R2, #+32]
   \        0x6   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \        0x0   0x6C10             LDR      R0,[R2, #+64]
   \        0x2   0x4001             ANDS     R1,R1,R0
   \        0x4   0x6411             STR      R1,[R2, #+64]
   \        0x6   0x4770             BX       LR
    767          
    768          /**
    769            * @brief  Checks whether the specified FSMC interrupt has occurred or not.
    770            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    771            *   This parameter can be one of the following values:
    772            *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    773            *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
    774            *     @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
    775            * @param  FSMC_IT: specifies the FSMC interrupt source to check.
    776            *   This parameter can be one of the following values:
    777            *     @arg FSMC_IT_RisingEdge: Rising edge detection interrupt. 
    778            *     @arg FSMC_IT_Level: Level edge detection interrupt.
    779            *     @arg FSMC_IT_FallingEdge: Falling edge detection interrupt. 
    780            * @retval The new state of FSMC_IT (SET or RESET).
    781            */

   \                                 In section .text, align 2, keep-with-next
    782          ITStatus FSMC_GetITStatus(uint32_t FSMC_Bank, uint32_t FSMC_IT)
    783          {
   \                     FSMC_GetITStatus: (+1)
   \        0x0   0x4602             MOV      R2,R0
    784            ITStatus bitstatus = RESET;
   \        0x2   0x2000             MOVS     R0,#+0
    785            uint32_t tmpsr = 0x0, itstatus = 0x0, itenable = 0x0; 
    786            
    787            /* Check the parameters */
    788            assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
    789            assert_param(IS_FSMC_GET_IT(FSMC_IT));
    790            
    791            if(FSMC_Bank == FSMC_Bank2_NAND)
   \        0x4   0x....             LDR.N    R3,??DataTable15_7
   \        0x6   0x2A10             CMP      R2,#+16
   \        0x8   0xBF08             IT       EQ
   \        0xA   0x681B             LDREQ    R3,[R3, #+0]
    792            {
    793              tmpsr = FSMC_Bank2->SR2;
   \        0xC   0xD004             BEQ.N    ??FSMC_GetITStatus_0
    794            }  
    795            else if(FSMC_Bank == FSMC_Bank3_NAND)
   \        0xE   0xF5B2 0x7F80      CMP      R2,#+256
   \       0x12   0xBF0C             ITE      EQ
   \       0x14   0x6A1B             LDREQ    R3,[R3, #+32]
   \       0x16   0x6C1B             LDRNE    R3,[R3, #+64]
    796            {
    797              tmpsr = FSMC_Bank3->SR3;
    798            }
    799            /* FSMC_Bank4_PCCARD*/
    800            else
    801            {
    802              tmpsr = FSMC_Bank4->SR4;
    803            } 
    804            
    805            itstatus = tmpsr & FSMC_IT;
    806            
    807            itenable = tmpsr & (FSMC_IT >> 3);
   \                     ??FSMC_GetITStatus_0: (+1)
   \       0x18   0xEA03 0x02D1      AND      R2,R3,R1, LSR #+3
    808            if ((itstatus != (uint32_t)RESET)  && (itenable != (uint32_t)RESET))
   \       0x1C   0x420B             TST      R3,R1
   \       0x1E   0xBF1C             ITT      NE
   \       0x20   0x2A00             CMPNE    R2,#+0
   \       0x22   0x2001             MOVNE    R0,#+1
    809            {
    810              bitstatus = SET;
    811            }
    812            else
    813            {
    814              bitstatus = RESET;
    815            }
    816            return bitstatus; 
   \       0x24   0x4770             BX       LR
    817          }
    818          
    819          /**
    820            * @brief  Clears the FSMC's interrupt pending bits.
    821            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    822            *   This parameter can be one of the following values:
    823            *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    824            *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
    825            *     @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
    826            * @param  FSMC_IT: specifies the interrupt pending bit to clear.
    827            *   This parameter can be any combination of the following values:
    828            *     @arg FSMC_IT_RisingEdge: Rising edge detection interrupt. 
    829            *     @arg FSMC_IT_Level: Level edge detection interrupt.
    830            *     @arg FSMC_IT_FallingEdge: Falling edge detection interrupt.
    831            * @retval None
    832            */

   \                                 In section .text, align 2, keep-with-next
    833          void FSMC_ClearITPendingBit(uint32_t FSMC_Bank, uint32_t FSMC_IT)
    834          {
    835            /* Check the parameters */
    836            assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
    837            assert_param(IS_FSMC_IT(FSMC_IT));
    838              
    839            if(FSMC_Bank == FSMC_Bank2_NAND)
   \                     FSMC_ClearITPendingBit: (+1)
   \        0x0   0x2810             CMP      R0,#+16
   \        0x2   0xEA6F 0x01D1      MVN      R1,R1, LSR #+3
   \        0x6   0x....             LDR.N    R2,??DataTable15_7
   \        0x8   0xD100             BNE.N    ??FSMC_ClearITPendingBit_0
    840            {
    841              FSMC_Bank2->SR2 &= ~(FSMC_IT >> 3); 
   \        0xA   0x....             B.N      ?Subroutine2
    842            }  
    843            else if(FSMC_Bank == FSMC_Bank3_NAND)
   \                     ??FSMC_ClearITPendingBit_0: (+1)
   \        0xC   0xF5B0 0x7F80      CMP      R0,#+256
   \       0x10   0xD100             BNE.N    ??FSMC_ClearITPendingBit_1
    844            {
    845              FSMC_Bank3->SR3 &= ~(FSMC_IT >> 3);
   \       0x12   0x....             B.N      ?Subroutine4
    846            }
    847            /* FSMC_Bank4_PCCARD*/
    848            else
    849            {
    850              FSMC_Bank4->SR4 &= ~(FSMC_IT >> 3);
   \                     ??FSMC_ClearITPendingBit_1: (+1)
   \       0x14   0x....             B.N      ?Subroutine3
    851            }
    852          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \        0x0   0xA000'0104        DC32     0xa0000104

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \        0x0   0xA000'0060        DC32     0xa0000060

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \        0x0   0xA000'00A0        DC32     0xa00000a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_3:
   \        0x0   0x000F'FFFE        DC32     0xffffe

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_4:
   \        0x0   0x000F'FFFB        DC32     0xffffb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_5:
   \        0x0   0x000F'FFBF        DC32     0xfffbf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_6:
   \        0x0   0xA000'0074        DC32     0xa0000074

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_7:
   \        0x0   0xA000'0064        DC32     0xa0000064
    853          
    854          /**
    855            * @}
    856            */ 
    857          
    858          /**
    859            * @}
    860            */
    861          
    862          /**
    863            * @}
    864            */
    865          
    866          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   FSMC_ClearFlag
       0   FSMC_ClearITPendingBit
       0   FSMC_GetECC
       0   FSMC_GetFlagStatus
       0   FSMC_GetITStatus
       0   FSMC_ITConfig
       0   FSMC_NANDCmd
       0   FSMC_NANDDeInit
       0   FSMC_NANDECCCmd
      16   FSMC_NANDInit
       0   FSMC_NANDStructInit
       0   FSMC_NORSRAMCmd
       8   FSMC_NORSRAMDeInit
      12   FSMC_NORSRAMInit
       8   FSMC_NORSRAMStructInit
       0   FSMC_PCCARDCmd
       0   FSMC_PCCARDDeInit
      12   FSMC_PCCARDInit
       0   FSMC_PCCARDStructInit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable15_4
       4  ??DataTable15_5
       4  ??DataTable15_6
       4  ??DataTable15_7
      10  ?Subroutine0
       8  ?Subroutine1
       8  ?Subroutine2
       8  ?Subroutine3
       8  ?Subroutine4
      22  ?Subroutine5
      20  FSMC_ClearFlag
      22  FSMC_ClearITPendingBit
      14  FSMC_GetECC
      32  FSMC_GetFlagStatus
      38  FSMC_GetITStatus
      68  FSMC_ITConfig
      38  FSMC_NANDCmd
      40  FSMC_NANDDeInit
      38  FSMC_NANDECCCmd
     100  FSMC_NANDInit
      34  FSMC_NANDStructInit
      34  FSMC_NORSRAMCmd
      48  FSMC_NORSRAMDeInit
     184  FSMC_NORSRAMInit
      84  FSMC_NORSRAMStructInit
      24  FSMC_PCCARDCmd
      24  FSMC_PCCARDDeInit
      66  FSMC_PCCARDInit
      32  FSMC_PCCARDStructInit

 
 1'036 bytes in section .text
 
 1'036 bytes of CODE memory

Errors: none
Warnings: none
