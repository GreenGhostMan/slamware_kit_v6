###############################################################################
#
# IAR ANSI C/C++ Compiler V9.10.2.313/W64 for ARM         28/Jul/2021  15:57:30
# Copyright 1999-2021 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\src\drv\sonar.c
#    Command line                 =
#        -f
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\Release_Rev6\List\drv\sonar.lst.rsp
#        (C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\src\drv\sonar.c
#        -D USE_STDPERIPH_DRIVER -D STM32F10X_HD -D USART_ENABLE_USART3 -D
#        CONFIG_BREAKOUT_REV=6 -D USE_FRONT_IR_SENSORS -D FEATURE_SET_V -lCN
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\Release_Rev6\List\drv
#        --diag_suppress Pa050 -o
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\Release_Rev6\Obj\drv
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        9.0\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\src\
#        -I
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\..\..\common\inc\
#        -I
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\..\infra_pub\
#        -I
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\..\infra_pub\arch\st_fwlib\CMSIS\CM3\CoreSupport\
#        -I
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\..\infra_pub\arch\st_fwlib\CMSIS\CM3\DeviceSupport\ST\STM32F10x\
#        -I
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\..\infra_pub\arch\st_fwlib\STM32F10x_StdPeriph_Driver\inc\
#        -I
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\..\infra_pub\arch\infra_stm32\
#        -I
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\..\infra_pub\arch\infra_stm32\32f10x\
#        -Ohz --use_c++_inline) --dependencies=n
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\Release_Rev6\Obj\drv\sonar.o.d
#    Locale                       =  C
#    List file                    =
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\Release_Rev6\List\drv\sonar.lst
#    Object file                  =
#        C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\Release_Rev6\Obj\drv\sonar.o
#    Runtime model:                  
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  0
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#
###############################################################################

C:\Users\linux\Desktop\SLAMWARE\breakoutBoardVersion6ReferenceCode\slamwarekit_reference_v6_code.20181120\slamwarekit_reference_v6_code.20181120\base_ref\src\drv\sonar.c
      1          /*
      2           * SlamTec Base Ref Design
      3           * Copyright 2009 - 2017 RoboPeak
      4           * Copyright 2013 - 2017 Shanghai SlamTec Co., Ltd.
      5           * http://www.slamtec.com
      6           * All rights reserved.
      7           */
      8          /*
      9           * Redistribution and use in source and binary forms, with or without modification,
     10           * are permitted provided that the following conditions are met:
     11           *
     12           * 1. Redistributions of source code must retain the above copyright notice,
     13           *    this list of conditions and the following disclaimer.
     14           *
     15           * 2. Redistributions in binary form must reproduce the above copyright notice,
     16           *    this list of conditions and the following disclaimer in the documentation
     17           *    and/or other materials provided with the distribution.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
     20           * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
     21           * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
     22           * SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
     23           * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
     24           * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
     25           * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
     26           * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     27           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     28           *
     29           */
     30          
     31          #include "common/common.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __softfp void pinMode(GPIO_TypeDef *, uint16_t, GPIOMode_TypeDef, GPIOSpeed_TypeDef)
   \                     pinMode: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0xF8AD 0x1000      STRH     R1,[SP, #+0]
   \        0x6   0xF88D 0x3002      STRB     R3,[SP, #+2]
   \        0xA   0xF88D 0x2003      STRB     R2,[SP, #+3]
   \        0xE   0x4669             MOV      R1,SP
   \       0x10   0x.... 0x....      BL       GPIO_Init
   \       0x14   0xBD01             POP      {R0,PC}
     32          #include "utils/filters.h"
     33          #include "drv/gpio.h"
     34          #include "drv/led.h"
     35          #include "sonar.h"
     36          
     37          #if defined(CONFIG_BREAKOUT_REV) && (CONFIG_BREAKOUT_REV >= 3)
     38          /**
     39           @defgroup  sonar ultrasonic sonar module.
     40           @addtogroup drivers
     41           @{
     42          
     43            Resource consumption: GPIOE 5, 7 ~ 12, 15.
     44            EXTI line 5,7,8,9 with interrupt.
     45            TIM6 as counter timer.
     46           */
     47          
     48          #define sonar_dbg(fmt, args...)     DBG_OUT("[sonar]: " fmt, ##args)
     49          
     50          #define EXTI_LINE(l)        (EXTI_Line0 << (l))
     51          
     52          #define SONAR_TIMER         TIM6
     53          

   \                                 In section .bss, align 1
     54          static uint8_t g_sonar_ch = 0;  /**< Active sonar channel index. */
   \                     g_sonar_ch:
   \        0x0                      DS8 1
     55          
     56          /**
     57           @brief Global sonar channel descriptors.
     58           */

   \                                 In section .bss, align 4
     59          static sonar_channel_t g_sonar[CONFIG_SONAR_CHANNEL_NUM];
   \                     g_sonar:
   \        0x0                      DS8 80
     60          
     61          /**
     62           @brief Global sonar channel configurations.
     63           */

   \                                 In section .rodata, align 4
     64          static const sonar_cfg_t g_sonar_cfg[CONFIG_SONAR_CHANNEL_NUM] = {
   \                     g_sonar_cfg:
   \        0x0   0x4001'1800        DC32 0x4001'1800
   \        0x4   0x0400             DC16 1'024
   \        0x6                      DS8 2
   \        0x8   0x4001'1800        DC32 0x4001'1800
   \        0xC   0x0020             DC16 32
   \        0xE                      DS8 2
   \       0x10   0x0000'0005        DC32 5, 0x4001'1800

   \              0x4001'1800
   \       0x18   0x0800             DC16 2'048
   \       0x1A                      DS8 2
   \       0x1C   0x4001'1800        DC32 0x4001'1800
   \       0x20   0x0080             DC16 128
   \       0x22                      DS8 2
   \       0x24   0x0000'0007        DC32 7, 0x4001'1800

   \              0x4001'1800
   \       0x2C   0x1000             DC16 4'096
   \       0x2E                      DS8 2
   \       0x30   0x4001'1800        DC32 0x4001'1800
   \       0x34   0x0100             DC16 256
   \       0x36                      DS8 2
   \       0x38   0x0000'0008        DC32 8, 0x4001'1800

   \              0x4001'1800
   \       0x40   0x8000             DC16 32'768
   \       0x42                      DS8 2
   \       0x44   0x4001'1800        DC32 0x4001'1800
   \       0x48   0x0200             DC16 512
   \       0x4A                      DS8 2
   \       0x4C   0x0000'0009        DC32 9
     65              {SONAR_TRIG1_PORT, SONAR_TRIG1_PIN, SONAR_ECHO1_PORT, SONAR_ECHO1_PIN, 5},
     66              {SONAR_TRIG2_PORT, SONAR_TRIG2_PIN, SONAR_ECHO2_PORT, SONAR_ECHO2_PIN, 7},
     67              {SONAR_TRIG3_PORT, SONAR_TRIG3_PIN, SONAR_ECHO3_PORT, SONAR_ECHO3_PIN, 8},
     68              {SONAR_TRIG4_PORT, SONAR_TRIG4_PIN, SONAR_ECHO4_PORT, SONAR_ECHO4_PIN, 9},
     69          };
     70          
     71          /**
     72           @brief Sonar echo read.
     73           @param ch    - sonar channel index, 0 ~ CONFIG_SONAR_CHANNEL_NUM.
     74           @return none.
     75           */
     76          static inline uint8_t SONAR_ECHO(uint8_t ch)
     77          {
     78              return GPIO_ReadInputDataBit(g_sonar_cfg[ch].echo_port, g_sonar_cfg[ch].echo_pin);
     79          }
     80          
     81          /**
     82           @brief Sonar trigger function.
     83           @param ch    - sonar channel index, 1 ~ CONFIG_SONAR_CHANNEL_NUM-1.
     84           @param level - sonar trigger level.
     85           @return none.
     86           */

   \                                 In section .text, align 2, keep-with-next
     87          static inline void SONAR_TRIG(uint8_t ch, uint8_t level)
     88          {
     89              if (level == HIGH) {
   \                     SONAR_TRIG: (+1)
   \        0x0   0x2214             MOVS     R2,#+20
   \        0x2   0x4350             MULS     R0,R2,R0
   \        0x4   0x....             LDR.N    R2,??DataTable8
   \        0x6   0x1813             ADDS     R3,R2,R0
   \        0x8   0x2901             CMP      R1,#+1
   \        0xA   0x8899             LDRH     R1,[R3, #+4]
   \        0xC   0x5810             LDR      R0,[R2, R0]
   \        0xE   0xBF08             IT       EQ
     90                  GPIO_SetBits(g_sonar_cfg[ch].trig_port, g_sonar_cfg[ch].trig_pin);
   \       0x10   0x.... 0x....      BEQ.W    GPIO_SetBits
     91              } else {
     92                  GPIO_ResetBits(g_sonar_cfg[ch].trig_port, g_sonar_cfg[ch].trig_pin);
   \       0x14   0x.... 0x....      B.W      GPIO_ResetBits
     93              }
     94          }
     95          
     96          /**
     97           @brief Trigger a sonar channel.
     98           @param ch - channel number to be triggered, 1 ~ CONFIG_SONAR_CHANNEL_NUM.
     99           @return none.
    100          
    101           */
    102          static void sonar_trigger(uint8_t ch)
    103          {
    104              EXTI_InitTypeDef exti;
    105          
    106              if (ch >= CONFIG_SONAR_CHANNEL_NUM) {
    107                  return ;
    108              }
    109          
    110              /* Send trigger wave. */
    111              SONAR_TRIG(ch, HIGH);
    112              _delay_us(20);
    113              SONAR_TRIG(ch, LOW);
    114          
    115              /* Prepare for echo rising edge interrupt. */
    116              GPIO_EXTILineConfig(GPIO_PortSourceGPIOE, g_sonar_cfg[ch].exti_line);
    117          
    118              /* Configure EXTI lines. */
    119              exti.EXTI_Mode    = EXTI_Mode_Interrupt;
    120              exti.EXTI_Trigger = EXTI_Trigger_Rising_Falling;
    121              exti.EXTI_LineCmd = ENABLE;
    122              exti.EXTI_Line    = EXTI_LINE(g_sonar_cfg[ch].exti_line);
    123              EXTI_Init(&exti);
    124              return ;
    125          }
    126          
    127          /**
    128           @brief Shutdown a sonar channel.
    129           @param ch - channel number to be shutdown, 0 ~ CONFIG_SONAR_CHANNEL_NUM.
    130           @return none.
    131          
    132           */

   \                                 In section .text, align 2, keep-with-next
    133          static void sonar_shutdown(uint8_t ch)
    134          {
   \                     sonar_shutdown: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
    135              EXTI_InitTypeDef exti;
    136          
    137              if (ch >= CONFIG_SONAR_CHANNEL_NUM) {
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x2C04             CMP      R4,#+4
   \        0x6   0xDA15             BGE.N    ??sonar_shutdown_0
    138                  return ;
    139              }
    140          
    141              SONAR_TRIG(ch, LOW);
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0x.... 0x....      BL       SONAR_TRIG
    142          
    143              /* Configure EXTI lines. */
    144              exti.EXTI_Mode    = EXTI_Mode_Interrupt;
    145              exti.EXTI_Trigger = EXTI_Trigger_Rising_Falling;  
   \        0xE   0x2110             MOVS     R1,#+16
   \       0x10   0x2200             MOVS     R2,#+0
   \       0x12   0xF88D 0x1005      STRB     R1,[SP, #+5]
   \       0x16   0xF88D 0x2004      STRB     R2,[SP, #+4]
    146              exti.EXTI_LineCmd = DISABLE;
   \       0x1A   0xF88D 0x2006      STRB     R2,[SP, #+6]
    147              exti.EXTI_Line    = EXTI_LINE(g_sonar_cfg[ch].exti_line);
   \       0x1E   0x2114             MOVS     R1,#+20
   \       0x20   0x....             LDR.N    R2,??DataTable8
   \       0x22   0x434C             MULS     R4,R1,R4
   \       0x24   0x1911             ADDS     R1,R2,R4
   \       0x26   0x2301             MOVS     R3,#+1
   \       0x28   0x6908             LDR      R0,[R1, #+16]
   \       0x2A   0x4083             LSLS     R3,R3,R0
   \       0x2C   0x9300             STR      R3,[SP, #+0]
    148              EXTI_Init(&exti);
   \       0x2E   0x4668             MOV      R0,SP
   \       0x30   0x.... 0x....      BL       EXTI_Init
    149              return ;
   \                     ??sonar_shutdown_0: (+1)
   \       0x34   0xBD13             POP      {R0,R1,R4,PC}
    150          }
    151          
    152          /**
    153           @brief Calculate sonar distance by sample value.
    154           @param ch - sonar channel, 0 ~ CONFIG_SONAR_CHANNEL_NUM
    155           @return none.
    156          
    157           This distance is in mm. 
    158           */

   \                                 In section .text, align 2, keep-with-next
    159          static void sonar_distance(uint8_t ch)
    160          {
   \                     sonar_distance: (+1)
   \        0x0   0x2804             CMP      R0,#+4
   \        0x2   0xDB00             BLT.N    ??sonar_distance_0
   \        0x4   0x4770             BX       LR
   \                     ??sonar_distance_0: (+1)
   \        0x6   0xB5F8             PUSH     {R3-R7,LR}
    161              uint8_t  i;
    162              uint32_t avg;
    163              float    d;
    164          
    165              if (ch >= CONFIG_SONAR_CHANNEL_NUM) {
    166                  return ;
    167              }
    168          
    169              avg = 0;
    170              for (i = 0; i < g_sonar[ch].cnt; i++) {
   \        0x8   0x....             LDR.N    R4,??DataTable8_1
   \        0xA   0x....             LDR.N    R5,??DataTable8_2
   \        0xC   0x7826             LDRB     R6,[R4, #+0]
   \        0xE   0x2314             MOVS     R3,#+20
   \       0x10   0x435E             MULS     R6,R3,R6
   \       0x12   0x2200             MOVS     R2,#+0
   \       0x14   0x2100             MOVS     R1,#+0
   \       0x16   0x19AC             ADDS     R4,R5,R6
   \       0x18   0xE004             B.N      ??sonar_distance_1
    171                  avg += g_sonar[g_sonar_ch].sample[i];
   \                     ??sonar_distance_2: (+1)
   \       0x1A   0xEB04 0x0741      ADD      R7,R4,R1, LSL #+1
    172              }
   \       0x1E   0x1C49             ADDS     R1,R1,#+1
   \       0x20   0x88BE             LDRH     R6,[R7, #+4]
   \       0x22   0x18B2             ADDS     R2,R6,R2
   \                     ??sonar_distance_1: (+1)
   \       0x24   0xFB03 0xF600      MUL      R6,R3,R0
   \       0x28   0x442E             ADD      R6,R5,R6
   \       0x2A   0x78B6             LDRB     R6,[R6, #+2]
   \       0x2C   0x42B1             CMP      R1,R6
   \       0x2E   0xDBF4             BLT.N    ??sonar_distance_2
    173              if (i > 0) {
   \       0x30   0xB181             CBZ.N    R1,??sonar_distance_3
    174                  avg /= i;
   \       0x32   0xFBB2 0xF0F1      UDIV     R0,R2,R1
   \       0x36   0x0840             LSRS     R0,R0,#+1
   \       0x38   0x.... 0x....      BL       __aeabi_ui2d
   \       0x3C   0x2200             MOVS     R2,#+0
   \       0x3E   0x....             LDR.N    R3,??DataTable8_3
   \       0x40   0x.... 0x....      BL       __aeabi_ddiv
   \       0x44   0x4602             MOV      R2,R0
   \       0x46   0x460B             MOV      R3,R1
   \       0x48   0xF04F 0x4020      MOV      R0,#+2684354560
   \       0x4C   0x....             LDR.N    R1,??DataTable8_4
   \       0x4E   0x.... 0x....      BL       __aeabi_dmul
   \       0x52   0xE000             B.N      ??sonar_distance_4
    175              } else {
    176                  avg = 0;
   \                     ??sonar_distance_3: (+1)
   \       0x54   0x2000             MOVS     R0,#+0
    177              }
    178          
    179              d = CONFIG_SONAR_COE_A + CONFIG_SONAR_COE_B * CONFIG_SONAR_COE_T;
    180              d *= avg / 2 / 1000.0;
    181          #ifdef CONFIG_SONAR_DISTANCE_Q16
    182              g_sonar[g_sonar_ch].distance = (uint32_t)FP_Q16(d);
    183          #else
    184              g_sonar[g_sonar_ch].distance = (uint32_t)d;
   \                     ??sonar_distance_4: (+1)
   \       0x56   0x.... 0x....      BL       __aeabi_d2f
   \       0x5A   0x.... 0x....      BL       __aeabi_f2uiz
   \       0x5E   0x6120             STR      R0,[R4, #+16]
    185          #endif
    186          }
   \       0x60   0xBDF1             POP      {R0,R4-R7,PC}
    187          
    188          /**
    189           @brief external line interrupt handler.
    190           @param none.
    191           @return none.
    192           */

   \                                 In section .text, align 2, keep-with-next
    193          void EXTI9_5_IRQHandler(void)
    194          {
   \                     EXTI9_5_IRQHandler: (+1)
   \        0x0   0xE92D 0x41FF      PUSH     {R0-R8,LR}
    195              uint8_t  id;
    196              uint8_t  status;
    197              uint32_t line;
    198              TIM_TimeBaseInitTypeDef tim_base;
    199          
    200              /* Get EXTI for the active channel. */
    201              line = EXTI_LINE(g_sonar_cfg[g_sonar_ch].exti_line);
   \        0x4   0x....             LDR.N    R6,??DataTable8_1
   \        0x6   0x....             LDR.N    R4,??DataTable8
   \        0x8   0x7832             LDRB     R2,[R6, #+0]
   \        0xA   0x2514             MOVS     R5,#+20
   \        0xC   0x436A             MULS     R2,R5,R2
   \        0xE   0x4422             ADD      R2,R4,R2
   \       0x10   0x2101             MOVS     R1,#+1
   \       0x12   0x6917             LDR      R7,[R2, #+16]
   \       0x14   0xFA01 0xF707      LSL      R7,R1,R7
    202              if (EXTI_GetITStatus(line) != RESET) {
   \       0x18   0x4638             MOV      R0,R7
   \       0x1A   0x.... 0x....      BL       EXTI_GetITStatus
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD049             BEQ.N    ??EXTI9_5_IRQHandler_0
    203                  EXTI_ClearITPendingBit(line);
   \       0x22   0x4638             MOV      R0,R7
   \       0x24   0x.... 0x....      BL       EXTI_ClearITPendingBit
    204          
    205                  status = SONAR_ECHO(g_sonar_ch);
    206                  if (status == HIGH) {
   \       0x28   0x7830             LDRB     R0,[R6, #+0]
   \       0x2A   0x.... 0x....      LDR.W    R8,??DataTable8_5
   \       0x2E   0x4368             MULS     R0,R5,R0
   \       0x30   0x4420             ADD      R0,R4,R0
   \       0x32   0x8981             LDRH     R1,[R0, #+12]
   \       0x34   0x6880             LDR      R0,[R0, #+8]
   \       0x36   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \       0x3A   0x2801             CMP      R0,#+1
   \       0x3C   0xD11C             BNE.N    ??EXTI9_5_IRQHandler_1
    207                      RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM6, ENABLE);
   \       0x3E   0x2101             MOVS     R1,#+1
   \       0x40   0x2010             MOVS     R0,#+16
   \       0x42   0x.... 0x....      BL       RCC_APB1PeriphClockCmd
    208                      /* Start counter timer. */
    209                      tim_base.TIM_Period = 60000;
   \       0x46   0xF64E 0x2160      MOVW     R1,#+60000
   \       0x4A   0xF8AD 0x1004      STRH     R1,[SP, #+4]
    210                      tim_base.TIM_Prescaler = (SYSTICK_1MS_TICKS/1000-1);
   \       0x4E   0x2247             MOVS     R2,#+71
    211                      tim_base.TIM_ClockDivision = TIM_CKD_DIV1;
   \       0x50   0x2100             MOVS     R1,#+0
   \       0x52   0xF8AD 0x1006      STRH     R1,[SP, #+6]
    212                      tim_base.TIM_CounterMode = TIM_CounterMode_Up;
   \       0x56   0xF8AD 0x1002      STRH     R1,[SP, #+2]
   \       0x5A   0xF8AD 0x2000      STRH     R2,[SP, #+0]
    213          
    214                      TIM_TimeBaseInit(SONAR_TIMER, &tim_base);
   \       0x5E   0x4669             MOV      R1,SP
   \       0x60   0x4640             MOV      R0,R8
   \       0x62   0x.... 0x....      BL       TIM_TimeBaseInit
    215                      TIM_SetCounter(SONAR_TIMER, 0);
   \       0x66   0x2100             MOVS     R1,#+0
   \       0x68   0x4640             MOV      R0,R8
   \       0x6A   0x.... 0x....      BL       TIM_SetCounter
    216                      TIM_Cmd(SONAR_TIMER, ENABLE);
   \       0x6E   0x2101             MOVS     R1,#+1
   \       0x70   0x4640             MOV      R0,R8
   \       0x72   0x.... 0x....      BL       TIM_Cmd
   \       0x76   0xE01E             B.N      ??EXTI9_5_IRQHandler_0
    217                  } else {
    218                      /* Stop counter timer. */
    219                      TIM_Cmd(SONAR_TIMER, DISABLE);
   \                     ??EXTI9_5_IRQHandler_1: (+1)
   \       0x78   0x2100             MOVS     R1,#+0
   \       0x7A   0x4640             MOV      R0,R8
   \       0x7C   0x.... 0x....      BL       TIM_Cmd
    220          
    221                      id = g_sonar[g_sonar_ch].id;
   \       0x80   0x7831             LDRB     R1,[R6, #+0]
   \       0x82   0x....             LDR.N    R7,??DataTable8_2
   \       0x84   0x1C78             ADDS     R0,R7,#+1
   \       0x86   0x4369             MULS     R1,R5,R1
   \       0x88   0x5C44             LDRB     R4,[R0, R1]
    222                      if (id >= CONFIG_SONAR_SAMPLE_SIZE) {
   \       0x8A   0x2C04             CMP      R4,#+4
   \       0x8C   0xBFA8             IT       GE
   \       0x8E   0x2400             MOVGE    R4,#+0
    223                          id = 0;
    224                      }
    225                      g_sonar[g_sonar_ch].sample[id++] = TIM_GetCounter(SONAR_TIMER);
   \       0x90   0x4640             MOV      R0,R8
   \       0x92   0x.... 0x....      BL       TIM_GetCounter
   \       0x96   0x7831             LDRB     R1,[R6, #+0]
   \       0x98   0x434D             MULS     R5,R5,R1
   \       0x9A   0x1979             ADDS     R1,R7,R5
   \       0x9C   0xEB01 0x0344      ADD      R3,R1,R4, LSL #+1
    226                      g_sonar[g_sonar_ch].state++;    /* Move to next state. */
    227                      g_sonar[g_sonar_ch].id = id;
   \       0xA0   0x1C64             ADDS     R4,R4,#+1
   \       0xA2   0x8098             STRH     R0,[R3, #+4]
   \       0xA4   0x7808             LDRB     R0,[R1, #+0]
   \       0xA6   0x1C40             ADDS     R0,R0,#+1
   \       0xA8   0x7008             STRB     R0,[R1, #+0]
   \       0xAA   0x704C             STRB     R4,[R1, #+1]
    228                      if (g_sonar[g_sonar_ch].cnt < CONFIG_SONAR_SAMPLE_SIZE) {
   \       0xAC   0x7888             LDRB     R0,[R1, #+2]
   \       0xAE   0x2804             CMP      R0,#+4
   \       0xB0   0xBFBC             ITT      LT
   \       0xB2   0x1C40             ADDLT    R0,R0,#+1
   \       0xB4   0x7088             STRBLT   R0,[R1, #+2]
    229                          g_sonar[g_sonar_ch].cnt++;
    230                      }
    231                  }
    232              }
    233          }
   \                     ??EXTI9_5_IRQHandler_0: (+1)
   \       0xB6   0xE8BD 0x81FF      POP      {R0-R8,PC}
    234          
    235          /**
    236           @brief ultrasonic sonar module heartbeat.
    237           @param None.
    238           @return None.
    239                      ___                                                         ___
    240           TRIG   ___|   |_______________________________________________________|   |____
    241                      >10us _   _   _   _   _   _   _   _          at least 10ms wait
    242           SENSOR _________| |_| |_| |_| |_| |_| |_| |_| |________________________________
    243                                Send 8 40KHz wave
    244                                                             ________
    245           ECHO   __________________________________________|        |____________________
    246                                                            10us ~ 18ms
    247           */

   \                                 In section .text, align 4, keep-with-next
    248          void sonar_heartbeat(void)
    249          {
   \                     sonar_heartbeat: (+1)
   \        0x0   0xE92D 0x42FC      PUSH     {R2-R7,R9,LR}
    250              if (g_sonar_ch >= CONFIG_SONAR_CHANNEL_NUM) {
   \        0x4   0x....             LDR.N    R5,??DataTable8_1
   \        0x6   0x....             LDR.N    R4,??DataTable8_2
   \        0x8   0x7828             LDRB     R0,[R5, #+0]
   \        0xA   0x2804             CMP      R0,#+4
   \        0xC   0xDB03             BLT.N    ??sonar_heartbeat_1
    251                  g_sonar_ch = 0;
   \        0xE   0x2100             MOVS     R1,#+0
   \       0x10   0x7029             STRB     R1,[R5, #+0]
    252                  g_sonar[g_sonar_ch].state = SONAR_INIT;
   \       0x12   0x2001             MOVS     R0,#+1
   \       0x14   0x7020             STRB     R0,[R4, #+0]
    253              }
    254          
    255              switch (g_sonar[g_sonar_ch].state) {
   \                     ??sonar_heartbeat_1: (+1)
   \       0x16   0x2614             MOVS     R6,#+20
   \       0x18   0x782F             LDRB     R7,[R5, #+0]
   \       0x1A   0xFB06 0xF907      MUL      R9,R6,R7
   \       0x1E   0xF814 0x0009      LDRB     R0,[R4, R9]
   \       0x22   0x1E40             SUBS     R0,R0,#+1
   \       0x24   0x2803             CMP      R0,#+3
   \       0x26   0xF200 0x8096      BHI.W    ??sonar_heartbeat_2
   \       0x2A   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??sonar_heartbeat_0:
   \       0x2E   0x02 0x32          DC8      0x2,0x32,0x5B,0x80

   \              0x5B 0x80
    256              case SONAR_INIT:
    257                  sonar_trigger(g_sonar_ch);
   \                     ??sonar_heartbeat_3: (+1)
   \       0x32   0x2F04             CMP      R7,#+4
   \       0x34   0xDA20             BGE.N    ??sonar_heartbeat_4
   \       0x36   0x2101             MOVS     R1,#+1
   \       0x38   0x4638             MOV      R0,R7
   \       0x3A   0x.... 0x....      BL       SONAR_TRIG
   \       0x3E   0x2014             MOVS     R0,#+20
   \       0x40   0x.... 0x....      BL       _delay_us
   \       0x44   0x2100             MOVS     R1,#+0
   \       0x46   0x4638             MOV      R0,R7
   \       0x48   0x.... 0x....      BL       SONAR_TRIG
   \       0x4C   0x....             LDR.N    R0,??DataTable8
   \       0x4E   0x4448             ADD      R0,R0,R9
   \       0x50   0x6907             LDR      R7,[R0, #+16]
   \       0x52   0xB2F9             UXTB     R1,R7
   \       0x54   0x2004             MOVS     R0,#+4
   \       0x56   0x.... 0x....      BL       GPIO_EXTILineConfig
   \       0x5A   0x2100             MOVS     R1,#+0
   \       0x5C   0xF88D 0x1004      STRB     R1,[SP, #+4]
   \       0x60   0x2210             MOVS     R2,#+16
   \       0x62   0x2101             MOVS     R1,#+1
   \       0x64   0xF88D 0x2005      STRB     R2,[SP, #+5]
   \       0x68   0xF88D 0x1006      STRB     R1,[SP, #+6]
   \       0x6C   0xFA01 0xF707      LSL      R7,R1,R7
   \       0x70   0x9700             STR      R7,[SP, #+0]
   \       0x72   0x4668             MOV      R0,SP
   \       0x74   0x.... 0x....      BL       EXTI_Init
    258                  g_sonar[g_sonar_ch].state++;    /* Move to next state. */
   \                     ??sonar_heartbeat_4: (+1)
   \       0x78   0x7828             LDRB     R0,[R5, #+0]
   \       0x7A   0x4370             MULS     R0,R6,R0
   \       0x7C   0x5C21             LDRB     R1,[R4, R0]
   \       0x7E   0x1C49             ADDS     R1,R1,#+1
   \       0x80   0x5421             STRB     R1,[R4, R0]
    259                  g_sonar[g_sonar_ch].ticks = getms();
   \       0x82   0x.... 0x....      BL       getms
   \       0x86   0x782A             LDRB     R2,[R5, #+0]
   \       0x88   0xF104 0x010C      ADD      R1,R4,#+12
   \       0x8C   0x4356             MULS     R6,R6,R2
   \       0x8E   0x5188             STR      R0,[R1, R6]
    260                  break;
   \       0x90   0xE05F             B.N      ??sonar_heartbeat_5
    261              case SONAR_MEASURE: /* Wait until measurement done. */
    262                  if (getms() - g_sonar[g_sonar_ch].ticks > CONFIG_SONAR_TIMEOUT_MS) {
   \                     ??sonar_heartbeat_6: (+1)
   \       0x92   0x.... 0x....      BL       getms
   \       0x96   0x782B             LDRB     R3,[R5, #+0]
   \       0x98   0xF104 0x020C      ADD      R2,R4,#+12
   \       0x9C   0x4373             MULS     R3,R6,R3
   \       0x9E   0x58D1             LDR      R1,[R2, R3]
   \       0xA0   0x1A40             SUBS     R0,R0,R1
   \       0xA2   0x2833             CMP      R0,#+51
   \       0xA4   0xD355             BCC.N    ??sonar_heartbeat_5
    263                      /* Timeout. Abort measurement and move to next channel. */
    264                      TIM_Cmd(SONAR_TIMER, DISABLE);
   \       0xA6   0x2100             MOVS     R1,#+0
   \       0xA8   0x....             LDR.N    R0,??DataTable8_5
   \       0xAA   0x.... 0x....      BL       TIM_Cmd
    265                      sonar_shutdown(g_sonar_ch);
   \       0xAE   0x7828             LDRB     R0,[R5, #+0]
   \       0xB0   0x.... 0x....      BL       sonar_shutdown
    266                      g_sonar[g_sonar_ch].ticks = getms();
   \       0xB4   0x.... 0x....      BL       getms
   \       0xB8   0x782F             LDRB     R7,[R5, #+0]
   \       0xBA   0x437E             MULS     R6,R6,R7
   \       0xBC   0xF104 0x020C      ADD      R2,R4,#+12
    267                      g_sonar[g_sonar_ch].state = SONAR_IDLE;
    268          			memset(g_sonar[g_sonar_ch].sample, 0, sizeof(g_sonar[g_sonar_ch].sample));
   \       0xC0   0x19A3             ADDS     R3,R4,R6
   \       0xC2   0x5190             STR      R0,[R2, R6]
   \       0xC4   0x2108             MOVS     R1,#+8
   \       0xC6   0x2000             MOVS     R0,#+0
   \       0xC8   0x55A0             STRB     R0,[R4, R6]
    269                      g_sonar_ch++;
   \       0xCA   0x1C7F             ADDS     R7,R7,#+1
   \       0xCC   0x1D18             ADDS     R0,R3,#+4
   \       0xCE   0x.... 0x....      BL       __aeabi_memclr
    270                      if (g_sonar_ch >= CONFIG_SONAR_CHANNEL_NUM) {
   \       0xD2   0xB2F8             UXTB     R0,R7
   \       0xD4   0x2804             CMP      R0,#+4
   \       0xD6   0xBFA8             IT       GE
   \       0xD8   0x2700             MOVGE    R7,#+0
    271                          g_sonar_ch = 0;
   \       0xDA   0x702F             STRB     R7,[R5, #+0]
    272                      }
    273                      drv_led_set(0, 0, 0);
   \       0xDC   0x2200             MOVS     R2,#+0
   \       0xDE   0x2100             MOVS     R1,#+0
   \       0xE0   0x2000             MOVS     R0,#+0
   \       0xE2   0xE021             B.N      ??sonar_heartbeat_7
    274                  }
    275                  break;
    276              case SONAR_DONE:    /* Measurement is done. */
    277                  if (g_sonar[g_sonar_ch].cnt == 0) {
   \                     ??sonar_heartbeat_8: (+1)
   \       0xE4   0xEB04 0x0109      ADD      R1,R4,R9
   \       0xE8   0x7888             LDRB     R0,[R1, #+2]
   \       0xEA   0xB390             CBZ.N    R0,??sonar_heartbeat_5
    278                      break;
    279                  }
    280                  if (g_sonar[g_sonar_ch].cnt >= CONFIG_SONAR_SAMPLE_SIZE) {
   \       0xEC   0x2804             CMP      R0,#+4
   \       0xEE   0xBFA4             ITT      GE
   \       0xF0   0x2004             MOVGE    R0,#+4
   \       0xF2   0x7088             STRBGE   R0,[R1, #+2]
    281                      g_sonar[g_sonar_ch].cnt = CONFIG_SONAR_SAMPLE_SIZE;
    282                  }
    283                  sonar_distance(g_sonar_ch);
   \       0xF4   0x4638             MOV      R0,R7
   \       0xF6   0x.... 0x....      BL       sonar_distance
    284                  g_sonar[g_sonar_ch].state++;
   \       0xFA   0xF814 0x0009      LDRB     R0,[R4, R9]
   \       0xFE   0x1C40             ADDS     R0,R0,#+1
   \      0x100   0xF804 0x0009      STRB     R0,[R4, R9]
    285                  /* Blink the led by channel. */
    286                  drv_led_set((g_sonar_ch%3)==0?0x10:0, (g_sonar_ch%3)==1?0x10:0, (g_sonar_ch%3)==2?0x10:0);
   \      0x104   0x2103             MOVS     R1,#+3
   \      0x106   0xFB97 0xF0F1      SDIV     R0,R7,R1
   \      0x10A   0xEB00 0x0040      ADD      R0,R0,R0, LSL #+1
   \      0x10E   0x1A38             SUBS     R0,R7,R0
   \      0x110   0x2802             CMP      R0,#+2
   \      0x112   0xBF0C             ITE      EQ
   \      0x114   0x2210             MOVEQ    R2,#+16
   \      0x116   0x2200             MOVNE    R2,#+0
   \      0x118   0x2801             CMP      R0,#+1
   \      0x11A   0xBF0C             ITE      EQ
   \      0x11C   0x2110             MOVEQ    R1,#+16
   \      0x11E   0x2100             MOVNE    R1,#+0
   \      0x120   0x2800             CMP      R0,#+0
   \      0x122   0xBF0C             ITE      EQ
   \      0x124   0x2010             MOVEQ    R0,#+16
   \      0x126   0x2000             MOVNE    R0,#+0
   \                     ??sonar_heartbeat_7: (+1)
   \      0x128   0x.... 0x....      BL       drv_led_set
    287                  sonar_dbg("ch %d, distance %d\r\n", g_sonar_ch, g_sonar[g_sonar_ch].distance);
    288                  break;
   \      0x12C   0xE011             B.N      ??sonar_heartbeat_5
    289              case SONAR_EXIT:    /* Channel measurement is done. Move to next. */
    290                  sonar_shutdown(g_sonar_ch);
   \                     ??sonar_heartbeat_9: (+1)
   \      0x12E   0x4638             MOV      R0,R7
   \      0x130   0x.... 0x....      BL       sonar_shutdown
    291                  g_sonar[g_sonar_ch].ticks = getms();
   \      0x134   0x.... 0x....      BL       getms
   \      0x138   0x7829             LDRB     R1,[R5, #+0]
   \      0x13A   0x434E             MULS     R6,R6,R1
   \      0x13C   0xF104 0x030C      ADD      R3,R4,#+12
    292                  g_sonar[g_sonar_ch].state = SONAR_IDLE;
    293                  g_sonar_ch++;
   \      0x140   0x1C49             ADDS     R1,R1,#+1
   \      0x142   0x5198             STR      R0,[R3, R6]
   \      0x144   0x2000             MOVS     R0,#+0
   \      0x146   0x55A0             STRB     R0,[R4, R6]
    294                  if (g_sonar_ch >= CONFIG_SONAR_CHANNEL_NUM) {
   \      0x148   0xB2CC             UXTB     R4,R1
   \      0x14A   0x2C04             CMP      R4,#+4
   \      0x14C   0xBFA8             IT       GE
   \      0x14E   0x2100             MOVGE    R1,#+0
    295                      g_sonar_ch = 0;
   \      0x150   0x7029             STRB     R1,[R5, #+0]
    296                  }
    297                  break;
    298              default:
    299                  g_sonar[g_sonar_ch].state = SONAR_INIT;
    300                  break;
    301              }
    302          
    303              return ;
   \                     ??sonar_heartbeat_5: (+1)
   \      0x152   0xE8BD 0x82F3      POP      {R0,R1,R4-R7,R9,PC}
   \                     ??sonar_heartbeat_2: (+1)
   \      0x156   0x2001             MOVS     R0,#+1
   \      0x158   0xF804 0x0009      STRB     R0,[R4, R9]
   \      0x15C   0xE7F9             B.N      ??sonar_heartbeat_5
    304          }
    305          
    306          /**
    307           @brief Get Sonar channel distance measurement value.
    308           @param ch - Sonar channel number, 1 ~ CONFIG_SONAR_CHANNEL_NUM.
    309           @return return disatance measured in mm.
    310           */

   \                                 In section .text, align 2, keep-with-next
    311          uint32_t sonar_get(uint8_t ch)
    312          {
   \                     sonar_get: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    313              if (ch >= CONFIG_SONAR_CHANNEL_NUM) {
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x2C04             CMP      R4,#+4
   \        0x6   0xDB01             BLT.N    ??sonar_get_0
    314                  return 0;
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0xBD10             POP      {R4,PC}
    315              }
    316          
    317              sonar_distance(ch);
   \                     ??sonar_get_0: (+1)
   \        0xC   0x.... 0x....      BL       sonar_distance
    318              return g_sonar[ch].distance;
   \       0x10   0x2014             MOVS     R0,#+20
   \       0x12   0x....             LDR.N    R1,??DataTable8_2
   \       0x14   0x4344             MULS     R4,R0,R4
   \       0x16   0x1908             ADDS     R0,R1,R4
   \       0x18   0x6900             LDR      R0,[R0, #+16]
   \       0x1A   0xBD10             POP      {R4,PC}
    319          }
    320          
    321          /**
    322           @brief Initialize ultrasonic sonar module.
    323           @param None.
    324           @return None.
    325           */

   \                                 In section .text, align 2, keep-with-next
    326          void sonar_init(void)
    327          {
   \                     sonar_init: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    328              uint8_t ch;
    329          
    330              /* These pins are pull up by default. So pull down them. */
    331              for (ch = 0; ch < CONFIG_SONAR_CHANNEL_NUM; ch++) {
   \        0x2   0x2400             MOVS     R4,#+0
    332                  pinMode(g_sonar_cfg[ch].echo_port, g_sonar_cfg[ch].echo_pin,
    333                          GPIO_Mode_IPD, GPIO_Speed_10MHz);
   \                     ??sonar_init_0: (+1)
   \        0x4   0x2114             MOVS     R1,#+20
   \        0x6   0x....             LDR.N    R0,??DataTable8
   \        0x8   0x4361             MULS     R1,R1,R4
   \        0xA   0x1845             ADDS     R5,R0,R1
   \        0xC   0x89A9             LDRH     R1,[R5, #+12]
   \        0xE   0x68A8             LDR      R0,[R5, #+8]
   \       0x10   0x2301             MOVS     R3,#+1
   \       0x12   0x2228             MOVS     R2,#+40
   \       0x14   0x.... 0x....      BL       pinMode
    334                  pinMode(g_sonar_cfg[ch].trig_port, g_sonar_cfg[ch].trig_pin,
    335                          GPIO_Mode_Out_PP, GPIO_Speed_50MHz);
   \       0x18   0x88A9             LDRH     R1,[R5, #+4]
   \       0x1A   0x6828             LDR      R0,[R5, #+0]
   \       0x1C   0x2303             MOVS     R3,#+3
   \       0x1E   0x2210             MOVS     R2,#+16
   \       0x20   0x.... 0x....      BL       pinMode
    336                  SONAR_TRIG(ch, 0);
   \       0x24   0x2100             MOVS     R1,#+0
   \       0x26   0xB2E0             UXTB     R0,R4
   \       0x28   0x.... 0x....      BL       SONAR_TRIG
    337              }
   \       0x2C   0x1C64             ADDS     R4,R4,#+1
   \       0x2E   0x2C04             CMP      R4,#+4
   \       0x30   0xDBE8             BLT.N    ??sonar_init_0
    338          
    339              /* Enable line5 ~ line9 external interrupt. */
    340          
    341              memset(g_sonar, 0, sizeof(g_sonar));
   \       0x32   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \       0x36   0x....             B.N      ?Subroutine0
    342          }
    343          
    344          /**
    345           @brief Clean ultrasonic sonar module.
    346           @param None.
    347           @return None.
    348           */

   \                                 In section .text, align 2, keep-with-next
    349          void sonar_exit(void)
    350          {
   \                     sonar_exit: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    351              uint8_t ch;
    352          
    353              for (ch = 0; ch < CONFIG_SONAR_CHANNEL_NUM; ch++) { 
   \        0x2   0x2400             MOVS     R4,#+0
    354                  SONAR_TRIG(ch, 0);
   \                     ??sonar_exit_0: (+1)
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0xB2E0             UXTB     R0,R4
   \        0x8   0x.... 0x....      BL       SONAR_TRIG
    355              }
   \        0xC   0x1C64             ADDS     R4,R4,#+1
   \        0xE   0xB2E2             UXTB     R2,R4
   \       0x10   0x2A04             CMP      R2,#+4
   \       0x12   0xDBF7             BLT.N    ??sonar_exit_0
    356          
    357              /* Disable line5 ~ line9 external interrupt. */
    358          
    359              memset(g_sonar, 0, sizeof(g_sonar));
   \       0x14   0xE8BD 0x4010      POP      {R4,LR}
   \       0x18                      REQUIRE ?Subroutine0
   \       0x18                      ;; // Fall through to label ?Subroutine0
    360          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0x2150             MOVS     R1,#+80
   \        0x2   0x....             LDR.N    R0,??DataTable8_2
   \        0x4   0x.... 0x....      B.W      __aeabi_memclr4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \        0x0   0x....'....        DC32     g_sonar_cfg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \        0x0   0x....'....        DC32     g_sonar_ch

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \        0x0   0x....'....        DC32     g_sonar

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \        0x0   0x408F'4000        DC32     0x408f4000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \        0x0   0x4075'7970        DC32     0x40757970

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \        0x0   0x4000'1000        DC32     0x40001000
    361          
    362          /** @} */
    363          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      40   EXTI9_5_IRQHandler
        40   -> EXTI_ClearITPendingBit
        40   -> EXTI_GetITStatus
        40   -> GPIO_ReadInputDataBit
        40   -> RCC_APB1PeriphClockCmd
        40   -> TIM_Cmd
        40   -> TIM_GetCounter
        40   -> TIM_SetCounter
        40   -> TIM_TimeBaseInit
       0   SONAR_TRIG
         0   -> GPIO_ResetBits
         0   -> GPIO_SetBits
       8   pinMode
         8   -> GPIO_Init
      24   sonar_distance
        24   -> __aeabi_d2f
        24   -> __aeabi_ddiv
        24   -> __aeabi_dmul
        24   -> __aeabi_f2uiz
        24   -> __aeabi_ui2d
       8   sonar_exit
         8   -> SONAR_TRIG
         0   -> __aeabi_memclr4
       8   sonar_get
         8   -> sonar_distance
      32   sonar_heartbeat
        32   -> EXTI_Init
        32   -> GPIO_EXTILineConfig
        32   -> SONAR_TRIG
        32   -> TIM_Cmd
        32   -> __aeabi_memclr
        32   -> _delay_us
        32   -> drv_led_set
        32   -> getms
        32   -> sonar_distance
        32   -> sonar_shutdown
      16   sonar_init
        16   -> SONAR_TRIG
         0   -> __aeabi_memclr4
        16   -> pinMode
      16   sonar_shutdown
        16   -> EXTI_Init
        16   -> SONAR_TRIG


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       8  ?Subroutine0
     186  EXTI9_5_IRQHandler
      24  SONAR_TRIG
      80  g_sonar
      80  g_sonar_cfg
       1  g_sonar_ch
      22  pinMode
      98  sonar_distance
      24  sonar_exit
      28  sonar_get
     350  sonar_heartbeat
      56  sonar_init
      54  sonar_shutdown

 
  81 bytes in section .bss
  80 bytes in section .rodata
 874 bytes in section .text
 
 874 bytes of CODE  memory
  80 bytes of CONST memory
  81 bytes of DATA  memory

Errors: none
Warnings: none
